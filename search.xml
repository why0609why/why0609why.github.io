<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2020/11/19/leetcode--imsp/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>c++知识点</title>
    <url>/2020/03/18/c++%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="stl"><a href="#stl" class="headerlink" title="stl"></a>stl</h1><h2 id="优先队列的排序"><a href="#优先队列的排序" class="headerlink" title="优先队列的排序"></a>优先队列的排序</h2><h3 id="优先队列存储基本类型"><a href="#优先队列存储基本类型" class="headerlink" title="优先队列存储基本类型"></a>优先队列存储基本类型</h3><p>存储基本类型很简单，因为内置类型的优先级很好判断，所以在使用最大堆和最小堆的时候只需要使用greater<typename>和less<typename>就行了。<br>其实greater和less很好分辨，greater是越来越大，那在堆顶的自然就是最小的，然后最小的优先级高，自然是最小堆，less同理。</typename></typename></p>
<p>比如最小堆存储int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int是优先队列里面存储元素的类型</span></span><br><span class="line">    <span class="comment">//vector是优先队列的底部实现</span></span><br><span class="line">    <span class="comment">//greater最小堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(<span class="number">-1</span>);</span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    q.push(<span class="number">10</span>);</span><br><span class="line">    q.push(<span class="number">22</span>);</span><br><span class="line">    q.push(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大堆存储int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int是优先队列里面存储元素的类型</span></span><br><span class="line">    <span class="comment">//vector是优先队列的底部实现</span></span><br><span class="line">    <span class="comment">//greater最小堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(<span class="number">-1</span>);</span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    q.push(<span class="number">10</span>);</span><br><span class="line">    q.push(<span class="number">22</span>);</span><br><span class="line">    q.push(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//22,20,10,5,-1</span></span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后优先队列存储string之类的，也是和上面同理，string比较的是字典序</p>
<h3 id="优先队列存储自定义类型"><a href="#优先队列存储自定义类型" class="headerlink" title="优先队列存储自定义类型"></a>优先队列存储自定义类型</h3><p>因为自定义类型需要自定义比较规则，所以需要自定义比较器。<br>c++默认优先队列的最大堆。因为java是自定义比较器返回int值，直接就代表优先级，但是c++返回的是bool，所以true或者false可以看成父节点和子节点是否交换。就是一个siftUp的过程，每次看父节点和子节点比较的返回值来代表父节点和子节点是否交换。</p>
<p>比如这里年龄从小到大排序，年龄相同就按照字典序排序，那么这里每次看的是如果父节点的年龄属性大那就和子节点交换，那么如此不断交换，那么堆顶的一定是年龄最小的。其他的类型定义自定义比较器的时候都可以按照这个道理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似于class中的构造函数快速赋值</span></span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="built_in">string</span> name) : age(age), name(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比如说这里就想让优先队列排序是：年龄最小的在堆顶，年龄相同的看名字的字典序的大小。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当这个条件发生的时候，在siftUp的过程中父节点和子节点交换</span></span><br><span class="line">        <span class="keyword">return</span> p1.age &gt; p2.age || (p1.age == p2.age &amp;&amp; p1.name &gt; p2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Person, <span class="built_in">vector</span>&lt;Person&gt;, cmp&gt; q;</span><br><span class="line">    q.push(Person(<span class="number">10</span>, <span class="string">"zs"</span>));</span><br><span class="line">    q.push(Person(<span class="number">18</span>, <span class="string">"lisi"</span>));</span><br><span class="line">    q.push(Person(<span class="number">13</span>, <span class="string">"ww"</span>));</span><br><span class="line">    q.push(Person(<span class="number">10</span>, <span class="string">"zl"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top().name &lt;&lt; <span class="string">":"</span> &lt;&lt; q.top().age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果：可以发现，年龄大的优先级高，年龄小的优先级的，因为是最小堆所以</span></span><br><span class="line">    <span class="comment">//zl:10</span></span><br><span class="line">    <span class="comment">//zs:10</span></span><br><span class="line">    <span class="comment">//ww:13</span></span><br><span class="line">    <span class="comment">//lisi:18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列总结"><a href="#优先队列总结" class="headerlink" title="优先队列总结"></a>优先队列总结</h2><ol>
<li>在sort中greater和less就直接代表的是从大到小和从小到大</li>
<li>在优先队列中，greater和less分别代表最小堆和最大堆。原因很好理解，因为在自定义比较器的方法里面返回的是bool，而且这个bool的作用是，如果bool是true，那就说明shiftUp的过程中父节点和子节点是要交换的，又因为greater用于基本类型而且greater内部是x &gt; y，那就说明在shiftUp的过程中如果父节点比子节点大，那就交换父子节点，如此，最终堆顶一定是最小的，这也就解释了greater是最小堆的原因。</li>
<li>如何书写自定义比较器，一定要明确一个点，自定义比较器的返回值是在shiftUp的过程中如果父节点比子节点大，那就交换父子节点的参考，如果返回值是true，那就交换。如此就能写出优先级。此处和java不一样，java是直接根据堆是最小堆(java的PriorityQueue底层是最小堆)，然后直接按照对应的条件返回优先级(返回值1是优先级高，-1是优先级低)，和c++的返回bool来决定父子节点是否交换是不同的。</li>
</ol>
<h2 id="sort进行排序"><a href="#sort进行排序" class="headerlink" title="sort进行排序"></a>sort进行排序</h2><h3 id="sort对数组排序"><a href="#sort对数组排序" class="headerlink" title="sort对数组排序"></a>sort对数组排序</h3><p>对数组排序无非就是从大到小，或者从小到大排序</p>
<h4 id="从小到大排序"><a href="#从小到大排序" class="headerlink" title="从小到大排序"></a>从小到大排序</h4><p>sort默认是从小到大排序的，可以直接调用sort</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里要从数组的开头到数组的末尾</span></span><br><span class="line">    sort(a, a + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以模板里的less函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个和上面那个是完全一样的，因为sort默认第三个参数就是less&lt;int&gt;()</span></span><br><span class="line">    sort(a, a + <span class="number">5</span>, less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自定义比较函数cmp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    sort(a, a + <span class="number">5</span>, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自定义一个比较器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bool cmp(int x, int y) &#123;</span></span><br><span class="line"><span class="comment">//    return x &lt; y;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//能看到比较器和比较函数很像</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    sort(a, a + <span class="number">5</span>, cmp());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从大到小排序"><a href="#从大到小排序" class="headerlink" title="从大到小排序"></a>从大到小排序</h4><p>因为sort默认是从小到大的，所以要从大到小排序可以选择greater<int></int></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    sort(a, a + <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//22,20,10,5,-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用自定义的比较函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    sort(a, a + <span class="number">5</span>, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//22,20,10,5,-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用自定义比较器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    sort(a, a + <span class="number">5</span>, cmp());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//22,20,10,5,-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对vector排序"><a href="#对vector排序" class="headerlink" title="对vector排序"></a>对vector排序</h3><p>和数组一样无非也是从大到小或者从小到大</p>
<h4 id="从小到大排序-1"><a href="#从小到大排序-1" class="headerlink" title="从小到大排序"></a>从小到大排序</h4><p>和排序数组一样，可以直接不用第三个参数来排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">22</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">-1</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接用less<int>()作为第三个参数</int></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">22</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">-1</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自定义比较函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">22</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">-1</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自定义比较器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">22</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">-1</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmp());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从大到小排序-1"><a href="#从大到小排序-1" class="headerlink" title="从大到小排序"></a>从大到小排序</h4><p>使用sort进行从大到小排序需要第三个参数<br>使用greater</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">22</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">-1</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//22,20,10,5,-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义比较函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">22</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">-1</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//22,20,10,5,-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义比较器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">22</span>);</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">-1</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmp());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用vector对自定义类型存储"><a href="#使用vector对自定义类型存储" class="headerlink" title="使用vector对自定义类型存储"></a>使用vector对自定义类型存储</h4><p>因为自定义存储类型，比如人这个类、或者车，那就要定义自定义类型对应的比较规则。<br>自定义比较器来比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义人这个类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似于class中的构造函数快速赋值</span></span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="built_in">string</span> name) : age(age), name(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义人的这个比较器，年龄从小到大，年龄相同的话按照名字的字典序从小到大</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这其实是自定义的less</span></span><br><span class="line">        <span class="keyword">return</span> p1.age &lt; p2.age || (p1.age == p2.age &amp;&amp; p1.name &lt; p2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    v.push_back(Person(<span class="number">10</span>, <span class="string">"zs"</span>));</span><br><span class="line">    v.push_back(Person(<span class="number">18</span>, <span class="string">"lisi"</span>));</span><br><span class="line">    v.push_back(Person(<span class="number">13</span>, <span class="string">"ww"</span>));</span><br><span class="line">    v.push_back(Person(<span class="number">10</span>, <span class="string">"zl"</span>));</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmp());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Person p : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.name &lt;&lt; <span class="string">"---"</span> &lt;&lt; p.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果：能发现是按照年龄从小到大，字典序从小到大排序的。</span></span><br><span class="line">    <span class="comment">//zl---10</span></span><br><span class="line">    <span class="comment">//zs---10</span></span><br><span class="line">    <span class="comment">//ww---13</span></span><br><span class="line">    <span class="comment">//lisi---18</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样也是可以使用自定义函数来的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似于class中的构造函数快速赋值</span></span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="built_in">string</span> name) : age(age), name(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数的写法和之前相同，逻辑和自定义比较器相同</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.age &lt; p2.age || (p1.age == p2.age &amp;&amp; p1.name &lt; p2.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    v.push_back(Person(<span class="number">10</span>, <span class="string">"zs"</span>));</span><br><span class="line">    v.push_back(Person(<span class="number">18</span>, <span class="string">"lisi"</span>));</span><br><span class="line">    v.push_back(Person(<span class="number">13</span>, <span class="string">"ww"</span>));</span><br><span class="line">    v.push_back(Person(<span class="number">10</span>, <span class="string">"zl"</span>));</span><br><span class="line"></span><br><span class="line">    sort(v.begin(), v.end(), cmp);</span><br><span class="line">    <span class="keyword">for</span> (Person p : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.name &lt;&lt; <span class="string">"---"</span> &lt;&lt; p.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用sort的总结"><a href="#使用sort的总结" class="headerlink" title="使用sort的总结"></a>使用sort的总结</h3><ol>
<li><p>sort默认是less的，也就是从小到大的，这里的less和优先队列的less不同，后面会讲。</p>
</li>
<li><p>sort里使用的less是从小到大，greater是从大到小<br>可以看一下less和greater的源码<br>less的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">greater</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line">    <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> greater的</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">less</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x&lt;y;&#125;</span><br><span class="line">    <span class="keyword">typedef</span> T first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> T second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">bool</span> result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 可以看到不管是less还是greater，里面的结构和自定义的比较器很像</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 所以某种意义上来说greater和less的使用完全可以被自定义比较器代替。</p>
</li>
<li><p>自定义比较器和自定义比较函数的使用：看心情，注意用自定义比较器的时候参数是cmp()，而自定义比较函数的时候是cmp。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较器</span></span><br><span class="line">sort(v.begin(), v.end(), cmp());</span><br><span class="line"><span class="comment">//greater</span></span><br><span class="line">sort(a, a + <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">//less</span></span><br><span class="line">sort(a, a + <span class="number">5</span>, less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line">sort(v.begin(), v.end(), cmp);</span><br></pre></td></tr></table></figure>

<p> 能看到因为greater和less都是比较器的关系，在参数那里都有括号，比较函数是没有的</p>
</li>
<li><p>在使用数组或者vector存储基本类型的时候，用greater或者less比较方便。存储自定义类型的时候，用自定义比较器或者自定义函数比较方便。</p>
</li>
<li><p>最后说一遍，在自定义比较器或者自定义比较函数里，你希望从小到大排序的话，那就写x &lt; y，这也是less，反之就是x &gt; y，这是greater。这里的less和greater是具体自定义比较器或者自定义比较函数里面的小于号和大于号，和堆里面的不一样。</p>
</li>
</ol>
<h2 id="对set的排序"><a href="#对set的排序" class="headerlink" title="对set的排序"></a>对set的排序</h2><h3 id="set存储基本类型"><a href="#set存储基本类型" class="headerlink" title="set存储基本类型"></a>set存储基本类型</h3><h4 id="从小到大"><a href="#从小到大" class="headerlink" title="从小到大"></a>从小到大</h4><p>因为set是有默认排序的，而且还是less的，而又因为在存储基本类型的时候，自定义类型数据在set中默认是less，从小到大存储的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.insert(<span class="number">5</span>);</span><br><span class="line">    s.insert(<span class="number">-1</span>);</span><br><span class="line">    s.insert(<span class="number">10</span>);</span><br><span class="line">    s.insert(<span class="number">20</span>);</span><br><span class="line">    s.insert(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//-1,5,10,20,22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从大到小"><a href="#从大到小" class="headerlink" title="从大到小"></a>从大到小</h4><p>通过自定义比较器来实现从大到小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意这里传入了比较器</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>,cmp&gt; s;</span><br><span class="line">    s.insert(<span class="number">5</span>);</span><br><span class="line">    s.insert(<span class="number">-1</span>);</span><br><span class="line">    s.insert(<span class="number">10</span>);</span><br><span class="line">    s.insert(<span class="number">20</span>);</span><br><span class="line">    s.insert(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//22,20,10,5,-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set存储自定义类型"><a href="#set存储自定义类型" class="headerlink" title="set存储自定义类型"></a>set存储自定义类型</h3><p>自定义类型就不再局限于从大到小或者从小到大，需要自定义比较规则<br>而且在存储自定义类型的时候一定要自定义比较器，不然set不知道怎么排序你的类型，就会报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似于class中的构造函数快速赋值</span></span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="built_in">string</span> name) : age(age), name(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义人的这个比较器，年龄从小到大，年龄相同的话按照名字的字典序从小到大</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这其实是自定义的less</span></span><br><span class="line">        <span class="keyword">return</span> p1.age &lt; p2.age || (p1.age == p2.age &amp;&amp; p1.name &lt; p2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;Person, cmp&gt; s;</span><br><span class="line">    s.insert(Person(<span class="number">10</span>, <span class="string">"zs"</span>));</span><br><span class="line">    s.insert(Person(<span class="number">18</span>, <span class="string">"lisi"</span>));</span><br><span class="line">    s.insert(Person(<span class="number">13</span>, <span class="string">"ww"</span>));</span><br><span class="line">    s.insert(Person(<span class="number">10</span>, <span class="string">"zl"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Person p: s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p.name &lt;&lt; <span class="string">"---"</span> &lt;&lt; p.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果：能发现是按照年龄从小到大，字典序从小到大排序的。</span></span><br><span class="line">    <span class="comment">//zl---10</span></span><br><span class="line">    <span class="comment">//zs---10</span></span><br><span class="line">    <span class="comment">//ww---13</span></span><br><span class="line">    <span class="comment">//lisi---18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对map的排序"><a href="#对map的排序" class="headerlink" title="对map的排序"></a>对map的排序</h2><h3 id="map存储基本类型"><a href="#map存储基本类型" class="headerlink" title="map存储基本类型"></a>map存储基本类型</h3><h4 id="键从小到大"><a href="#键从小到大" class="headerlink" title="键从小到大"></a>键从小到大</h4><p>map的键默认是有序的，而且map中的键是less排布的，也是从小到大的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    m[<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">22</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">20</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">":"</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果：是按照键值从小到大排序的</span></span><br><span class="line">    <span class="comment">//-1:0</span></span><br><span class="line">    <span class="comment">//5:0</span></span><br><span class="line">    <span class="comment">//10:0</span></span><br><span class="line">    <span class="comment">//20:0</span></span><br><span class="line">    <span class="comment">//22:0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从大到小-1"><a href="#从大到小-1" class="headerlink" title="从大到小"></a>从大到小</h4><p>那么自然也是可以用自定义比较器来使键值从大到小排序的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键值从大到小排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, cmp&gt; m;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    m[<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">22</span>] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">20</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">":"</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果：可以发现键值从大到小</span></span><br><span class="line">    <span class="comment">//22:0</span></span><br><span class="line">    <span class="comment">//20:0</span></span><br><span class="line">    <span class="comment">//10:0</span></span><br><span class="line">    <span class="comment">//5:0</span></span><br><span class="line">    <span class="comment">//-1:0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map存储自定义类型"><a href="#map存储自定义类型" class="headerlink" title="map存储自定义类型"></a>map存储自定义类型</h3><p>存储自定义类型需要自定义比较规则，就不再局限于简单的从大到小或者从小到大<br>同set一样，如果不自定义比较器给set，那么容器就不知道你要怎么排序，然后报错，所以map也需要自定义比较器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似于class中的构造函数快速赋值</span></span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="built_in">string</span> name) : age(age), name(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义人的这个比较器，年龄从小到大，年龄相同的话按照名字的字典序从小到大</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这其实是自定义的less</span></span><br><span class="line">        <span class="keyword">return</span> p1.age &lt; p2.age || (p1.age == p2.age &amp;&amp; p1.name &lt; p2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;Person, <span class="keyword">int</span>, cmp&gt; m;</span><br><span class="line">    <span class="built_in">map</span>&lt;Person, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    m[Person(<span class="number">10</span>, <span class="string">"zs"</span>)] = <span class="number">0</span>;</span><br><span class="line">    m[Person(<span class="number">18</span>, <span class="string">"lisi"</span>)] = <span class="number">0</span>;</span><br><span class="line">    m[Person(<span class="number">13</span>, <span class="string">"ww"</span>)] = <span class="number">0</span>;</span><br><span class="line">    m[Person(<span class="number">10</span>, <span class="string">"zl"</span>)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first.name &lt;&lt; <span class="string">":"</span> &lt;&lt; it-&gt;first.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果:可以发现键的排布，就是按照自定义的比较器来的</span></span><br><span class="line"><span class="comment">//  zl:10</span></span><br><span class="line"><span class="comment">//  zs:10</span></span><br><span class="line"><span class="comment">//  ww:13</span></span><br><span class="line"><span class="comment">//  lisi:18</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="sizeof很常用"><a href="#sizeof很常用" class="headerlink" title="sizeof很常用"></a>sizeof很常用</h2><p>c++里面的数组没有直接获取数组长度的方法，所以可以用sizeof来获得数组长度<br>具体操作： 数组长度 = sizeof(数组)/sizeof(数组里面的元素)<br>比如 int a[10];<br>那么sizeof(a)就是40，sizeof(int)是4。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明数组</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]); ++j) &#123;</span><br><span class="line">            a[i][j] = t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]); ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实sizeof()参数既可以传递变量，也可以传递类型。</p>
<h2 id="不用迭代器遍历map"><a href="#不用迭代器遍历map" class="headerlink" title="不用迭代器遍历map"></a>不用迭代器遍历map</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"zd"</span>] = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"why"</span>] = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为map的元素是键值对，所以可以用pair来使用增强for遍历map</span></span><br><span class="line"><span class="keyword">for</span> (pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p:<span class="built_in">map</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="string">"---"</span> &lt;&lt; p.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pair的使用"><a href="#pair的使用" class="headerlink" title="pair的使用"></a>pair的使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接声明一个pair变量并且赋值</span></span><br><span class="line">    pair&lt;string, int&gt; p1("zd", 18);</span><br><span class="line">    <span class="comment">//make_pair可以当匿名方法使用，返回一个pair</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = make_pair(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先声明一个pair，再分别给属性赋值</span></span><br><span class="line">    pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2;</span><br><span class="line">    p2.first = <span class="string">"why"</span>;</span><br><span class="line">    p2.second = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给map插入一个pair，这里的pair不用有变量名</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"zs"</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带构造方法的结构体的写法"><a href="#带构造方法的结构体的写法" class="headerlink" title="带构造方法的结构体的写法"></a>带构造方法的结构体的写法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似于class中的构造函数快速赋值</span></span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="built_in">string</span> name) : age(age), name(name) &#123;&#125;</span><br><span class="line">&#125; Person;</span><br></pre></td></tr></table></figure>

<h2 id="c-中1和0在表达式中可以代替true或者false"><a href="#c-中1和0在表达式中可以代替true或者false" class="headerlink" title="c++中1和0在表达式中可以代替true或者false"></a>c++中1和0在表达式中可以代替true或者false</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个for一个道理</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何创建一个结构体变量"><a href="#如何创建一个结构体变量" class="headerlink" title="如何创建一个结构体变量"></a>如何创建一个结构体变量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//和pair相似，直接创建一个结构体并且调用它的构造函数</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">p1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    TreeNode p;    <span class="comment">//这是不调用构造方法写法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先创建对象，然后给属性赋值</span></span><br><span class="line">    TreeNode p2;</span><br><span class="line">    p2.val = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个结构体指针,指向p1这个结构体</span></span><br><span class="line">    TreeNode * point = &amp;p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; point-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用new给一个结构体指针在堆区分配内存，和java很像</span></span><br><span class="line">    TreeNode *p3 = <span class="keyword">new</span> TreeNode(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//使用malloc给结构体指针分配内存，注意这里要将分配的内存转换成指定指针类型</span></span><br><span class="line">    TreeNode *p4 = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    p3-&gt;val = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    p4-&gt;val = <span class="number">22</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p4-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说一下结构体和结构体指针的区别：</p>
<ol>
<li><p>首先使用的地方不同，结构体指针用在结构体之间有关联，</p>
<ol>
<li>比如链表，树这种，需要在结构体中存储下一个结构体的地址才能产生关联，所以这是结构体指针用的地方。那比如有时候用不到结构体指针，</li>
<li>比如单纯的想在容器里存储结构体，比如把结构体存入栈或者队列之列的容器，不需要结构体中产生关联，所以这时候就用不到结构体指针，单纯的声明结构体变量然后对结构体变量进行操作就行。</li>
</ol>
</li>
<li><p>虽然使用地方不同，但是结构体指针完全可以代替结构体变量，因为声明结构体变量的时候可以取而代之声明结构体指针，然后通过指针达到对结构体变量的操作产生相同的效果。</p>
</li>
<li><p>通过使用结构体指针，能达到和java很像的语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode node = <span class="keyword">new</span> TreeNode(val);</span><br></pre></td></tr></table></figure>

 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TreeNode * node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">TreeNode * node = (TreeNode *)<span class="built_in">malloc</span>(TreeNode);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="注意使用匿名的时候"><a href="#注意使用匿名的时候" class="headerlink" title="注意使用匿名的时候"></a>注意使用匿名的时候</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用匿名的时候不需要加变变量名</span></span><br><span class="line">    <span class="keyword">return</span> TreeNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用unorder-set和unorder-map的存储自定义类型的时候"><a href="#使用unorder-set和unorder-map的存储自定义类型的时候" class="headerlink" title="使用unorder_set和unorder_map的存储自定义类型的时候"></a>使用unorder_set和unorder_map的存储自定义类型的时候</h2><p>这时候要注意，因为unorder_set和unorder_map的实现是靠hash来实现的，并且这两个容器里面的数据时无序的，<br><strong>所以这两个容器对其存储的数据类型的要求是：这些类型要重写这两个方法。hash<key> 以及 equal_to<key></key></key></strong><br>这和java里面的hashcode()方法和equals()方法很像，<br>那么就可以发现</p>
<ol>
<li>当存储内置类型的时候，其实这两个方法是已经写好了的，所以在存储自定义类型的时候是不需要重写这两个方法的</li>
<li>当存储自定义类型的时候，是需要重写的，因为系统不知道<strong>你自定义的类型是的哈希值是怎么算的，并且当出现哈希冲突的时候你怎么处理两个对象是否相同</strong>。</li>
<li>当存储pair这种的时候，得重写hash方法。很好理解：pair系统肯定知道这么判断相同，但是怎么判断哈希值就是问题了。</li>
</ol>
<p>下面代码：使用unorder_set存储自定义类型TreeNode</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类中重写equal_to方法，判断两个对象是否相同</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> TreeNode &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == t.x &amp;&amp; y == t.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; TreeNode, *TreeNodePoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将哈希函数写在外面</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNodeHash</span> &#123;</span></span><br><span class="line">    <span class="comment">//计算某个对象的哈希值</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> TreeNode &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.x * <span class="number">100000007</span> + t.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; TreeNodeHash;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在存储自定义类型的时候传入自己的哈希函数</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;TreeNode, TreeNodeHash&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">set</span>.insert(TreeNode(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">set</span>.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用unorder_set存储pair</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希函数写</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNodeHash</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.first * <span class="number">100000007</span> + t.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; TreeNodeHash;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储pair&lt;int.int&gt;的时候不用重写equal_to方法，因为</span></span><br><span class="line">    <span class="comment">//这种半内置类型不需要重写equal_to方法，只需要hash方法</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, TreeNodeHash&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">set</span>.insert(make_pair(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">set</span>.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存储自定义类型指针的时候，不用重写！！！！"><a href="#存储自定义类型指针的时候，不用重写！！！！" class="headerlink" title="存储自定义类型指针的时候，不用重写！！！！"></a>存储自定义类型指针的时候，不用重写！！！！</h3><h2 id="在c-中使用int的最大值和最小值"><a href="#在c-中使用int的最大值和最小值" class="headerlink" title="在c++中使用int的最大值和最小值"></a>在c++中使用int的最大值和最小值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int的最小值是"</span>&lt;&lt;min&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int的最大值是"</span>&lt;&lt;max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在c-中声明数组的时候直接复制"><a href="#在c-中声明数组的时候直接复制" class="headerlink" title="在c++中声明数组的时候直接复制"></a>在c++中声明数组的时候直接复制</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如经常用的方向数组</span></span><br><span class="line"><span class="keyword">int</span> dr[<span class="number">4</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dc[<span class="number">4</span>]&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector也是一样的</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="vector的赋值"><a href="#vector的赋值" class="headerlink" title="vector的赋值"></a>vector的赋值</h2><p>vector类似于java里面的容器，在容器没有声明初始大小的时候，就不能通过指针访问，也就是不能通过v[i]这么来访问，必须先push_back几个元素后才能通过v[i]访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v[<span class="number">10</span>] = <span class="number">100</span>;    <span class="comment">//报错,在vector不知道自己长度之前不能通过指针访问</span></span><br><span class="line">v.push_back(<span class="number">10</span>);     <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在声明的时候设置了长度</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>[<span class="number">9</span>] = <span class="number">9</span>;  <span class="comment">//正确，因为有了长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维的设置初始长度,一维是10，二维是20</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>))</span></span>;</span><br><span class="line"><span class="built_in">vector</span>[<span class="number">5</span>][<span class="number">5</span>] = <span class="number">25</span>;  <span class="comment">//正确，因为每个维度都有了长度</span></span><br></pre></td></tr></table></figure>

<h2 id="判断从字符串变整数的时候是否可以越整数的界"><a href="#判断从字符串变整数的时候是否可以越整数的界" class="headerlink" title="判断从字符串变整数的时候是否可以越整数的界"></a>判断从字符串变整数的时候是否可以越整数的界</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> digit = str[i] - <span class="number">48</span>;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; (INT_MAX - digit) / <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 本来应该是 ans * 10 + digit &gt; Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">// 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。</span></span><br><span class="line">    <span class="keyword">return</span> negative ? INT_MIN : INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">ans = ans * <span class="number">10</span> + digit;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure>

<p>这个例子中，-2147483648返回的就是本身，可以举例子，发现这个规则是符合的</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>javase基础知识1</title>
    <url>/2019/08/01/javase%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/</url>
    <content><![CDATA[<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>lambda就是用来方便集合的遍历的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//除map集合的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王二麻子"</span>);</span><br><span class="line"></span><br><span class="line">    list.forEach((temp)-&gt; System.out.println(temp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map集合的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">"key1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    map.put(<span class="string">"key2"</span>,<span class="string">"value2"</span>);</span><br><span class="line">    map.put(<span class="string">"key3"</span>,<span class="string">"value3"</span>);</span><br><span class="line"></span><br><span class="line">    map.forEach((k,v)-&gt; System.out.println(k+<span class="string">"="</span>+v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a>==与equals的区别</h1><p>==:引用类型比较的是地址值，基本类型比较的是值<br>equals:被String类重写的equals()方法比较的是字符串的内容,一半没有重写的equals()内容就是==，重写主要是为了判断对象是否相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//不是new的话，看堆区是否有以前的内容，如果有的话就不信开辟内存，同样的栈区都有s1，s2的内存</span></span><br><span class="line">    String s1 = <span class="string">"abc"</span>;</span><br><span class="line">    String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(s1 == s2);               <span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.equals(s2));          <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次new都在堆区产生了新的内存，同样的栈区都有s1，s2的内存</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    System.out.println(s3 == s4);               <span class="comment">//false</span></span><br><span class="line">    System.out.println(s3.equals(s4));          <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Integer-声明-i1-127-i2-127-i3-128-i3-128"><a href="#Integer-声明-i1-127-i2-127-i3-128-i3-128" class="headerlink" title="Integer 声明 i1= 127,i2 = 127 ,i3 = 128, i3 = 128;"></a>Integer 声明 i1= 127,i2 = 127 ,i3 = 128, i3 = 128;</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//因为当使用Integer引用的时候如果是一个字节以内的内容用的是一样的内存，一个字节的以外的东西用的就是不一样的内存</span></span><br><span class="line">    <span class="comment">//因为一个字节表示范围是-128~127,所以</span></span><br><span class="line">    Integer i1 = <span class="number">127</span>;</span><br><span class="line">    Integer i2 = <span class="number">127</span>;</span><br><span class="line">    Integer i3 = <span class="number">128</span>;</span><br><span class="line">    Integer i4 = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);       <span class="comment">//true</span></span><br><span class="line">    System.out.println(i3 == i4);       <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="navicat修饰符"><a href="#navicat修饰符" class="headerlink" title="navicat修饰符"></a>navicat修饰符</h1><p>再看Object类里面比如hasCode()方法之类的会有navicat修饰符，表示java调用别的语言。</p>
<h1 id="如何跳出多重for"><a href="#如何跳出多重for" class="headerlink" title="如何跳出多重for"></a>如何跳出多重for</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//break直接跳出flag对应的for循环</span></span><br><span class="line">    flag:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                <span class="keyword">break</span> flag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="amp-与-amp-amp-的区别"><a href="#amp-与-amp-amp-的区别" class="headerlink" title="&amp;与&amp;&amp;的区别"></a>&amp;与&amp;&amp;的区别</h1><ol>
<li>条件1 &amp;&amp; 条件2：条件1为false，条件2不执行</li>
<li>条件1 &amp; 条件2：条件1为false，条件2执行</li>
<li>&amp;&amp;是短路与，&amp;是不短路的</li>
</ol>
<h1 id="强制类型转换和隐式类型转换"><a href="#强制类型转换和隐式类型转换" class="headerlink" title="强制类型转换和隐式类型转换"></a>强制类型转换和隐式类型转换</h1><ol>
<li>将大的数据类型转换为小的数据类型称之为强制类型转换，会出现精度丢失</li>
</ol>
<h1 id="jvm，jre，jdk的区别"><a href="#jvm，jre，jdk的区别" class="headerlink" title="jvm，jre，jdk的区别"></a>jvm，jre，jdk的区别</h1><ol>
<li>jvm：java虚拟机，用来保证java的跨平台特性</li>
<li>jre：java的运行环境，包括jvm+lib(基础类库)</li>
<li>jdk：java的开发工具，包含jre和开发工具</li>
</ol>
<h1 id="静态变量、静态代码块、静态方法、构造方法的执行顺序"><a href="#静态变量、静态代码块、静态方法、构造方法的执行顺序" class="headerlink" title="静态变量、静态代码块、静态方法、构造方法的执行顺序"></a>静态变量、静态代码块、静态方法、构造方法的执行顺序</h1><ol>
<li>加载顺序：静态变量-&gt;静态代码块-&gt;静态方法-&gt;构造方法</li>
</ol>
<h1 id="饿汉式单例设计模式和懒汉式单例设计模式"><a href="#饿汉式单例设计模式和懒汉式单例设计模式" class="headerlink" title="饿汉式单例设计模式和懒汉式单例设计模式"></a>饿汉式单例设计模式和懒汉式单例设计模式</h1><ol>
<li>单例设计模式：永远只能创建一个对象</li>
<li>单例设计模式的书写方式总共是两种：饿汉式单例设计模式和懒汉式单例设计模式</li>
<li>书写单例设计模式的语法规则：<ol>
<li>类中的构造方法私有</li>
<li>需要提供一个公共的获取对象的方法</li>
</ol>
</li>
<li>懒汉式单例设计模式在多线程会有线程不安全：试想：如果线程1走入了懒汉式的getInstance里面的判断if里面，如果此时cat为null，那么进入if，然后此时如果线程1休眠，然后线程2进入if，cat有了一个堆区内存，然后当线程1回归时，cat又会有一个堆区内存，所以懒汉设计模式在多线程的条件下有可能成为多实例的，线程是不安全的</li>
</ol>
<h2 id="饿汉式单例设计模式"><a href="#饿汉式单例设计模式" class="headerlink" title="饿汉式单例设计模式"></a>饿汉式单例设计模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例设计模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接造一个对象出来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式单例设计模式"><a href="#懒汉式单例设计模式" class="headerlink" title="懒汉式单例设计模式"></a>懒汉式单例设计模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例设计模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先造一个null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//懒汉式的返回单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cat == <span class="keyword">null</span>)&#123;</span><br><span class="line">            cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>c++语法糖</title>
    <url>/2020/02/01/c++%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<h1 id="helloworld问好"><a href="#helloworld问好" class="headerlink" title="helloworld问好"></a>helloworld问好</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HelloWorld C++!!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="cout输出字符串的拼接"><a href="#cout输出字符串的拼接" class="headerlink" title="cout输出字符串的拼接"></a>cout输出字符串的拼接</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"This "</span> &lt;&lt; <span class="string">"is "</span> &lt;&lt; <span class="string">"awesome!"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用转义字符换行"><a href="#使用转义字符换行" class="headerlink" title="使用转义字符换行"></a>使用转义字符换行</h2><p>两者的换行效果是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"使用转义字符换行\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"使用endl进行换行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="多个换行"><a href="#多个换行" class="headerlink" title="多个换行"></a>多个换行</h3><p>多个换行的两种方法也是等效的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"使用转义字符换行\n\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"使用endl进行换行"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="打印多行文本"><a href="#打印多行文本" class="headerlink" title="打印多行文本"></a>打印多行文本</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello \n world! \n I \n love \n w3c-school!"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释和java一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多行注释</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"使用转义字符换行\n\n"</span>;</span><br><span class="line">    <span class="comment">//单行注释</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"使用endl进行换行"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"星期1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"星期2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"星期3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"星期4"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"星期5"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"星期6"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"星期7"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入错误"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="获取地址"><a href="#获取地址" class="headerlink" title="获取地址"></a>获取地址</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//输出a的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出a的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个普通变量</span></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//声明一直指针让这个指针指向这个变量</span></span><br><span class="line"><span class="comment">//因为指针得到了普通变量的地址值</span></span><br><span class="line"><span class="keyword">int</span> *scorePtr = &amp;score;</span><br></pre></td></tr></table></figure>

<h3 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h3><p>只有两个</p>
<ol>
<li>取地址运算符： &amp;</li>
<li>解引用操作符： *<br>前者用来获得变量的地址值，后者用来获得指针指向的地址的内容(值)。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *scorePtr = &amp;score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通变量的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//100</span></span><br><span class="line">    <span class="comment">//指针的值(地址)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; scorePtr &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//0x61fe14</span></span><br><span class="line">    <span class="comment">//获取指针指向的地址里面的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *scorePtr &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="lower-bound和distance函数"><a href="#lower-bound和distance函数" class="headerlink" title="lower_bound和distance函数"></a>lower_bound和distance函数</h2><p>简单的说lower_bound返回相当于是在数组或者vector里面线性查找第一个大于等于target的数，并且返回地址值，然后distance函数通过这个返回的地址值和数组或者vector头的地址值进行插值计算，就可以得到target的索引值。如果存在的话就返回索引值，如果不存在就返回数组最后一个索引的下一个，vector返回v.end().</p>
<p>这两个函数可以看作比较快速的线性查找。看数组或者vector里面是否存在target。存在返回索引，不存在返回最后一个索引的下一个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//lower_bound找到第一个大于3的地址值</span></span><br><span class="line">    <span class="keyword">int</span> *p = lower_bound(a, a + <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//distance用于计算两个地址值之间差的字节数/字节大小</span></span><br><span class="line">    <span class="comment">//其实可以看成要找的值在数组里面的索引值，如果找不到就返回最后一个索引值的下一个</span></span><br><span class="line">    <span class="comment">//和找不到就返回end是一个道理</span></span><br><span class="line">    <span class="keyword">int</span> index = distance(a, p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是快一点的线性查找</span></span><br><span class="line">    index = distance(a, lower_bound(a, a + <span class="number">10</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用vector也是这个道理</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    index = distance(v.begin(), lower_bound(v.begin(), v.end(), <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><h3 id="创建动态内存"><a href="#创建动态内存" class="headerlink" title="创建动态内存"></a>创建动态内存</h3><p>可以使用<figure class="highlight plain"><figcaption><span>data-type```来在堆区开辟一块新内存，然后并且将内存地址返回。</span></figcaption><table><tr><td class="code"><pre><span class="line">```c++</span><br><span class="line">int main() &#123;</span><br><span class="line">    //开辟一块整形大小的内存</span><br><span class="line">    int *p = new int;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    //其实new出来的初始值都是随机值</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除动态内存"><a href="#删除动态内存" class="headerlink" title="删除动态内存"></a>删除动态内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给数组创建分配内存"><a href="#给数组创建分配内存" class="headerlink" title="给数组创建分配内存"></a>给数组创建分配内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给指针赋初始值</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//给指针分配内存</span></span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放地址</span></span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of char:"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of int:"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of float:"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of double:"</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"var: "</span> &lt;&lt; <span class="keyword">sizeof</span>(var) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>大部分时候函数是先声明、定义，然后调用的<br>不过也可以先声明，在调用的后面定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  doSomething();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello edong!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rand-函数"><a href="#rand-函数" class="headerlink" title="rand()函数"></a>rand()函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rand() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成指定范围内的随机数"><a href="#生成指定范围内的随机数" class="headerlink" title="生成指定范围内的随机数"></a>生成指定范围内的随机数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//对20取余再加1就能达到这个效果</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> + rand() % <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成真正的随机数"><a href="#生成真正的随机数" class="headerlink" title="生成真正的随机数"></a>生成真正的随机数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用系统当前时间为随机数种子</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//然后使用rand()来生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> + rand() % <span class="number">20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> x=<span class="number">1</span>, <span class="keyword">int</span> y=<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; volume() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; volume(<span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//6</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; volume(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化数组的值"><a href="#初始化数组的值" class="headerlink" title="初始化数组的值"></a>初始化数组的值</h2><p>memset函数在string.h头文件里面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设SIZE是1000</span></span><br><span class="line"><span class="keyword">int</span> a[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于是从a开始给这么多个字节的地址值全都赋值为0</span></span><br><span class="line"><span class="comment">//两者是等效的，因为sizeof(a)就是1000个sizeof(int)</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);<span class="comment">//这里的1000是数组大小，需要多少替换下就可以了。</span></span><br></pre></td></tr></table></figure>

<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明map和迭代器</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator mit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="comment">//map插入，用pair封装一个键值对</span></span><br><span class="line">    m.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"zhangsan"</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//另一种插入，和python的字典很像</span></span><br><span class="line">    m[<span class="string">"lisi"</span>] = <span class="number">3000</span>;</span><br><span class="line">    m[<span class="string">"wangwu"</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="comment">//m.find()返回键所在的迭代器位置，通过迭代器删除</span></span><br><span class="line">    m.erase(m.find(<span class="string">"wangwu"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="comment">//类似python字典直接修改</span></span><br><span class="line">    m[<span class="string">"lisi"</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//或者根据迭代器修改</span></span><br><span class="line">    m.find(<span class="string">"lisi"</span>)-&gt;second = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="comment">//m.end()指向map最后一组元素之后的一块地址值</span></span><br><span class="line">    <span class="keyword">if</span> (m.find(<span class="string">"zhangsan"</span>) != m.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"存在指定键"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"指定的键的值为"</span> &lt;&lt; m[<span class="string">"zhangsan"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//或者根据迭代器直接访问</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"指定的键的值为"</span> &lt;&lt; m.find(<span class="string">"zhangsan"</span>)-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不存在指定键"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//m的迭代器从map的第一个位置开始，遍历到最后一个元素，当遍历到</span></span><br><span class="line">    <span class="comment">//最后一个元素的下一个元素的时候遍历停止</span></span><br><span class="line">    <span class="keyword">for</span> (mit = m.begin(); mit != m.end(); mit++) &#123;</span><br><span class="line">        <span class="comment">//迭代器通过-&gt;first获得键，通过-&gt;secong获得值</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mit-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; mit-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>不能在迭代器的for循环中使用m.erase(iteraotr)，因为m.erase()删除的是指定的迭代器的位置，如果删除之后iterator的值在for循环中自增就没有意义。</li>
<li>map是自带sort排序的</li>
</ol>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>感觉和map一摸一样的，都是默认从小到大，然后自定义优先级就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="comment">//注意这里很直接，谁大就是按谁排</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, cmp&gt; s;</span><br><span class="line">    s.insert(<span class="number">1</span>);</span><br><span class="line">    s.insert(<span class="number">4</span>);</span><br><span class="line">    s.insert(<span class="number">2</span>);</span><br><span class="line">    s.insert(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = s.begin(); it != s.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>注意掌握greater对应着&gt; 和 less对应着&lt;</p>
<h3 id="优先队列存储自定义元素"><a href="#优先队列存储自定义元素" class="headerlink" title="优先队列存储自定义元素"></a>优先队列存储自定义元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应着less</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Person p1, Person p2) &#123;</span><br><span class="line">    <span class="comment">//小于号被重载，小于的比较其实是年龄的比较</span></span><br><span class="line">    <span class="keyword">return</span> p1.age &lt; p2.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应着greater</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Person p1, Person p2) &#123;</span><br><span class="line">    <span class="comment">//大于号被重载，大于的比较其实是年龄的比较</span></span><br><span class="line">    <span class="keyword">return</span> p1.age &gt; p2.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    person p1;</span><br><span class="line">    p1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    p1.age = <span class="number">20</span>;</span><br><span class="line">    person p2;</span><br><span class="line">    p2.name = <span class="string">"lisi"</span>;</span><br><span class="line">    p2.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从小变大</span></span><br><span class="line">    priority_queue&lt;person, <span class="built_in">vector</span>&lt;person&gt;, greater&lt;person&gt; &gt; q1;</span><br><span class="line">    <span class="comment">//从大变小</span></span><br><span class="line">    priority_queue&lt;person, <span class="built_in">vector</span>&lt;person&gt;, less&lt;person&gt; &gt; q2;</span><br><span class="line"></span><br><span class="line">    q1.push(p1);</span><br><span class="line">    q1.push(p2);</span><br><span class="line">    q2.push(p1);</span><br><span class="line">    q2.push(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q1.top().name &lt;&lt; <span class="string">" "</span> &lt;&lt; q1.top().age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q2.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q2.top().name &lt;&lt; <span class="string">" "</span> &lt;&lt; q2.top().age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列存储内置类型"><a href="#优先队列存储内置类型" class="headerlink" title="优先队列存储内置类型"></a>优先队列存储内置类型</h3><p>存储内置类型不用重载运算符，因为内置类型的比较是很容易的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从小到大</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q1;</span><br><span class="line">    <span class="comment">//从大到小</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; q2;</span><br><span class="line">    q1.push(<span class="number">1</span>);</span><br><span class="line">    q1.push(<span class="number">3</span>);</span><br><span class="line">    q1.push(<span class="number">2</span>);</span><br><span class="line">    q1.push(<span class="number">5</span>);</span><br><span class="line">    q2.push(<span class="number">1</span>);</span><br><span class="line">    q2.push(<span class="number">3</span>);</span><br><span class="line">    q2.push(<span class="number">2</span>);</span><br><span class="line">    q2.push(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q1.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q2.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q2.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="comment">//注意这里很直接，谁大就是按谁排</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> person &amp;p1, <span class="keyword">const</span> person &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里是按字符串比较谁在前后的</span></span><br><span class="line">        <span class="keyword">return</span> p1.name &gt; p2.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    person p1, p2, p3;</span><br><span class="line">    p1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    p2.name = <span class="string">"lisi"</span>;</span><br><span class="line">    p2.age = <span class="number">0</span>;</span><br><span class="line">    p3.name = <span class="string">"zhan"</span>;</span><br><span class="line">    p3.age = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于TreeMap</span></span><br><span class="line">    <span class="built_in">map</span>&lt;person, <span class="keyword">int</span>, cmp&gt; m;</span><br><span class="line">    m[p1] = <span class="number">1</span>;</span><br><span class="line">    m[p2] = <span class="number">2</span>;</span><br><span class="line">    m[p3] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意迭代器也是要相同的声明</span></span><br><span class="line">    <span class="built_in">map</span>&lt;person, <span class="keyword">int</span>, cmp&gt;::iterator mit;</span><br><span class="line">    <span class="keyword">for</span> (mit = m.begin(); mit != m.end(); mit++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; mit-&gt;first.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mit-&gt;first.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对数组进行sort排序"><a href="#对数组进行sort排序" class="headerlink" title="对数组进行sort排序"></a>对数组进行sort排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//默认从小到大排序</span></span><br><span class="line">    sort(a, a + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用自定义函数，从大到小排序</span></span><br><span class="line">    sort(a, a + <span class="number">5</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stl总结"><a href="#stl总结" class="headerlink" title="stl总结"></a>stl总结</h2><ol>
<li><p>使用sort排序数组和vector，默认是从小到大排序，如果要重大到小排序只需要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用set或者map，默认是从小到大排序，如果要从大到小排序只需要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="comment">//注意这里很直接，谁大就是按谁排</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; cmp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用优先队列，要注意使用greater还是less,如果存储的是内置类型的，不用重载大于小于号，直接根据greater或者less来用就行了。如果存储自定义类型，那就得重载大于号和小于号了，greater对应着大于号，less对应着小于号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应着less</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Person p1, Person p2) &#123;</span><br><span class="line">    <span class="comment">//小于号被重载，小于的比较其实是年龄的比较</span></span><br><span class="line">    <span class="keyword">return</span> p1.age &lt; p2.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应着greater</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Person p1, Person p2) &#123;</span><br><span class="line">    <span class="comment">//大于号被重载，大于的比较其实是年龄的比较</span></span><br><span class="line">    <span class="keyword">return</span> p1.age &gt; p2.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>javase基础知识2</title>
    <url>/2019/08/02/javase%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</url>
    <content><![CDATA[<h1 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h1><ol>
<li><p>String：当String字符串遇到频繁的修改的时候，每修改一次并且修改完的内容与之前不同时，虚拟机都会在堆区开辟新的内存，让栈区的内存去指向新开辟的堆区内存，这样会使得内存存在浪费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建了栈区s的内存,在堆区创建了"张三"的内存</span></span><br><span class="line">        String s = <span class="string">"张三"</span>;</span><br><span class="line">        <span class="comment">//又在堆区创建了"李四"的内存，让栈区s指向了李四的内存</span></span><br><span class="line">        s = <span class="string">"李四"</span>;</span><br><span class="line">        <span class="comment">//同上，又在堆区创建了"王五"的内存，让栈区s指向了李四的内存</span></span><br><span class="line">        s = <span class="string">"王五"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈区sb的内存+堆区"张三1"的内存</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"张三1"</span>);</span><br><span class="line">        <span class="comment">//在堆区的"张三1"的内存上进行修改，不新增内存</span></span><br><span class="line">        sb.append(<span class="string">"111"</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StringBuffer和StringBuilder字符串在遇到频繁的修改的时候，它只会在其本来所处的堆区内存中不断修改内容而不会频繁的开辟新内存，节约了空间。</p>
</li>
<li><p>StringBuffer和StringBuilder的区别就是StringBuilder在多线程中会遇到线程安全问题，但是其在单线程中StringBuilder的效率是比StringBuffer要高的。</p>
</li>
<li><p>StringBUffer和StringBuilder的使用取舍是当多线程的时候使用StringBuffer,单线程的时候使用StringBuilder。</p>
</li>
</ol>
<h1 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h1><ol>
<li>ArrayList底层是数组(Object类型的数组)，LinkedList的底层是链表</li>
<li>由于ArrayList的底层是数组，因此查询数据比较快，但是对数据的增删比较慢，LinkList查询很慢，但是增删很快。</li>
</ol>
<h1 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h1><ol>
<li>HashMap和Hashtable的底层都是哈希表</li>
<li>HashMap是jdk1.5之后出现的版本，Hashtable是在jdk1.5之前出现的</li>
<li>Hashtable是线程安全的，HashMap是非线程安全的。</li>
<li>HashMap的key和value可以为null，但是Hashtable的key和value不能为null<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Hashtable&lt;Integer,Integer&gt; map2 = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashMap中的键值对可以为null</span></span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//Hashtable中的键值对不能为null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map2.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hashtable中的key和value不能为null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(map.containsKey(<span class="keyword">null</span>));</span><br><span class="line">        System.out.println(map2.contains(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="什么是编译时期的异常？什么是运行时期的异常"><a href="#什么是编译时期的异常？什么是运行时期的异常" class="headerlink" title="什么是编译时期的异常？什么是运行时期的异常"></a>什么是编译时期的异常？什么是运行时期的异常</h1><ol>
<li>首先确立一个观点：写完的代码称之源文件(.java)，经过一系列工具(如idea，eclipse)的编译后成为java字节码文件(.class)，最后有Java虚拟机来执行字节码文件。</li>
<li>源文件编译成字节码文件时出现的异常是称之为编译异常(CE)，当程序被执行时发生的异常叫做运行时异常(RE)。</li>
<li>通常出现的编译时期异常有：FileNotFoundException(文件没有找到)、IOException(IO流异常)、ClassNotFoundException(没有找到类的异常)、EOFException(当用IO流读取文件的时候，文件的数据不存在会发生)、IllegalArgumentException(错误的参数，比如函数调用时传参)。</li>
<li>通常的运行时期异常有：NullPointerException(空指针)、ArithMeticException(比如10除以0的时候)、ArrayIndexOutOfBoundsException(数组越界)、StringIndexOutOfBoundsException(字符串下标越界)、IllegalArgumentException(RE时也有可能出现参数传递错误).</li>
</ol>
<h1 id="常见的加密算法有哪些，详细的解释其中一种？"><a href="#常见的加密算法有哪些，详细的解释其中一种？" class="headerlink" title="常见的加密算法有哪些，详细的解释其中一种？"></a>常见的加密算法有哪些，详细的解释其中一种？</h1><ol>
<li>常见的加密算法： DES、AES、RSA、Base64、MD5  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] attr = &#123;<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>&#125;;</span><br><span class="line">        <span class="comment">//明文</span></span><br><span class="line">        String pwd = <span class="string">"123abc"</span>;</span><br><span class="line">        <span class="comment">//密文</span></span><br><span class="line">        String mw = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//MD5加密算法，任何明文经过加密之后都是变成一个长度为32位的字符串</span></span><br><span class="line">        MessageDigest messageDigest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中间会产生一个长度为16的字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] digest = messageDigest.digest(pwd.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过这个字节数组来获取两个索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : digest) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = b;</span><br><span class="line">            <span class="keyword">if</span> (temp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp+=<span class="number">256</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index1 = temp/<span class="number">16</span>;</span><br><span class="line">            <span class="keyword">int</span> index2 = temp%<span class="number">16</span>;</span><br><span class="line">            <span class="comment">//通过这两个索引来拼接16进制的字符串</span></span><br><span class="line">            mw += attr[index1];</span><br><span class="line">            mw += attr[index2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以看出不管多长的明文字符串经过MD5加密后，产生的都是长度为32的内容是16进制的字符串</span></span><br><span class="line">        System.out.println(mw);</span><br><span class="line">        System.out.println(mw.length());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h1><ol>
<li>由字母、数字、下划线和$组成，不能以数字开头</li>
</ol>
<h1 id="java中的数据类型"><a href="#java中的数据类型" class="headerlink" title="java中的数据类型"></a>java中的数据类型</h1><ol>
<li>数据类型包括基本数据类型和引用数据类型</li>
<li>基本数据类型包括：byte、boolean、char、short、int、long、float、double</li>
<li>引用数据类型包括：普通类、接口、数组</li>
</ol>
<h1 id="java语言的三种技术架构"><a href="#java语言的三种技术架构" class="headerlink" title="java语言的三种技术架构"></a>java语言的三种技术架构</h1><ol>
<li>JAVAME：小型版本，是为开发电子消费产品和嵌入式设备提供的解决方案。手机</li>
<li>JAVASE：java标准版，集合、多线程、面向对象等等</li>
<li>JAVAEE：企业版，jsp、servlet什么的</li>
</ol>
<h1 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h1><ol>
<li>重载：同一个类中多个方法名字相同，但是参数类型，参数个数不同</li>
<li>重写：子类中的方法与父类中名字相同</li>
</ol>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><ol>
<li>栈内存：用于存储局部变量，当数据使用完，所占用的栈区内存会被释放</li>
<li>堆内存：数组和对象，通过new建立的示例都放在堆区的内存中</li>
<li>方法区：静态成员、构造函数、常量池、线程池都是放在方法区的</li>
<li>本地方法区：window系统占用</li>
<li>主要就是分成这4类内存结构</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>javase基础知识3</title>
    <url>/2019/08/03/javase%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/</url>
    <content><![CDATA[<h1 id="谈一谈面向对象思想"><a href="#谈一谈面向对象思想" class="headerlink" title="谈一谈面向对象思想"></a>谈一谈面向对象思想</h1><ol>
<li>什么是面向对象？面向对象是相对于面向过程来说的，面向过程强调的是功能，而面向对象强调的是对功能的封装。面向对象是java的核心思想，这个思想来自于我们人的实际生活</li>
<li>面向对象的三大基本特征：封装(通过权限修饰符来实现)、继承(extends)、多态</li>
</ol>
<h1 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h1><ol>
<li>成员变量：直接放置在类中的变量称之为成员变量，与方法是平级关系</li>
<li>局部变量：在方法体中声明的变量称之为局部变量。</li>
<li>两者区别：<ol>
<li>作用域区别：成员变量对于整个类有效、局部变量在某个范围内有效。</li>
<li>存储位置区别：成员变量随着对象的创建而存在，对象出现，成员变量出现，对象消失，成员变量消失，并且存储在堆内存中；局部变量在方法被调用，或者语句被执行的时候存在，存储在栈区内存中</li>
<li>初始值：成员变量有默认的初始值(引用类型是null，基本类型有各自默认的初始值)，局部变量必须初始化之后才能使用</li>
</ol>
</li>
</ol>
<h1 id="静态变量和成员变量的区别"><a href="#静态变量和成员变量的区别" class="headerlink" title="静态变量和成员变量的区别"></a>静态变量和成员变量的区别</h1><ol>
<li>从调用方式来看：静态变量也称之为类变量，可以直接通过类名来调用，也可以通过对象名.来调用；成员变量只能通过对象名来调用</li>
<li>从存储位置来看：静态变量存储于方法区的静态区域；成员变量存储在堆内存中</li>
<li>从生命周期来看：静态变量随着类的加载而存在，随着类的消失而消失，生命周期很长；成员变量随着对象创建而创建，对象的消失而消失</li>
<li>与对象的相关性：静态变量是所有对象的共享的数据；成员变量是每个对象特有的</li>
</ol>
<h1 id="什么是匿名对象？匿名对象的应用场景"><a href="#什么是匿名对象？匿名对象的应用场景" class="headerlink" title="什么是匿名对象？匿名对象的应用场景"></a>什么是匿名对象？匿名对象的应用场景</h1><ol>
<li><p>什么是匿名对象：没有名字的对象，是对象的一种简写形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印参数里的list集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        list.forEach((temp)-&gt; System.out.println(temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//常规对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"中国"</span>);</span><br><span class="line">        list.add(<span class="string">"美国"</span>);</span><br><span class="line">        Test.print(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名对象</span></span><br><span class="line">        Test.print(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名对象的应用场景：</p>
<ol>
<li>可以作为实际参数在方法中传递</li>
<li>只调用一次类的实例方法</li>
</ol>
</li>
</ol>
<h1 id="手写JDBC代码"><a href="#手写JDBC代码" class="headerlink" title="手写JDBC代码"></a>手写JDBC代码</h1><ol>
<li>可以分成几个步骤<ol>
<li>导入mysql的jar包</li>
<li>加载驱动</li>
<li>创建java代码与数据库的连接对象Connection</li>
<li>创建Statement对象</li>
<li>写sql语句，发送sql，接受结果</li>
<li>关闭资源</li>
</ol>
</li>
<li>代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.导入mysql的jar包</span></span><br><span class="line">    <span class="comment">//2.加载驱动</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建java代码与数据库连接的对象Connection</span></span><br><span class="line">    Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql:///test"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.创建Statement对象</span></span><br><span class="line">    Statement statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.写sql语句，发送sql，接收结果</span></span><br><span class="line">    String sql = <span class="string">"select * from user"</span>;</span><br><span class="line">    ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">    <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">        <span class="keyword">int</span> id = resultSet.getInt(<span class="string">"id"</span>);</span><br><span class="line">        String name = resultSet.getString(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(id+<span class="string">"---"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.关闭资源</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="this关键字与static关键字"><a href="#this关键字与static关键字" class="headerlink" title="this关键字与static关键字"></a>this关键字与static关键字</h1><ol>
<li><p>首先明确一个概念：java中的成员组成，类成员和对象成员，也就是静态成员和实例成员<br><img src="/image/javase03-member.png" alt></p>
</li>
<li><p>this关键字在方法中，那个对象调用了含有this关键字的方法，那么在这个方法中的this就代表哪个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//此处输出的是this的哈希码,因为是Demo类的对象调用的test()方法，</span></span><br><span class="line">        <span class="comment">//所以在test()中，this代表的是demo这个对象</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo().test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static用来修饰示例成员</p>
<ol>
<li>静态的特点：</li>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>对所有的对象共享</li>
<li>可以被类名直接调用</li>
</ol>
</li>
</ol>
<h1 id="普通类、抽象类、接口相关的面试题"><a href="#普通类、抽象类、接口相关的面试题" class="headerlink" title="普通类、抽象类、接口相关的面试题"></a>普通类、抽象类、接口相关的面试题</h1><ol>
<li>普通类：没有抽象的方法</li>
<li>抽象类中可以有抽象方法，也可以一个抽象方法都没有</li>
<li>接口<ol>
<li>接口中的方法都为抽象方法(public abstract修饰)</li>
<li>接口中的变量都必须被public static final修饰</li>
</ol>
</li>
<li>一些<ol>
<li>普通类是否可以继承抽象类：可以</li>
<li>普通类是否可以实现接口：可以</li>
<li>抽象类是否可以继承普通类：可以</li>
<li>抽象类是否可以继承抽象类：可以</li>
<li>抽象类是否可以实现接口：可以</li>
<li>接口是否可以继承普通类：不可以</li>
<li>接口是否可以继承抽象类：不可以</li>
<li>接口是否可以继承接口：可以</li>
<li>总结：接口不能继承任何类</li>
</ol>
</li>
</ol>
<h1 id="什么是多态？多态发生的条件"><a href="#什么是多态？多态发生的条件" class="headerlink" title="什么是多态？多态发生的条件"></a>什么是多态？多态发生的条件</h1><ol>
<li>什么是多态？指同一个对象在程序不同时刻的多种运行的状态</li>
<li>多态发生的条件<ol>
<li>声明的类型和实际的类型不一样</li>
<li>子类重写父类中的方法</li>
</ol>
</li>
</ol>
<h1 id="四种访问修饰符的访问权限"><a href="#四种访问修饰符的访问权限" class="headerlink" title="四种访问修饰符的访问权限"></a>四种访问修饰符的访问权限</h1><p><img src="/image/javase3-public.png" alt></p>
<h1 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h1><ol>
<li>Properties类主要用来读取*.properties的配置文件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将配置文件读取成字节流</span></span><br><span class="line">        InputStream ins = Main.class.getClassLoader().getResourceAsStream("test/pro.properties");</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将配置文件与Properties对象关联起来</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        pro.load(ins);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过键名去获取值</span></span><br><span class="line">        System.out.println(pro.get(<span class="string">"driver"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>javase基础知识4</title>
    <url>/2019/08/13/javase%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%864/</url>
    <content><![CDATA[<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><ol>
<li>final是一个修饰符，可以修饰类、变量、方法<ol>
<li>当修饰类时：当类被final修饰时，此类不能被其他类继承，</li>
<li>当修饰变量时：变量就成为一个常量，常量的值不能被修改</li>
<li>当修饰方法时：此方法不能被子类重写</li>
</ol>
</li>
</ol>
<h1 id="Arrays、Math、Random等常用工具类"><a href="#Arrays、Math、Random等常用工具类" class="headerlink" title="Arrays、Math、Random等常用工具类"></a>Arrays、Math、Random等常用工具类</h1><ol>
<li><p>工具类：工具类一般不new对象(构造方法私有)，并且其中的方法基本都是静态的</p>
</li>
<li><p>Arrays：sort()和asList()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//通过asList方法来生成一个list</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过asList生成的list是不能再添加元素的</span></span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Math类：abs()求绝对值pow()求次方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随机生成一个4位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ran = (<span class="keyword">int</span>) (Math.random()*<span class="number">10000</span>);</span><br><span class="line">    System.out.println(ran);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="instanceOf关键字"><a href="#instanceOf关键字" class="headerlink" title="instanceOf关键字"></a>instanceOf关键字</h1><ol>
<li>使用方法：对象 instanceOf 类型 ,返回值true表示对象是这个类型的，false则表示不是<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值是true</span></span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    System.out.println(cat <span class="keyword">instanceof</span> Cat);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ol>
<li>可变参数是jdk1.5的新特性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用这种方式来接受多个不确定个数的整形值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>...attr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : attr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//两次不同参数的调用都可以实现，省去了重载的麻烦</span></span><br><span class="line">        <span class="keyword">new</span> Main().test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Main().test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="多线程相关面试题"><a href="#多线程相关面试题" class="headerlink" title="多线程相关面试题"></a>多线程相关面试题</h1><ol>
<li>什么是进程：是在进行的程序</li>
<li>什么是线程：进程内部的一条执行路径或者一个控制单元</li>
<li>实现线程的几种方式：<ol>
<li>让普通类继承Thread类</li>
<li>让一个类实现Runnable接口</li>
</ol>
</li>
<li>run()与start()的区别：<ol>
<li>run()方法用于封装需要执行的代码块</li>
<li>start()方法用于启动线程</li>
</ol>
</li>
<li>如何保证线程安全：将多个线程共享的操作对象用锁锁起来</li>
</ol>
<h1 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h1><ol>
<li>常见字节流，可以看出字节流都是以InputStream/OutputStream结尾的<br><img src="/image/javase04-inputstream.png" alt></li>
<li>常见字符流，可以看出字符流是Reader/Writer结尾的<br><img src="/image/javase04-reader.png" alt></li>
<li>两者区别的话<ol>
<li>字符流主要用于读取纯文本，纯纯的文本</li>
<li>字节流主要用于读取图片，视频什么的，也能用于读取纯文本，底层肯定用的也是字符流的原理</li>
</ol>
</li>
</ol>
<h1 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h1><ol>
<li>对象本身是不能直接保存到磁盘中的，如果把对象序列化之后，对象就可以保存的磁盘中了</li>
<li>直接让对象实现Serializable接口，然后生成序列号就OK</li>
</ol>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ol>
<li>Class类是反射的根基：Class对象代表的是一个类编译后的字节码文件(.class文件)</li>
<li>创建Class类的三种方式：<ol>
<li>Class.forName(“类的全路径”)</li>
<li>对象.getClass()</li>
<li>类名.class</li>
</ol>
</li>
</ol>
<h1 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h1><ol>
<li>目前主要用来做配置文件，比如框架的</li>
<li>xml的约束文件：dtd、xsd，约束文件用来规定xml中哪些能写和哪些不能写</li>
<li>解析xml文件的几种方式：<ol>
<li>dom解析(占用内存，可以前后反复遍历)</li>
<li>sax解析(节省内存，只能向后遍历数据)</li>
</ol>
</li>
</ol>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ol>
<li>协议：<ol>
<li>TCP协议：3次握手(第一次：我问你在吗？ 第二次：你回答 第三次：我反馈你我知道你在)</li>
<li>UDP协议：将数据源和目的封装成数据包，不需要建立连接</li>
<li>HTTP协议：超文本传输协议，</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>javase基础知识5</title>
    <url>/2019/10/08/javase%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/</url>
    <content><![CDATA[<h2 id="1-1111111这是个什么类型的数？"><a href="#1-1111111这是个什么类型的数？" class="headerlink" title="1.1111111这是个什么类型的数？"></a>1.1111111这是个什么类型的数？</h2><p>答案：double类型。因为在java中有八种数据类型，其中浮点型有double和float类型。而默认的小数的类型都是double类型，也就是说1.11111111这个数是一个double类型的数，那么如果想把他变成float类型的话，就得写1.111111111f。同样的int和long也有一样的，要声明一个数是long类型的必须在后面加l。如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.11111</span>;  <span class="comment">//这句话是报错的，因为1.1111默认是double类型，这么写必须要强转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的写法是</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.11111f</span>;</span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line"><span class="keyword">float</span> f = (<span class="keyword">float</span>)<span class="number">1.11111</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也是可以的</span></span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="number">1231231231231231231L</span>;</span><br></pre></td></tr></table></figure>

<h2 id="byte类型的范围为什么是-128-127"><a href="#byte类型的范围为什么是-128-127" class="headerlink" title="byte类型的范围为什么是-128~127"></a>byte类型的范围为什么是-128~127</h2><ol>
<li><p>首先看一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Byte a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span> (t==<span class="number">10000</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到打印的结果是先从1到127，然后变成-128，再从-128到127，然后-128到127开始循环。</p>
</li>
<li><p>在这道题目开始之前需要明白几个点：</p>
<ol>
<li>计算机操作的都是源码，而且第一位（符号位）0表正数，1表负数。</li>
<li>正数的原码、反码、补码都是一样的。</li>
<li>负数的反码是由负数的原码出符号位每位取反，补码是由反码末尾加一构成的。</li>
<li>+127的原码是01111111，-128的补码是10000000。</li>
</ol>
</li>
<li><p>首先看1到127，因为计算机操作的都是补码，所以补码的变化过程是从00000001（1的补码）到01111111（127的补码），这时候再加一，补码就变成了10000000，现在这个是一个补码，而且是一个负数，那么把10000000变成原码就变成了00000000，因为之前因为补码看出来它是一个负数，所以这个数就成了-0，但是-0实在是不合适，所以这里就强制把他变成了-128（注意这里是硬性规定的）。然后补码10000000再加1就变成了10000001，这时候再变成原码就成了01111111，这个数其实就是-127，那么10000001再加一就成了10000010，这个数其实就是-126。这也就能说明白了为什么上面代码打印的过程是从1到127，再变到-128，然后从-128到127，再如此循环的，其实都是一直变这补码，而且10000000（-0）硬性规定是-128。</p>
</li>
<li><p>明白了上面的因为byte是一个字节的所以8位，所以byte的类型是2^(8-1) ~ -2^(8)，同理的short、int、long都可以照这个公式算范围。</p>
</li>
</ol>
<h2 id="java中的数字缓存"><a href="#java中的数字缓存" class="headerlink" title="java中的数字缓存"></a>java中的数字缓存</h2><p>java中是会缓存-128到127的数字的，只要不是new包装类对象，而且数字范围实在-128到127的，都是可以从缓存中获取到值的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为new对象所以引用值不同</span></span><br><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为命中缓存，所以从缓存中拿引用值</span></span><br><span class="line">Integer i3 = <span class="number">100</span>;</span><br><span class="line">Integer i4 = <span class="number">100</span>;</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>

<h2 id="String-s-new-String-“str123”-创建了几个字符串？"><a href="#String-s-new-String-“str123”-创建了几个字符串？" class="headerlink" title="String s = new String(“str123”);创建了几个字符串？"></a>String s = new String(“str123”);创建了几个字符串？</h2><p>2个，字符串常量池里面有一个，堆区也有一个</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础知识总结</title>
    <url>/2019/02/10/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="byte为什么是从-128到127"><a href="#byte为什么是从-128到127" class="headerlink" title="byte为什么是从-128到127"></a>byte为什么是从-128到127</h1><p>我们知道byte一个字节，那就是8位，那么可以知道其范围是-2^7<del>(2^7)-1，也就是从-128到+127，那么推算到int上，int是4个字节，所以int的范围是-2^31</del>(1^32)-1。那么假设一个类型是n位，那么这个范围就是-2^(n-1)<del>(2^(n-1))-1。<br>那么unsigned byte是0</del>2^8，也就是从0~256.</p>
<p>原因是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Byte a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*输出的结果是：从1到127，然后到-128，再从-128到-1，再从0到127，如此循环*/</span></span><br></pre></td></tr></table></figure>

<p>PS : 明确三个概念<br>1.正数的原码，反码，补码都是本身的二进制<br>2.负数的源码的符号为是1，变反码是除了符号位，剩余位都取反，变补码是在原来的反码的基础上加一。<br>3.1000 0000 表示-128，(本身是-0)。</p>
<p>运算过程<br>从1到127是：  0000 0001(补码，原码) ~ 0111 1111(补码，原码)<br>到-128是： 1000 0000(补码，原码)<br>-128的补码二进制加一得 ： 1000 0001(-127的补码)，随后变原码：减一+非符号位取反得 1111 1111(-127的原码)<br>再由-127的补码二进制加一的 ： 1000 0010(-126的补码)，随后变原码： 减一+非符号为取反得 1111 1110(-126的原码)<br>如此循环到-1，-1的的补码二进制为 1111 1111，随后变为原码：1000 0001(-1的原码)<br>随后-1的补码二进制加一为： 0000 0000 (0的补码)，变为原码就是：0000 0000，就成了0，然后再加一直到+127，再到-128，再到-1，再到0….如此循环。。。 </p>
<br>
<br>


<h1 id="判断字符是否是数字范围内"><a href="#判断字符是否是数字范围内" class="headerlink" title="判断字符是否是数字范围内"></a>判断字符是否是数字范围内</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.charAt(i) &lt; <span class="string">'0'</span> || str.charAt(i) &gt; <span class="string">'9'</span>)</span><br><span class="line">    System.out.println(<span class="string">"该字符不在在数字范围内"</span>);</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="如果一个字符是数字字符，怎么把其转换成对应的整形值"><a href="#如果一个字符是数字字符，怎么把其转换成对应的整形值" class="headerlink" title="如果一个字符是数字字符，怎么把其转换成对应的整形值"></a>如果一个字符是数字字符，怎么把其转换成对应的整形值</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.valueOf(<span class="string">'1'</span>+<span class="string">""</span>));    <span class="comment">//1</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">'1'</span>+<span class="string">""</span>));   <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="string">'1'</span> - <span class="string">'0'</span>;</span><br><span class="line">System.out.println(a);  <span class="comment">//a==1</span></span><br></pre></td></tr></table></figure>

<p>注意下这两种写法是不对的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为字符1是可以当作49这个整数用的，所以这句话的返回值是49的一个整形对象</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">'1'</span>));   <span class="comment">//49</span></span><br><span class="line"><span class="comment">//编译报错，这个方法只能把字符串转换</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">'1'</span>));</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="字符和整数的关系"><a href="#字符和整数的关系" class="headerlink" title="字符和整数的关系"></a>字符和整数的关系</h1><p>字符其实有自己的整数值，就是其的ASCII码值，比如字符’1’，就可以把字符当整数用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'1'</span>;   <span class="comment">//ascii值位49</span></span><br><span class="line">System.out.println(c &gt; <span class="number">47</span>); <span class="comment">//ture</span></span><br></pre></td></tr></table></figure>

<p>整形强转为char</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println((<span class="keyword">char</span>) <span class="number">49</span>);  <span class="comment">//输出为字符1</span></span><br></pre></td></tr></table></figure>

<h1 id="java类型转换图"><a href="#java类型转换图" class="headerlink" title="java类型转换图"></a>java类型转换图</h1><p><img src="/image/java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt></p>
<h1 id="用Arrays-fill-给二维数组赋值"><a href="#用Arrays-fill-给二维数组赋值" class="headerlink" title="用Arrays.fill()给二维数组赋值"></a>用Arrays.fill()给二维数组赋值</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//book是一个二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; book.length; k++) &#123;</span><br><span class="line">    Arrays.fill(book[k], <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常见的正则表达式的知识点"><a href="#常见的正则表达式的知识点" class="headerlink" title="常见的正则表达式的知识点"></a>常见的正则表达式的知识点</h1><p>通配符：<br>加号                        前面的内容出现一次或多次(1,2,3…..n)<br>问号                        前面的内容出现一次或不出现(0,1)<br>星号                        前面的内容出现任意次(0,1,2,3…n)<br>方括号里面的东西              方括号里面的东西必须出现1个<br>英文句号                     代替任意字符</p>
<p>代表：<br>两个反斜杠加一个d           表示数字<br>两个反斜杠加一个加号         表示字符加号<br>两个反斜杠加一个减号            表示字符减号<br>两个反斜杠加一个英文句号            表示英文句号这个字符</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础的好的博客</title>
    <url>/2019/10/17/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="集合Collection总览"><a href="#集合Collection总览" class="headerlink" title="集合Collection总览"></a>集合Collection总览</h1><p><a href="https://segmentfault.com/a/1190000014176577#articleHeader8" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014176577#articleHeader8</a></p>
]]></content>
      <categories>
        <category>好的博客</category>
      </categories>
      <tags>
        <tag>好的博客</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp</title>
    <url>/2019/09/18/kmp/</url>
    <content><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 私有属性next数组</span></span><br><span class="line">    __next = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得next数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(self, p: str)</span>:</span></span><br><span class="line">        self.__next.append(<span class="number">-1</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(p):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">-1</span> <span class="keyword">or</span> p[i] == p[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i == len(p):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                self.__next.append(j)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = self.__next[j]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过kmp算法求值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kmp</span><span class="params">(self, t: str, p: str)</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(t) <span class="keyword">and</span> j &lt; len(p):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">-1</span> <span class="keyword">or</span> t[i] == p[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = self.__next[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j == len(p):</span><br><span class="line">            <span class="keyword">return</span> i - j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印next数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_next</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__next)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1002.查找常用字符</title>
    <url>/2019/07/25/leetcode-1002.%20%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。</span><br><span class="line">例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">输出：[&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= A.length &lt;= 100</span><br><span class="line">1 &lt;= A[i].length &lt;= 100</span><br><span class="line">A[i][j] 是小写字母</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>最开始的想法是造一个二维数组，第一维是字符串的个数，第二维长度是26，第二维用于存放每个字符串的每个字符出现的个数。将所有的字符串中的所有字符的出现次数都放到book数组里之后，遍历每一列，把每一列的最小值保存到res数组里，这个每一列的最小值所代表的的就是每一个字符串中该字符出现的次数，res数组的长度是26，记录的是每一个字符在所有字符串中出现的次数，而且res[0]=value，这个等式代表的意思是：’a’这个字符在所有字符串出现的次数是value次。</li>
<li>在简洁一点，其实要求所有字符串中都有的字符，可以看成字符串1和字符串2中都有的常用字符，然后这个结果再和第三个字符串进行判断公共的常用字符，一直到最后一个。于是就可以直接声明一个res数组，这个数组的含义和上面的数组的含义一样，然后遍历每一个字符串，在遍历的过程中直接进行比较，也就是说res数组的值是一直在改变的，最终的结果就是所有的公共字符。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="做法一"><a href="#做法一" class="headerlink" title="做法一"></a>做法一</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> book[][] = <span class="keyword">new</span> <span class="keyword">int</span>[a.length][<span class="number">27</span>];</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//最终的结果数组</span></span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">27</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把所有字符串的所有字符个数分别放到自己的那个数组里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = a[i].charAt(j)-<span class="number">97</span>;</span><br><span class="line">                book[i][lo]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放完之后每列找最小值，并把最小值放到res数组里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">27</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (book[i][j] &lt; min)&#123;</span><br><span class="line">                    min = book[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[j] = min;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放完之后逐个遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (res[i]&gt;<span class="number">0</span> &amp;&amp; res[i] != <span class="number">10000000</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = (<span class="keyword">char</span>) (i+<span class="number">97</span>);</span><br><span class="line">                list.add(String.valueOf(c));</span><br><span class="line">                res[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简化之后"><a href="#简化之后" class="headerlink" title="简化之后"></a>简化之后</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//最终的公共字符以及次数就在数组里面</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">27</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = <span class="number">100000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">            <span class="comment">//对于每个字符串的所有字符先存一遍</span></span><br><span class="line">            <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">27</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">                book[c-<span class="number">97</span>]++;    </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存完之后和最终的结果相比</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res[i] &gt; book[i])&#123;</span><br><span class="line">                    res[i] = book[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后遍历最终的结果就OK</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (res[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = (<span class="keyword">char</span>) (i+<span class="number">97</span>);</span><br><span class="line">                list.add(String.valueOf(c));</span><br><span class="line">                res[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li><p>没事多用增强for，处理字符串的时候可以把字符串变成字符数组来用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (char c : s.toCharArray()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求全体的交集的时候，可以求个体1 ∩ 个体2 ∩ 个体3…，这两个结果是等价的。这道题就是全体的公共字符可以从每个个体的公共字符，而每两个字符串的公共字符是很好求的，自然全体的公共字符就可以求了。</p>
</li>
<li><p>‘a’-97=0，用数组表示小写字母的话，a到z都减97的话正好是0<del>25，可以放在长度为26的数组里面，0</del>25的话加上97再强转char的话就可以回到a到z。</p>
</li>
<li><p>字符数组一般声明26就OK</p>
</li>
<li><p>字符变字符串：String.valueOf(c),或者c+””;</p>
</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-common-characters/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-100. 相同的树</title>
    <url>/2019/10/03/leetcode-100.%20%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个二叉树，编写一个函数来检验它们是否相同。</span><br><span class="line"></span><br><span class="line">如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始的想法就是直接bfs两棵树，然后产生两个数组，包括null和节点上的值，然后对比数组，看看一不一样。</li>
<li>后来再想，用bfs其实就是遍历一下这棵树，那么遍历的方法有很多，而且遍历的简单的方法更多，比如前序、中序、后续遍历，这些都是可以的，所以这里写一下前序遍历。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="bfs遍历树"><a href="#bfs遍历树" class="headerlink" title="bfs遍历树"></a>bfs遍历树</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        list1 = self.getList(p)</span><br><span class="line">        list2 = self.getList(q)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list1 == list2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getList</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        q = deque()</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先把根节点的值和根节点放到数组和队列里面</span></span><br><span class="line">        q.append(root)</span><br><span class="line">        res.append(root.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(q) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(q)):</span><br><span class="line">                <span class="comment"># 拿出一个节点，对于这个节点进行bfs</span></span><br><span class="line">                cur = q.popleft()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果左孩子不是null，就把左孩子的值放到数组里面</span></span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                    res.append(cur.left.val)</span><br><span class="line">                <span class="comment"># 如果左孩子是null，就把None放到数组里面</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 右孩子的处理方法同左孩子</span></span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">                    res.append(cur.right.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="literal">None</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        l1 = []</span><br><span class="line">        l2 = []</span><br><span class="line">        <span class="comment"># python的可变类型的传递是引用传递，所以l1和l2都会被赋值</span></span><br><span class="line">        self.preOrder(p, l1)</span><br><span class="line">        self.preOrder(q, l2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l1 == l2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrder</span><span class="params">(self, cur: TreeNode, l: list)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">            l.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        l.append(cur.val)</span><br><span class="line">        self.preOrder(cur.left, l)</span><br><span class="line">        self.preOrder(cur.right, l)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>python中的可变类型的传递是引用传递。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1. 两数之和</title>
    <url>/2019/07/31/leetcode-1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>暴力</li>
<li>貌似找到了之前用哈希表出错的地方了，因为用哈希表存储的时候，key是a[i],value是i，在存入相同的值的时候相同key的value后面的会覆盖前面的，在后面遍历寻找key的时候，每次遍历相同的都是遍历排在前面的key，而前面的key的value是没有存值的，哈希表里面存的是后面key的value，在判别不是同一个数的时候只需要拿前面的key的索引和后面的key的value相比较就行了，不同的话就不是同一个元素。</li>
<li>也可以排序然后用二分</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;a.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i]+a[j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//存在相同的情况时，后面的key的value会把前面的key的value覆盖掉</span></span><br><span class="line">            map.put(a[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target-a[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//存在相同的情况时,前面的key的索引和后面的key的value相比较</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; i!=map.get(complement))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,map.get(complement)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="python的哈希表"><a href="#python的哈希表" class="headerlink" title="python的哈希表"></a>python的哈希表</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            temp = target - value</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 其实and dic[temp] != index这里是可以不要的，加这句话的本身就是用于避免temp找到自己(value)，但是这个</span></span><br><span class="line">            <span class="comment"># for的本身就是从头来的，每一个value和index都是独立的，而且每次寻找之后在把自身添加到字典中，所以就不存在</span></span><br><span class="line">            <span class="comment"># 自己找到自己的情况</span></span><br><span class="line">            <span class="keyword">if</span> temp <span class="keyword">in</span> dic <span class="keyword">and</span> dic[temp] != index:</span><br><span class="line">                <span class="keyword">return</span> [index, dic[temp]]</span><br><span class="line"></span><br><span class="line">            dic[value] = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dic</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-101. 对称二叉树</title>
    <url>/2019/10/04/leetcode-101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，检查它是否是镜像对称的。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>二叉树的题一直都很有意思，一开始的想法是bfs，把每一层的值都拿到一个数组里面，有值的放值，没值的放None，然后遍历完一层之后用两个指针判断数组temp是否首位相同，如果不一样直接返回False，遍历完所有的层数后返回True</li>
<li>然后用递归的写法，看了官方的题解，题解很明确。<ol>
<li>可以先假设想像有两个树，如何判断这两棵树对称呢？首先这两棵数得有相同的根节点，其次一棵树的左子树必须是另一棵树的右子树，比如一模一样。把握着两个点就可以确定两棵树对称。那么问题来了，如何判断一棵树是否对称呢？按照刚才的想法，只需要判断这颗树的根节点的左右子树是否对称，这就回到刚才的问题了。所以就可以用递归的方式来实现。</li>
<li>那么递归到底的情况是什么呢？这里注意每个节点的值都是只有两种的，要么是有值，要么是null。所以判断左右子树的值的相等情况就是递归终止的条件。那么左子树可能是有值或者是null，右子树也可能是有值或者是null，分类讨论：左子树为null，右子树为null这种情况返回就是True，因为两棵树都是null，自然都相等。左子树和右子树有一个为null，另一个位置返回自然就是False了。当两个都有值的时候需要判断值是否相同，不同直接返回False，相同的话就继续递归左子树的右子树和右子树的左子树（对称的原因）的结果且上递归右子树的左子树和左子树的右子树。</li>
</ol>
</li>
<li>还有迭代的写法，同样的因为对称的关系，每次处理两个节点，这两个节点就是要判断对称的左右子树的根。然后进行同递归的相同的处理就行了，做法类似于bfs，但其实不完全是。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="bfs遍历所有的层"><a href="#bfs遍历所有的层" class="headerlink" title="bfs遍历所有的层"></a>bfs遍历所有的层</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        q = deque()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root != <span class="literal">None</span>:</span><br><span class="line">            q.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(q) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 用一个temp数组记录所有每一行的所有的值</span></span><br><span class="line">            temp = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(q)):</span><br><span class="line">                <span class="comment"># 这里的bfs处理的是cur的所有的子节点，不同于以前的处理cur</span></span><br><span class="line">                <span class="comment"># bfs的选择有很多，看情况选择对cur的处理</span></span><br><span class="line">                cur = q.popleft()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果cur的左孩子有值就把值放到temp里，然后正常bfs</span></span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    temp.append(cur.left.val)</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="comment"># 否则就是把None放到temp中</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 右孩子的处理方法同左孩子</span></span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    temp.append(cur.right.val)</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># temp赋值完毕后就是检查temp是否对称</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = len(temp) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                <span class="keyword">if</span> temp[i] != temp[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 其实也可以看成两个整树是否对称</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse(root, root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归的函数就是看cur1和cur2这两棵树是否对称</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(self, cur1: TreeNode, cur2: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 若都为None自然相同</span></span><br><span class="line">        <span class="keyword">if</span> cur1 == <span class="literal">None</span> <span class="keyword">and</span> cur2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为这里已经不会再发生都为None的情况了，自然有一个None就一定不相等</span></span><br><span class="line">        <span class="keyword">if</span> cur1 == <span class="literal">None</span> <span class="keyword">or</span> cur2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当两者的值相同的时候需要继续递归左子树的右子树和右子树的左子树（对称的原因）</span></span><br><span class="line">        <span class="comment"># 的结果且上递归右子树的左子树和左子树的右子树。</span></span><br><span class="line">        <span class="keyword">if</span> cur1.val == cur2.val:</span><br><span class="line">            <span class="keyword">return</span> self.recurse(cur1.left, cur2.right) <span class="keyword">and</span> self.recurse(cur1.right, cur2.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        q = deque()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为了确保每次处理的节点是对称的，所以放两个根节点进去。</span></span><br><span class="line">        q.append(root)</span><br><span class="line">        q.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(q) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 每次处理两个节点</span></span><br><span class="line">            cur1 = q.popleft()</span><br><span class="line">            cur2 = q.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 同递归的处理方法</span></span><br><span class="line">            <span class="keyword">if</span> cur1 == <span class="literal">None</span> <span class="keyword">and</span> cur2 == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur1 == <span class="literal">None</span> <span class="keyword">or</span> cur2 == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur1.val == cur2.val:</span><br><span class="line">                q.append(cur1.left)</span><br><span class="line">                q.append(cur2.right)</span><br><span class="line">                q.append(cur1.right)</span><br><span class="line">                q.append(cur2.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>对于bfs的处理可以有很多种，比如这里的可以对cur节点进行cur的子节点的处理，也可以对cur本身进行处理，这两者区别就是前者是处理当前层，后者是处理下一层。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1008. 先序遍历构造二叉树</title>
    <url>/2019/11/24/leetcode-1008.%20%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</span><br><span class="line"></span><br><span class="line">(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。）</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[8,5,1,7,10,12]</span><br><span class="line">输出：[8,5,10,1,7,null,12]</span><br><span class="line">生成的树的链接：</span><br><span class="line">https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/03/08/1266.png</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= preorder.length &lt;= 100</span><br><span class="line">先序 preorder 中的值是不同的。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题意就是给你一个二分搜索树的先序遍历完的数组，现在让你把这个数组再变成一颗二分搜索树，并返回这个树</li>
<li>那么问题的突破点在哪里呢？仔细分析题目给的数组可以发现[8,5,1,7,10,12],8一定是根节点，因为是二分搜索树，所以最小的比根节点大的节点一定是根节点的右子树，而且他俩的值也是最接近的，这里就可以看到这个值是10了，假设10在数组的索引是k，8的索引是start,12的索引是end，那么就可以确定，从[start,k-1]都是8的start索引对应树的左孩子们，从[k,end]都是右孩子们。所以这里就可以用递归写了，但是要注意到一点，k可能不存在，如果一个孩子没有右子树，k就不存在，此时只需要构造左子树就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstFromPreorder</span><span class="params">(self, nums: list)</span> -&gt; TreeNode:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.recurse_bstFrom(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归构造nums数组中从start开始到end结尾的数字成为一个二分搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_bstFrom</span><span class="params">(self, nums: list, start: int, end: int)</span>:</span></span><br><span class="line">        <span class="comment"># 递归到底的情况，也就是到了具体的某一个叶子节点的时候</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[start])</span><br><span class="line">        <span class="comment"># 也有可能会出现start&gt;end的情况，这时候不用处理</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到当前根节点的右子树的在数组中对应的索引值，也就是最小的</span></span><br><span class="line">        <span class="comment"># 大于根节点的值的节点</span></span><br><span class="line">        k = start</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[start]:</span><br><span class="line">                k = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先构造根节点</span></span><br><span class="line">        cur = TreeNode(nums[start])</span><br><span class="line">        <span class="comment"># 因为k初始值是start，如果start没有更新就说明k没有右子树。</span></span><br><span class="line">        <span class="comment"># 如果没有右子树，通过递归构造二分搜索树的区域就有所区别</span></span><br><span class="line">        <span class="keyword">if</span> k == start:</span><br><span class="line">            cur.left = self.recurse_bstFrom(nums, start+<span class="number">1</span>, end)</span><br><span class="line">            cur.right = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 如果有右子树就递归构造就行了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.left = self.recurse_bstFrom(nums, start + <span class="number">1</span>, k - <span class="number">1</span>)</span><br><span class="line">            cur.right = self.recurse_bstFrom(nums, k, end)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>一般关于树的题都可以递归，尤其是给你一个通过某种规则遍历树而产生的数组，让你再造树的题，仔细找规律就行了。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-107. 二叉树的层次遍历 II</title>
    <url>/2019/10/07/leetcode-107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回其自底向上的层次遍历为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>就是bfs层次遍历二叉树，把遍历到的每一层放到一个栈里，然后把栈正常打印就是最后的结果了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="bfs层序遍历"><a href="#bfs层序遍历" class="headerlink" title="bfs层序遍历"></a>bfs层序遍历</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        q = deque()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        q.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正常的bfs</span></span><br><span class="line">        <span class="keyword">while</span> len(q) != <span class="number">0</span>:</span><br><span class="line">            temp = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(q)):</span><br><span class="line">                cur = q.popleft()</span><br><span class="line"></span><br><span class="line">                temp.append(cur.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line"></span><br><span class="line">            res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里因为要的结果是从底向上遍历的，所以反转一下list</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> len(res) != <span class="number">0</span>:</span><br><span class="line">            stack.append(res.pop())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1013. 将数组分成和相等的三个部分</title>
    <url>/2019/08/03/leetcode-1013.%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 A，只有我们可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">形式上，如果我们可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + ... + A[i] == </span><br><span class="line">A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) </span><br><span class="line">就可以将数组三等分</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li><p>最开始的想法：既然是把数组分成三个部分，那就那两个索引来分割整个数组成为三个部分，然后分别求三个部分的和，如果三个部分的和相同的话，就表明数组有和相同的三个部分，否则没有</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canThreePartsEqualSum</span><span class="params">(self, list: List[int])</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(list) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(list) - <span class="number">1</span>):</span><br><span class="line">                </span><br><span class="line">                sum1 = <span class="number">0</span></span><br><span class="line">                sum2 = <span class="number">0</span></span><br><span class="line">                sum3 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, i + <span class="number">1</span>):</span><br><span class="line">                    sum1 += list[index]</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> range(i + <span class="number">1</span>, j + <span class="number">1</span>):</span><br><span class="line">                    sum2 += list[index]</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> range(j + <span class="number">1</span>, len(list)):</span><br><span class="line">                    sum3 += list[index]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> sum1 == sum2 <span class="keyword">and</span> sum2 == sum3:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p> 其中i,j就是根据一个二重循环拿到所有的可能的数组的三个部分</p>
</li>
<li><p>后来想到一个数组的和一定是一个定值，那么把这个定值三等分，得出一个temp，如果数组存在和相等的三个部分，那么每个部分的和一定是temp，很简单的一个道理，一开始没有想到，然后依照题意每个部分都是连续的，然后在从头遍历数组的时候找temp就行了，找完整个数组看看其中和为temp的个数是不是为3个。按照这个思路找数组中和相等的k个部分也是可以的。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canThreePartsEqualSum</span><span class="params">(self, list: List[int])</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        sum1 = sum(list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sum1 % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        temp = sum1 // <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        tsum = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">            tsum += i</span><br><span class="line">            <span class="keyword">if</span> tsum == temp:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                tsum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li><p>python中直接求和是可以用sum函数的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sum1 = sum(list)</span><br></pre></td></tr></table></figure>
</li>
<li><p>双重循环不仅可以拿到数组的任意序列，还是两个点，把数组分成任意3个部分。</p>
</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1021. 删除最外层的括号</title>
    <url>/2019/09/16/leetcode-1021.%20%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效括号字符串为空 (&quot;&quot;)、&quot;(&quot; + A + &quot;)&quot; 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，&quot;&quot;，&quot;()&quot;，&quot;(())()&quot; 和 &quot;(()(()))&quot; 都是有效的括号字符串。</span><br><span class="line"></span><br><span class="line">如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</span><br><span class="line"></span><br><span class="line">给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。</span><br><span class="line"></span><br><span class="line">对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;(()())(())&quot;</span><br><span class="line">输出：&quot;()()()&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;(()())(())(()(()))&quot;</span><br><span class="line">输出：&quot;()()()()(())&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;(()())(())(()(()))&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;，</span><br><span class="line">删除每隔部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;()()&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;()()&quot;，原语化分解得到 &quot;()&quot; + &quot;()&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;&quot; + &quot;&quot; = &quot;&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S.length &lt;= 10000</span><br><span class="line">S[i] 为 &quot;(&quot; 或 &quot;)&quot;</span><br><span class="line">S 是一个有效括号字符串</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题意说白了就是给你一个字符串，然后对这个字符串进行一个操作，什么操作呢，首先这个字符串可以拆分成用小括号包围的几个部分，就拿第一个示例来看”(()())(())”，这个字符串的组成部分就是”(()())”+”(())”，因为这个两个部分就是被小括号包围的两个部分，把原字符串拆分成几个小部分的操作叫做题意中的原语化操作，然后进行的操作就是把每个小部分的外围括号去掉(类似把每个小部分剥层皮)，再把每个小部分剩下的内容取出来拼接在一起，就是最终要的结果。</li>
<li>那么最开始的想法：从头遍历字符串，用一个变量t来记录从头遍历到每个索引i所对应的字符串上的所有的括号是否全部抵消，也就是一左一右抵消，当t为0的话就说明括号全部抵消了，同样也就说明这个一个原语化产生的小部分，然后再把这个小部分进行切片，然后如此获得剩下的所有的切片。</li>
<li>后来根据栈的解法：左括号入栈，右括号出栈，当栈为空的时候就表示产生了一个小部分，通过start、end来记录小部分的位置，原理跟上面差不多，只不过用栈来记录括号是否匹配完全</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h1 id="没有用栈"><a href="#没有用栈" class="headerlink" title="没有用栈"></a>没有用栈</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start、end、flag的初值经过debug就可以发现原因，这样比较方便</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeOuterParentheses</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># t用来记录括号是否抵消</span></span><br><span class="line">        t = <span class="number">1</span></span><br><span class="line">        <span class="comment"># start用来记录要切片的索引的开始位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># end用来记录要切片的索引的结束为止</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># res是拼接的字符串</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="comment"># flag表示当前已经找到一个小部分了，为了整体的操作一样所以加一个flag</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                t += <span class="number">1</span></span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                t -= <span class="number">1</span></span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 找到一个小部分之后进行切片</span></span><br><span class="line">                res += s[start + <span class="number">1</span>:end]</span><br><span class="line">                <span class="comment"># 这里定位新的小部分，统一上面的操作</span></span><br><span class="line">                start = end+<span class="number">1</span></span><br><span class="line">                end = start</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                t = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeOuterParentheses</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="comment"># 用栈来记录括号是否匹配</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># start、end用来标注小部分的索引</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原理同上一个解法，只不过这里使用栈来记录的，左括号入栈，有括号出栈</span></span><br><span class="line">        <span class="comment"># 当栈为空就表示匹配完成</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">                    res += s[start + <span class="number">1</span>:end - <span class="number">1</span>]</span><br><span class="line">                    start = end</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>list可以当栈使，collections包下的deque来当队列使</li>
<li>栈的最经典的应用就是括号匹配</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-outermost-parentheses/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-104. 二叉树的最大深度</title>
    <url>/2019/10/05/leetcode-104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，找出其最大深度。</span><br><span class="line"></span><br><span class="line">二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>做法同二叉树最小深度，dfs、bfs都行</li>
<li>之前的dfs方法，在解决二叉树最小深度这个问题中的我是用的递归解法其实不是特别正确，其实是投了巧，当时的写法是递归遍历整颗树，然后在遍历的过程中一直比较每个节点的深度和所记录的最大深度进行比较，如果最大值可以更新就更新最大值。</li>
<li>这里一个新的递归方法：这个递归函数用来求每个节点的左右子树的最大深度。那么左右子树的最大深度求出来之后，这个树的最大深度自然就是左右子树的最大深度加1。这样就可以很方便的用递归方式求出整棵树的最大深度，同理最小深度也可以求出来。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="遍历整棵树，在递归遍历的过程中寻找最大值"><a href="#遍历整棵树，在递归遍历的过程中寻找最大值" class="headerlink" title="遍历整棵树，在递归遍历的过程中寻找最大值"></a>遍历整棵树，在递归遍历的过程中寻找最大值</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    res = <span class="number">-1000000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.recurse_maxDepth(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_maxDepth</span><span class="params">(self, cur: TreeNode, depth: int)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> depth &gt; self.res:</span><br><span class="line">                self.res = depth</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            self.recurse_maxDepth(cur.left, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            self.recurse_maxDepth(cur.right, depth + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="递归求左右子树的最大深度，求出后加一就是整棵树的最大值"><a href="#递归求左右子树的最大深度，求出后加一就是整棵树的最大值" class="headerlink" title="递归求左右子树的最大深度，求出后加一就是整棵树的最大值"></a>递归求左右子树的最大深度，求出后加一就是整棵树的最大值</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_maxDepth(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 求cur节点的最大深度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_maxDepth</span><span class="params">(self, cur: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        lnum = <span class="number">0</span></span><br><span class="line">        rnum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 求左子树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            lnum = self.recurse_maxDepth(cur.left)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求右子树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            rnum = self.recurse_maxDepth(cur.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求左右子树的最大深度的最大值，然后加1就是cur这颗树的最大深度。</span></span><br><span class="line">        <span class="keyword">return</span> max(lnum, rnum) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1051.高度检查器</title>
    <url>/2019/07/23/leetcode-1051.%20%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。</span><br><span class="line"></span><br><span class="line">请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,4,2,1,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= heights.length &lt;= 100</span><br><span class="line">1 &lt;= heights[i] &lt;= 100</span><br></pre></td></tr></table></figure>

<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>准确的题意就是把一个数组最少变几个数就能把这个数组变成非递减的数组，再准确来说就是看这个数组中有几个数的位置不对而导致了这个数组不是非递减数组，就可以得出如果把这个数组按非递减顺序排序之后，原数组中和排序后的数组里面同值不同位的数就是题目所求的数。</li>
<li>理解 <img src="/image/leetcode-1051.png" alt></li>
</ul>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> nh[] = Arrays.copyOf(heights,heights.length);</span><br><span class="line">        Arrays.sort(nh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看新数组和原数组同位不同数的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] != nh[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>没啥知识点</li>
</ul>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/height-checker/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/height-checker/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1079. 活字印刷</title>
    <url>/2019/11/23/leetcode-1079.%20%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;AAB&quot;</span><br><span class="line">输出：8</span><br><span class="line">解释：可能的序列为 &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;AAABBC&quot;</span><br><span class="line">输出：188</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= tiles.length &lt;= 7</span><br><span class="line">tiles 由大写英文字母组成</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始理解的是错的，理解的是两个方向的子集的并集，但是其实这道题的意思是你有n种字母，每种字母有x个，然后看你能怎么组合这些字母，要注意到组合这些字母产生的结果和子集可不是完全一样熬，题目要求的是那这么多字母随意组合，和子集的意思有很大的不一样。</li>
<li>仔细想，有n种字母，每种字母有x个，完全就可以那这个进行递归啊，有全排列的思想，每次拿n种字母，每种字母分别有x个，每次放不同的字母进行递归，那么递归终止的条件是当当前递归没有字母放了，自然就是递归的终止条件了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTilePossibilities</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line">        <span class="comment"># 因为给的是字符串，所以用字典记录每个字母出现的次数</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic.keys():</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = dic[i] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把拿到的排列结果放到res里面</span></span><br><span class="line">        res = []</span><br><span class="line">        self.recurse_numTile(s, dic, res, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> len(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归dic内容的字母，中间产生的字符串放到temp里面，如果确定是结果，就把结果放到res里面</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_numTile</span><span class="params">(self, s: str, dic: dict, res: list, temp: str)</span>:</span></span><br><span class="line">        <span class="comment"># 递归终止条件，如果当前所有的种类的字母都放完了，就递归终止</span></span><br><span class="line">        <span class="keyword">if</span> len(dic.keys()) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 空集不放到结果集里面，因为递归每次都是拼接新字符到temp字符串后面，而且每次递归</span></span><br><span class="line">        <span class="comment"># 产生的temp都是相互不影响的，所以每次把新temp放到结果集里面就行了</span></span><br><span class="line">        <span class="keyword">if</span> temp != <span class="string">''</span>:</span><br><span class="line">            res.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到所有的字母种类</span></span><br><span class="line">        keys = dic.keys()</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="comment"># 如果还能往后放新字母的话，也就是往后放递归的字母手里还有的话</span></span><br><span class="line">            <span class="keyword">if</span> dic[k] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 先更新temp字符串</span></span><br><span class="line">                temp = temp + k</span><br><span class="line">                <span class="comment"># 再更新字典</span></span><br><span class="line">                dic[k] = dic[k] - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 以当前的情况进行递归</span></span><br><span class="line">                self.recurse_numTile(s, dic, res, temp)</span><br><span class="line">                <span class="comment"># 当前情况的所有情况递归完了，进行下次递归的时候要消除上次递归产生的影响</span></span><br><span class="line">                <span class="comment"># 以确保所有递归的情况不会冲突。</span></span><br><span class="line">                <span class="comment"># 刚才是往temp后面添加了一个字符，这是裁剪出除了最后一个字符的字符串</span></span><br><span class="line">                temp = temp[:len(temp) - <span class="number">1</span>]</span><br><span class="line">                dic[k] = dic[k] + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>一定要明确一点，每次递归的情况都是不会影响的。</li>
<li>像这种n个字符，每个字符有x个的这种求全排列，求法就是用n1 * x1，n2 * x2，进行放的全排列。</li>
<li>这种问题和子集问题的区别就在于，子集是有相等情况的，比如’AAB’序列，N*X就能产生’ABA’，而子集是产生不了的，因为在子集看来’AAB’和’ABA’是一样性质的，因为他用到了相同的元素，而 N * X的问题看的是排列的结果，而子集的侧重点是用到了几个最小元素，而不是最小元素产生的结果.</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/letter-tile-possibilities/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-tile-possibilities/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-108. 将有序数组转换为二叉搜索树</title>
    <url>/2019/10/07/leetcode-108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</span><br><span class="line"></span><br><span class="line">本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>按照大佬的理解，总共分两步：<ol>
<li>按照树的结构，可以采用递归的写法来实现</li>
<li>因为要把有序数组转换成二叉平衡搜索树，而且因为是搜索树，每个节点的左子树的所有的值比节点的值小，每个节点的右子树的所有值都比节点的值大，自然就可以每次二分数组的区间，这样既可以保证高度，也可以保证有序</li>
</ol>
</li>
<li>补一个最近写的，和上面思路一样，为了确保高度平衡，而且还是有序数组，每次就可以从数组中间确定根节点，然后数组左面为左子树，右面为右子树。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="二分数组递归"><a href="#二分数组递归" class="headerlink" title="二分数组递归"></a>二分数组递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_sortedArrayToBST(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次把数组l~r的区间内的值变成一棵平衡二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_sortedArrayToBST</span><span class="params">(self, nums: list, l: int, r: int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 区间l~r的中点mid为根节点</span></span><br><span class="line">        node = TreeNode(nums[mid])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 以根节点在l~r中进行二分</span></span><br><span class="line">        <span class="comment"># 根节点的左节点进行递归建树</span></span><br><span class="line">        node.left = self.recurse_sortedArrayToBST(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">        node.right = self.recurse_sortedArrayToBST(nums, mid + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回node节点</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[l]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = (l + r) / <span class="number">2</span>;</span><br><span class="line">        TreeNode *cur = <span class="keyword">new</span> TreeNode(nums[index]);</span><br><span class="line">        cur-&gt;left = dfs(nums, l, index - <span class="number">1</span>);</span><br><span class="line">        cur-&gt;right = dfs(nums, index + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>平衡二叉搜索树中序遍历之后就是一个有序数组。</li>
<li>可以二分递归建树。</li>
<li>树的问题可以用递归求解。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-110. 平衡二叉树</title>
    <url>/2019/10/06/leetcode-110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，判断它是否是高度平衡的二叉树。</span><br><span class="line"></span><br><span class="line">本题中，一棵高度平衡二叉树定义为：</span><br><span class="line"></span><br><span class="line">一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始的想法是求根节点的最大深度和最小深度，然后看着两者的绝对值之差是不是小于等于1，从而判断这颗树是不是平衡树，但是这种做法其实是不对的，因为一棵树书否是平衡树决定的因素是这棵树的每个节点（除了叶子节点）的左右子树的深度是否绝对值差小于等于1，只求根节点的最大最小深度是完全不符合要求的。</li>
<li>正确的做法是递归求每个节点的左右子树的深度，而且这个深度其实就是左右子树的最大深度。在每次递归的时候直接判断左右子树的绝对值差。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        self.recurse_isBalanced(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求出cur节点的最大深度（也就是一棵树直观上的深度）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_isBalanced</span><span class="params">(self, cur: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 递归终止条件：当cur是叶子节点的时候，cur的深度自然就是1</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先声明好局部变量</span></span><br><span class="line">        lnum = <span class="number">0</span></span><br><span class="line">        rnum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当左子树不为空的之后求出左子树的最大深度（直观上的深度）</span></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            lnum = self.recurse_isBalanced(cur.left)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 同上面，求出右子树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            rnum = self.recurse_isBalanced(cur.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为是递归，会遍历到所有的cur以及cur的左右子树的深度</span></span><br><span class="line">        <span class="comment"># 自然也可以在递归里面判断以cur为根的树是不是平衡树</span></span><br><span class="line">        <span class="keyword">if</span> abs(lnum - rnum) &gt; <span class="number">1</span>:</span><br><span class="line">            self.flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为求的是cur的最大深度，cur的最大深度自然是左右子树的</span></span><br><span class="line">        <span class="comment"># 最大深度的最大值加1</span></span><br><span class="line">        <span class="keyword">return</span> max(lnum, rnum) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>递归可以根据参数的条件分解为很多个子递归，也就是大问题拆解成小问题的做法（根据参数的不同）。</li>
<li>求一颗二叉树的最大深度最递归的做法就是求左右子树的最大深度的最大值加一，把一个求cur节点的最大深度的问题分解成了求cur节点的左右子树的最大深度。求出左右子树的最大深度的最大值之后自然cur的最大深度就很容易了。</li>
<li>这里最重要的点就是分解子问题，把根节点的问题分成了左右子树的问题，然后把左右子树的问题统一回去就成了跟问题的解，然后根问题的解也可以用来解决子问题的解</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-109. 有序链表转换二叉搜索树</title>
    <url>/2020/08/18/leetcode-109.%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span><br><span class="line"></span><br><span class="line">本题中，一个高度平衡二叉树是指一个二叉树每个节点</span><br><span class="line">的左右两个子树的高度差的绝对值不超过 1。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], </span><br><span class="line">它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>最容易想到的，就是之前做过的题—根据有序数组转换成二叉平衡搜索树，先把有序链表转换成有序数组，然后再转换成AVL就行。这道题主要讲下面两个方法</li>
<li>有序数组和有序链表的转换方法区别在于，数组可以拿到某个子树对应的区间[l,r]—-前闭后闭的区间，并且可以拿到这个区间的mid，然后根据[l,mid-1]和[mid+1,r]去构造新的左右子树，那么对于链表来说就没有这么友好，链表倒是可以通过快慢指针法拿到mid，但是[l,mid-1]对于链表确不方便，所以这里采用前闭后开区间来创建数，如[l,right)，就是l到right前一个节点这么多节点的对应的区间，这么做的原因是当拿到mid之后，[l,mid)可以直接用来创建左子树，[mid-&gt;next,right)可以继续创建右子树，比原来方便的多。</li>
<li>第二种方法方法是N*logN，因为在根据快慢指针找链表对应区间的mid的时候花费了O(N)的时间，所以可以用第三种方法优化到O(N)，要注意到，链表的顺序和你构造完的AVL的中序遍历结果是一样的。所以可以用一个全局变量指针指向AVL当前构造的节点，然后递归模仿中序遍历的顺序一个一个构造AVL的节点。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="前闭后开区间"><a href="#前闭后开区间" class="headerlink" title="前闭后开区间"></a>前闭后开区间</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedListToBST</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTree(head, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//left和right是一个链表区域的左开右闭区间，[left,right)</span></span><br><span class="line">    <span class="comment">//left是这段区间的开始，right是这段区间的最后一个元素下一个</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">getMid</span><span class="params">(ListNode *left, ListNode *right)</span> </span>&#123;</span><br><span class="line">        ListNode *low = left;</span><br><span class="line">        ListNode *fast = left;</span><br><span class="line">        <span class="comment">//当长度的偶数的时候fast最后为null,</span></span><br><span class="line">        <span class="comment">//当长度是奇数的时候fast最后为最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != right &amp;&amp; fast-&gt;next != right) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用链表的[left,right)这一区间创建树</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">createTree</span><span class="params">(ListNode *left, ListNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当链表长度为空的时候</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//或得到这段区间的中间节点</span></span><br><span class="line">        ListNode *mid = getMid(left, right);</span><br><span class="line">        <span class="comment">//构造当前节点</span></span><br><span class="line">        TreeNode *cur = <span class="keyword">new</span> TreeNode(mid-&gt;val);</span><br><span class="line">        <span class="comment">//这里就体现了前闭后开区间的好处，可以直接用mid</span></span><br><span class="line">        <span class="comment">//当左子树的right</span></span><br><span class="line">        cur-&gt;left = createTree(left, mid);</span><br><span class="line">        cur-&gt;right = createTree(mid-&gt;next, right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历优化"><a href="#中序遍历优化" class="headerlink" title="中序遍历优化"></a>中序遍历优化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedListToBST</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = getLen(head);</span><br><span class="line">        ListNode *t = head;</span><br><span class="line">        <span class="keyword">return</span> createTree(t, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用中序遍历来顺便创建AVL，很妙</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">createTree</span><span class="params">(ListNode *&amp;h, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模仿先序遍历的顺序</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        TreeNode *cur = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        cur-&gt;left = createTree(h, l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//h指向的是构造好的AVL当前中序遍历到第几个元素</span></span><br><span class="line">        cur-&gt;val = h-&gt;val;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        cur-&gt;right = createTree(h, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>链表递归操作时可以选择[left,right)前闭后开的区间，因为如果找mid的时候，继续递归的话，mid可以作为下一次递归的right</li>
<li>数组递归操作是可以选择[left,right]前闭后闭的区间</li>
<li>具体递归的索引怎么选择可以具体分析好处。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>链表</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-111. 二叉树的最小深度</title>
    <url>/2019/09/30/leetcode-111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，找出其最小深度。</span><br><span class="line"></span><br><span class="line">最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最小深度  2.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>首先可以用dfs，那么dfs需要的是参数depth，和当前节点cur，depth表示当前节点的深度，判断当前节点是否是叶子节点，如果是叶子节点，就判断当前节点的深度是否是最小深度，否则就去遍历左右子树。</li>
<li>再用bfs，每次把从队列拿出来的节点进行一次是否是叶子节点的判断，如果是叶子节点，那就计算一下当前的节点的深度是否是比记录下的最小值要小，如果不是叶子节点就正常的 bfs。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="java的dfs"><a href="#java的dfs" class="headerlink" title="java的dfs"></a>java的dfs</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minDepth(root, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在树中，求深度是depth的cur节点的最小深度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">minDepth</span><span class="params">(TreeNode cur, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//看当前节点是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//是的话然后判断当前深度是否是最小</span></span><br><span class="line">            <span class="keyword">if</span> (depth &lt; min) &#123;</span><br><span class="line">                min = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dfs往下走</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minDepth(cur.left, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minDepth(cur.right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="python的dfs"><a href="#python的dfs" class="headerlink" title="python的dfs"></a>python的dfs</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    res = sys.maxsize</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.minDepth1(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth1</span><span class="params">(self, cur, depth)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> depth &lt; self.res:</span><br><span class="line">                self.res = depth</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            self.minDepth1(cur.left, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            self.minDepth1(cur.right, depth + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h2 id="java的bfs"><a href="#java的bfs" class="headerlink" title="java的bfs"></a>java的bfs</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      <span class="keyword">int</span> depth;</span><br><span class="line"></span><br><span class="line">      TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里为了操作方便，给节点加了一个depth的属性，用于记录节点的深度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//常规的bfs</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> time = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//每次拿到从队首的元素，先判断一下是否是叶子节点，如果是再判断深度是否是最小</span></span><br><span class="line">                <span class="keyword">if</span> (temp.left == <span class="keyword">null</span> &amp;&amp; temp.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.depth &lt; min) &#123;</span><br><span class="line">                        min = temp.depth;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果不是叶子节点就进行正常的bfs</span></span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp.left.depth = temp.depth + <span class="number">1</span>;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp.right.depth = temp.depth + <span class="number">1</span>;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-dfs"><a href="#c-dfs" class="headerlink" title="c++ dfs"></a>c++ dfs</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *cur, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ans = min(ans, height);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(cur-&gt;left, height + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(cur-&gt;right, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>python中的引用类型的空值为None   </li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1108. IP 地址无效化</title>
    <url>/2019/12/31/leetcode-1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。</span><br><span class="line"></span><br><span class="line">所谓无效化 IP 地址，其实就是用 &quot;[.]&quot; 代替了每个 &quot;.&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：address = &quot;1.1.1.1&quot;</span><br><span class="line">输出：&quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：address = &quot;255.100.50.0&quot;</span><br><span class="line">输出：&quot;255[.]100[.]50[.]0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出的 address 是一个有效的 IPv4 地址</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>把”.”换成”[.]”？？？</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">defangIPaddr</span><span class="params">(self, address: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> address.replace(<span class="string">"."</span>, <span class="string">"[.]"</span>, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/defanging-an-ip-address/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/defanging-an-ip-address/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1111. 有效括号的嵌套深度</title>
    <url>/2020/04/01/leetcode-1111.%20%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。</span><br><span class="line"></span><br><span class="line">嵌套深度 depth 定义：即有效括号字符串嵌套的层数。详情参见题末「嵌套深度」部分。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">给你一个「有效括号字符串」 seq，将其分成两个不相交的子序列 A 和 B，且 A 和 B 都满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。</span><br><span class="line"></span><br><span class="line">现在，你需要从中选出 任意 一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。</span><br><span class="line"></span><br><span class="line">返回长度为 seq.length 答案数组 answer ，选择 A 还是 B 的编码规则是：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：seq = &quot;(()())&quot;</span><br><span class="line">输出：[0,1,1,1,1,0]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：seq = &quot;()(())()&quot;</span><br><span class="line">输出：[0,0,0,1,1,0,1,1]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>垃圾题，<a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution/javazhan-shi-xian-zuo-ti-wu-fen-zhong-du-ti-liang-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution/javazhan-shi-xian-zuo-ti-wu-fen-zhong-du-ti-liang-/</a></li>
<li>计算出每个括号对应的此时的嵌套深度，如果要让A和B的这两个子序列的最大的嵌套深度最小，那就要尽可能平均分配括号，所以让嵌套深度是奇数的字符给A，偶数的给B。用一个变量模拟栈的长度就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxDepthAfterSplit</span><span class="params">(<span class="built_in">string</span> seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:seq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                d++;</span><br><span class="line">                ans.push_back(d &amp; <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(d &amp; <span class="number">1</span>);</span><br><span class="line">                d--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>括号匹配的嵌套深度。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>括号匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-112. 路径总和</title>
    <url>/2019/10/07/leetcode-112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定如下二叉树，以及目标和 sum = 22，</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line">返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显可以用递归，在这里我想的递归的写法是每次递归到cur节点的时候，都会有记录到cur节点之前的路径的和sum，因为是递归嘛，有着搜索的感觉，每次递归的时候cur都会有到cur节点之前的所有可能的和，所以每次递归的时候只需要考虑cur是否是叶子节点，如果是叶子节点，就算一下当前cur的值和sum的和是否是题目给的路径总和，如果是就标记有，如果不是就继续搜索。</li>
<li>递归记录递归到每个节点的值temp，然后比较temp和sum，注意temp的定义，还有要注意一定要到叶子节点才记录路径，也就是说如果temp在递归的过程中还没有到叶子节点就等于sum的时候是不记录的。要注意到叶子节点的情况。<br>
<br>

</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="搜索递归"><a href="#搜索递归" class="headerlink" title="搜索递归"></a>搜索递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, res: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">and</span> sum == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从根节点开始搜索，根节点之前的值自然是0</span></span><br><span class="line">        self.recurse_hasPathSum(root, <span class="number">0</span>, res)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归到cur节点，sum是每条路径走到cur节点之前的所有路径上的节点的总和，res是题目要求的路径总和</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_hasPathSum</span><span class="params">(self, cur: TreeNode, sum: int, res:int)</span>:</span></span><br><span class="line">        <span class="comment"># 如果是叶子节点，就计算一下是否达到res</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> sum + cur.val == res:</span><br><span class="line">                self.flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 往左子树搜索</span></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 之所以是sum+cur.val的原因是搜索，往下递归的时候sum是一定要变得额</span></span><br><span class="line">            self.recurse_hasPathSum(cur.left, sum + cur.val, res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            self.recurse_hasPathSum(cur.right, sum + cur.val, res)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//temp记录的是到这个节点之前的路径和</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *cur, <span class="keyword">int</span> temp, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个节点是叶子节点并且算上这个叶子节点的值为sum的时候，记录答案</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val + temp == sum &amp;&amp; cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新temp</span></span><br><span class="line">        temp += cur-&gt;val;</span><br><span class="line">        <span class="comment">//左右子树分别继续递归</span></span><br><span class="line">        dfs(cur-&gt;left, temp, sum);</span><br><span class="line">        dfs(cur-&gt;right, temp, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>注意题意说的路径是指从根节点到叶子节点，所以当temp+cur.val==sum的时候，要注意这个cur是不是叶子节点。而判断是不是叶子节点只需要判断这个cur的左右子树是不是都null。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1160. 拼写单词</title>
    <url>/2020/03/17/leetcode-1160.%20%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</span><br><span class="line"></span><br><span class="line">假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』</span><br><span class="line">（字符串），那么我们就认为你掌握了这个单词。</span><br><span class="line"></span><br><span class="line">注意：每次拼写时，chars 中的每个字母都只能用一次。</span><br><span class="line"></span><br><span class="line">返回词汇表 words 中你掌握的所有单词的 长度之和。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>用哈希表记录就好，先用哈希表记录一下单词表里的所有单词的个数，然后对于每个单词都产生一个哈希表，然后比较新的哈希表的所有值是否全部小于单词表对应的哈希表。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无序的哈希表</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">        <span class="comment">//map可以直接这样添加键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:chars) &#123;</span><br><span class="line">            map1[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word:words) &#123;</span><br><span class="line">            <span class="comment">//对于每个单词都产生一个哈希表</span></span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map2;</span><br><span class="line">            <span class="comment">//和上面一样的赋值方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c: word) &#123;</span><br><span class="line">                map2[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//单词里的每个字母都要在两个map里面比一下</span></span><br><span class="line">            <span class="comment">//看字母表里是否存在足够多的字母</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c:word) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map1[c] &lt; map2[c]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                res += word.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>unordered_map是无序的map，默认的map是有序的。</li>
<li>c++中，在声明map(或者unordered_map)之后，可以直接像python里面一样插入键值对，比如map&lt;char,int&gt;长这个样子，那么插入就可以map[‘a’]=65。和python一样。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-114. 二叉树展开为链表</title>
    <url>/2020/08/02/leetcode-114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，原地将它展开为一个单链表。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>最粗暴的，前序遍历，然后把遍历过的节点都放到集合里面，因为集合是有序的，所以可以从集合里面重新拼接一个新的二叉树</li>
<li>如果要求是原地变化的话，自然就是找规律了，通过观察（题解）了解到，当节点存在左子树的时候，需要把这个节点的右子树连接到这个节点的左子树的最右面节点的右子树上，然后再把这个节点的左子树放到右子树上，然后再把左子树去掉，然后对每个节点都这么操作一次就可以达到变化的效果了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        f(root, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">list</span>.size(); i++) &#123;</span><br><span class="line">            TreeNode *pre = <span class="built_in">list</span>[i - <span class="number">1</span>];</span><br><span class="line">            TreeNode *cur = <span class="built_in">list</span>[i];</span><br><span class="line">            pre-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            pre-&gt;right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历，并且把遍历过的节点都存储到集合里面</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(TreeNode *cur, <span class="built_in">vector</span>&lt;TreeNode *&gt; &amp;<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">list</span>.push_back(cur);</span><br><span class="line">        f(cur-&gt;left, <span class="built_in">list</span>);</span><br><span class="line">        f(cur-&gt;right, <span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="原地变化"><a href="#原地变化" class="headerlink" title="原地变化"></a>原地变化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        f(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">findRight</span><span class="params">(TreeNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">return</span> findRight(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(TreeNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//存在左子树</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//找到左子树的最右面的节点</span></span><br><span class="line">            TreeNode *right = findRight(cur-&gt;left);</span><br><span class="line">            <span class="comment">//把当前节点的右子树连接到当前节点的左子树的最右面的节点的右面</span></span><br><span class="line">            right-&gt;right = cur-&gt;right;</span><br><span class="line">            <span class="comment">//把左子树放到右面</span></span><br><span class="line">            cur-&gt;right = cur-&gt;left;</span><br><span class="line">            <span class="comment">//把左子树扔了</span></span><br><span class="line">            cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后对于每个节点都这么操作一遍</span></span><br><span class="line">        f(cur-&gt;left);</span><br><span class="line">        f(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>


<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1169. 查询无效交易</title>
    <url>/2020/02/16/leetcode-1169.%20%E6%9F%A5%E8%AF%A2%E6%97%A0%E6%95%88%E4%BA%A4%E6%98%93/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果出现下述两种情况，交易 可能无效：</span><br><span class="line"></span><br><span class="line">交易金额超过 ¥1000</span><br><span class="line">或者，它和另一个城市中同名的另一笔交易相隔不超过 60 分钟（包含 60 分钟整）</span><br><span class="line">每个交易字符串 transactions[i] 由一些用逗号分隔的值组成，这些值分别表示交易</span><br><span class="line">的名称，时间（以分钟计），金额以及城市。</span><br><span class="line"></span><br><span class="line">给你一份交易清单 transactions，返回可能无效的交易列表。你可以按任何顺序返回答案。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]</span><br><span class="line">输出：[&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]</span><br><span class="line">解释：第一笔交易是无效的，因为第二笔交易和它间隔不超过 60 分钟、名称相同且发</span><br><span class="line">生在不同的城市。同样，第二笔交易也是无效的。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,1200,mtv&quot;]</span><br><span class="line">输出：[&quot;alice,50,1200,mtv&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;bob,50,1200,mtv&quot;]</span><br><span class="line">输出：[&quot;bob,50,1200,mtv&quot;]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>这个题也很神奇，没说明白一些情况，然后我就很莽的自己认为情况了。比如当前交易可能会和之前的交易发生冲突，并且当前交易金额大于1000，这时候不知道前面的交易会不会因为时间的冲突而导致它不合法，但是当前交易有大于1000，不知道能不能影响到之前。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">invalidTransactions</span><span class="params">(String[] ss)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.length; i++) &#123;</span><br><span class="line">            String[] split = ss[i].split(<span class="string">","</span>);</span><br><span class="line">            <span class="comment">//先判断当前交易是否合法</span></span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(split[<span class="number">2</span>]) &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!res.contains(ss[i]))</span><br><span class="line">                    res.add(ss[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再看这个交易之后的交易和当前交易是否冲突</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; ss.length; j++) &#123;</span><br><span class="line">                String[] split2 = ss[j].split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">if</span> (Integer.parseInt(split2[<span class="number">2</span>]) &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!res.contains(ss[j]))</span><br><span class="line">                    res.add(ss[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//冲突就是交易名字一样，城市不一样，时间没超过60</span></span><br><span class="line">                <span class="keyword">if</span> (split[<span class="number">0</span>].equals(split2[<span class="number">0</span>]) &amp;&amp; !split[<span class="number">3</span>].equals(split2[<span class="number">3</span>])</span><br><span class="line">                        &amp;&amp; Math.abs(Integer.parseInt(split[<span class="number">1</span>]) - Integer.parseInt(split2[<span class="number">1</span>])) &lt;= <span class="number">60</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!res.contains(ss[i]))</span><br><span class="line">                        res.add(ss[i]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!res.contains(ss[j]))</span><br><span class="line">                        res.add(ss[j]);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/invalid-transactions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invalid-transactions/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1162. 地图分析</title>
    <url>/2020/03/29/leetcode-1162.%20%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个</span><br><span class="line">『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地</span><br><span class="line">，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离</span><br><span class="line">它最近的陆地区域的距离。</span><br><span class="line"></span><br><span class="line">我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0)</span><br><span class="line"> 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</span><br><span class="line"></span><br><span class="line">如果我们的地图上只有陆地或者海洋，请返回 -1。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0,0],[0,0,0],[0,0,0]]</span><br><span class="line">输出：4</span><br><span class="line">解释： </span><br><span class="line">海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题目大致下来就是给你一个二位数组，里面1代表陆地，0代表海洋，问陆地每次只能向四个方向运动，能运动到的最远的海洋的距离里陆地的距离最大时多少，那不就相当于是对于每个陆地进行bfs，bfs最大的层数就是最大的距离么</li>
<li>所以这里先把所有的陆地入队，然后每次对每个陆地的点进行bfs的时候，对于新的陆地grid[newx][newy]就是原来的grid[x][y]+1，这样直接标记了走过的地方，也直接相当于计数了。</li>
<li>甜姨的题解<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/</a></li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方向数组</span></span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dc[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列存储坐标</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">//当确定是陆地的时候</span></span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.push(make_pair(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> hasOcean = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> x = p.first;</span><br><span class="line">            <span class="keyword">int</span> y = p.second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="comment">//得到新的坐标</span></span><br><span class="line">                <span class="keyword">int</span> newx = x + dr[k];</span><br><span class="line">                <span class="keyword">int</span> newy = y + dc[k];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果越界或者不是海洋，因为只有0是海洋，不是海洋的值都大于等于1</span></span><br><span class="line">                <span class="keyword">if</span> (newx &lt; <span class="number">0</span> || newx &gt;= m || newy &lt; <span class="number">0</span> || newy &gt;= n || grid[newx][newy] != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把这块海洋变成陆地</span></span><br><span class="line">                grid[newx][newy] = grid[x][y] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//记录最大值</span></span><br><span class="line">                ans = max(ans, grid[newx][newy]);</span><br><span class="line">                hasOcean = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//并且插入新的陆地坐标，继续dfs</span></span><br><span class="line">                q.push(make_pair(newx, newy));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果发现没有海洋</span></span><br><span class="line">        <span class="keyword">if</span> (!hasOcean)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/as-far-from-land-as-possible/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-118. 杨辉三角</title>
    <url>/2019/07/25/leetcode-118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>找规律咯</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;\</span><br><span class="line">                <span class="comment">//当是两端的时候才是1</span></span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span> || j==i) &#123;</span><br><span class="line">                    li.add(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不是两端的时候就按规律走</span></span><br><span class="line">                <span class="keyword">int</span> temp = list.get(i-<span class="number">1</span>).get(j)+list.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>);</span><br><span class="line">                li.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(li);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/pascals-triangle/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-120. 三角形最小路径和</title>
    <url>/2020/07/14/leetcode-120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到</span><br><span class="line">下一行中相邻的结点上。</span><br><span class="line"></span><br><span class="line">相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 </span><br><span class="line">上一层结点下标 + 1 的两个结点。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定三角形：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>貌似有点像杨辉三角，每次往下或者往下面的右面的第一个走，很明显用dp就可以了。dp[i][j]就是min(dp[i-1][j],dp[i-1][j-1])+nums[i][j]。不过要注意越界的情况</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            fill(dp[i], dp[i] + len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = nums[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//因为第一列的值只能从那个格子过来，所以先给第一列的格子赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给每一行的最后一列赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][nums[i].size() - <span class="number">1</span>] = dp[i - <span class="number">1</span>][nums[i - <span class="number">1</span>].size() - <span class="number">1</span>] + nums[i][nums[i].size() - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后给中间的格子，从第二行的第一列开始记录(从0开始)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums[i].size() - <span class="number">1</span>; j++) &#123;\</span><br><span class="line">                <span class="comment">//找出上一步的最小值</span></span><br><span class="line">                <span class="keyword">int</span> temp = min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//写出这一步的最小值</span></span><br><span class="line">                dp[i][j] = temp + nums[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为最后的结果都在最后一行中，从最后一行中找结果就行了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            ans = min(ans, dp[len - <span class="number">1</span>][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>空间优化以后再做，也很简单</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/triangle/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-119.杨辉三角II</title>
    <url>/2019/07/27/leetcode-119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>每次更新杨辉三角的时候倒着更新就可以，有点背包的性质，背包性质以后总结。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## O(k)的空间复杂度</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line"></span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//从倒数第二列开始更新，并且第一列不更新，被更新的列都是上一行的当前列和前面的列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = list.get(j)+list.get(j-<span class="number">1</span>);</span><br><span class="line">                list.set(j,t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/pascals-triangle-ii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-121.买卖股票的最佳时机</title>
    <url>/2019/07/28/leetcode-121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</span><br><span class="line"></span><br><span class="line">注意你不能在买入股票前卖出股票。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>在还不知道优化做法之前是这么想的，既然只进行一次交易，而且先买然后卖，那就枚举每一个买，在每一个买之后一个一个试，找出最大的卖，O(n^2)。</li>
<li>优化做法：其实就是找出两个点，一个最小值和一个最小值后面的最大值，但是最大值可以不用变量来表示，最大值的作用就是用来减去最小值来得出最大利润，所以说只需要两个变量，一个最小值变量，一个最大利润变量。对于每一天来说，有可能当天的值就是最小值，如果是最小值就更新最小值，如果不是，那么当天的新值有可能与最小值的差是最大利润，和之前记录的最大利润比一下，大的话就更新。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//在每一个买之后枚举卖，找出最大值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;a.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j]-a[i] &gt; max)&#123;</span><br><span class="line">                    max = a[j]-a[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max &lt; <span class="number">0</span>? <span class="number">0</span>:max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找最小值和最大利润"><a href="#寻找最小值和最大利润" class="headerlink" title="寻找最小值和最大利润"></a>寻找最小值和最大利润</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="comment">//如果当天的值是最小值就更新最小值</span></span><br><span class="line">            <span class="keyword">if</span> (i&lt;min)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果当天的利润大，就更新利润</span></span><br><span class="line">                <span class="keyword">if</span> (i-min&gt;profit)&#123;</span><br><span class="line">                    profit = i-min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1221. 分割平衡字符串</title>
    <url>/2019/11/06/leetcode-1221.%20%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个「平衡字符串」中，&apos;L&apos; 和 &apos;R&apos; 字符的数量是相同的。</span><br><span class="line"></span><br><span class="line">给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。</span><br><span class="line"></span><br><span class="line">返回可以通过分割得到的平衡字符串的最大数量。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;RLRRLLRLRL&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, 每个子字符串中都包含相同数量的 &apos;L&apos; 和 &apos;R&apos;。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;RLLLLRRRLR&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, 每个子字符串中都包含相同数量的 &apos;L&apos; 和 &apos;R&apos;。</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;LLLLRRRR&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：s 只能保持原样 &quot;LLLLRRRR&quot;.</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s[i] = &apos;L&apos; 或 &apos;R&apos;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>水题。</li>
<li>从头往后遍历字符串，用一个数来记录L,R谁多，这里用cnt，如果cnt小于零说明L多，大于零说明R多，当cnt为0的时候就表明L和R平衡了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedStringSplit</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先记录第一个是L还是R</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'L'</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从前往后遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="comment"># 遇到L，cnt就减小1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'L'</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 遇到R，cnt就加1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当cnt为0表示L与R平衡</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-946. 验证栈序列</title>
    <url>/2019/10/17/leetcode-1252.%20%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。</span><br><span class="line"></span><br><span class="line">另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。</span><br><span class="line"></span><br><span class="line">你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。</span><br><span class="line"></span><br><span class="line">请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png</span><br><span class="line">输入：n = 2, m = 3, indices = [[0,1],[1,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。</span><br><span class="line">第一次增量操作后得到 [[1,2,1],[0,1,0]]。</span><br><span class="line">最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png</span><br><span class="line">输入：n = 2, m = 2, indices = [[1,1],[0,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>水题，给一个初始行数为n，初始列数为m的二维数组进行x次操作，x是indices这个二维数组的一维长度，这个操作是，每次把nums数组的第i行，第j列加1，这个i，j分别是indices的第二位的两个值。经过x次操作后统计nums数组中的奇数的个数。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">oddCells</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[][] indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//x次操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//行</span></span><br><span class="line">            <span class="keyword">int</span> r = indices[i][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//列</span></span><br><span class="line">            <span class="keyword">int</span> c = indices[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                nums[r][j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                nums[j][c]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计奇数的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j][k] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1232. 缀点成线</title>
    <url>/2020/02/16/leetcode-1232.%20%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，</span><br><span class="line">其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</span><br><span class="line"></span><br><span class="line">请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则</span><br><span class="line">请返回 false。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>防止除0，采用乘的方式，判断三个点之间的两个斜率是否相同，不相同返回false。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a[i][<span class="number">1</span>] - a[i - <span class="number">1</span>][<span class="number">1</span>]) * (a[i - <span class="number">1</span>][<span class="number">0</span>] - a[i - <span class="number">2</span>][<span class="number">0</span>]) !=</span><br><span class="line">                    (a[i - <span class="number">1</span>][<span class="number">1</span>] - a[i - <span class="number">2</span>][<span class="number">1</span>]) * (a[i][<span class="number">0</span>] - a[i - <span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>遇到除法尽量转换成乘法，防止除0</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1217. 玩筹码</title>
    <url>/2019/11/24/leetcode-1217.%20%E7%8E%A9%E7%AD%B9%E7%A0%81/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。</span><br><span class="line"></span><br><span class="line">你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：</span><br><span class="line"></span><br><span class="line">将第 i 个筹码向左或者右移动 2 个单位，代价为 0。</span><br><span class="line">将第 i 个筹码向左或者右移动 1 个单位，代价为 1。</span><br><span class="line">最开始的时候，同一位置上也可能放着两个或者更多的筹码。</span><br><span class="line"></span><br><span class="line">返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：chips = [1,2,3]</span><br><span class="line">输出：1</span><br><span class="line">解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：chips = [2,2,2,3,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>阅读理解题，筹码都长一个样子，chips[i]代表的是当前索引位置的筹码所在的位置，比如chips[1] = 2,chips[2] = 2，就说明第一个筹码再位置2，第二个筹码也在位置2，这是题意。</li>
<li>然后关键点在移动两个位置无花费，移动一个位置有花费，也就是说偶数位置移动到偶数位置无花费，奇数移动到奇数位置无花费。而数组里面的值就是<strong>位置</strong>，所以可以把所有的数字都分成两个部分，奇数位置上的和偶数位置上的，所以呢，假设把所有的奇数都放在一起，偶数都放在一起(因为无花费)，然后现在就可以看成两列筹码，一列全是偶数位置上的，一列全是奇数位置上的。然后可以这么想，我已经在无花费的情况下，拿到了两列花费最低的、位置正确的筹码，我最后要做的事情就是把这两列化成一列，而且既然要最少花费，那就简单了，那一列少，就移动哪一列，那要移动的花费就是少的那一列的个数了(个数*(花费=1))，所以转化题目的解法就是求数组中奇数和偶数的那个个数少啦。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostToMoveChips</span><span class="params">(self, chips: List[int])</span> -&gt; int:</span></span><br><span class="line">        ji = <span class="number">0</span></span><br><span class="line">        ou = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> chips:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                ou+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ji+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(ji,ou)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/play-with-chips/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/play-with-chips/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1281. 整数的各位积和之差</title>
    <url>/2019/12/31/leetcode-1281.%20%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 234</span><br><span class="line">输出：15 </span><br><span class="line">解释：</span><br><span class="line">各位数之积 = 2 * 3 * 4 = 24 </span><br><span class="line">各位数之和 = 2 + 3 + 4 = 9 </span><br><span class="line">结果 = 24 - 9 = 15</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 4421</span><br><span class="line">输出：21</span><br><span class="line">解释： </span><br><span class="line">各位数之积 = 4 * 4 * 2 * 1 = 32 </span><br><span class="line">各位数之和 = 4 + 4 + 2 + 1 = 11 </span><br><span class="line">结果 = 32 - 11 = 21</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= n &lt;= 10^5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>模拟就行了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtractProductAndSum</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        t1 = <span class="number">1</span></span><br><span class="line">        t2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            t = n % <span class="number">10</span></span><br><span class="line">            n = n // <span class="number">10</span></span><br><span class="line">            t1 = t1 * t</span><br><span class="line">            t2 = t2 + t</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t1 - t2</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1266. 访问所有点的最小时间</title>
    <url>/2019/12/31/leetcode-1266.%20%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。</span><br><span class="line">请你计算访问所有这些点需要的最小时间（以秒为单位）。</span><br><span class="line"></span><br><span class="line">你可以按照下面的规则在平面上移动：</span><br><span class="line"></span><br><span class="line">每一秒沿水平或者竖直方向移动一个单位长度，</span><br><span class="line">或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。</span><br><span class="line">必须按照数组中出现的顺序来访问这些点。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图片url</span><br><span class="line">https:/&#125;/assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/1626_example_1.png</span><br><span class="line"></span><br><span class="line">输入：points = [[1,1],[3,4],[-1,0]]</span><br><span class="line">输出：7</span><br><span class="line">解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; </span><br><span class="line">                        [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]   </span><br><span class="line">从 [1,1] 到 [3,4] 需要 3 秒 </span><br><span class="line">从 [3,4] 到 [-1,0] 需要 4 秒</span><br><span class="line">一共需要 7 秒</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points = [[3,2],[-2,2]]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">points.length == n</span><br><span class="line">1 &lt;= n &lt;= 100</span><br><span class="line">points[i].length == 2</span><br><span class="line">-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显模拟，因为这道题的要求是按顺序走每个点的，所以说这个题一下就变得特别简单，那这个问题就变成了每个点到每个点的最短距离的问题。</li>
<li>既然每次可以横着或者竖着或者斜着走一步，那么假设现在有两个点，这两个点有这么几种情况<ol>
<li>两点在一条直线上，这种情况的话两点之间的距离就是横坐标或者竖坐标之差了。</li>
<li>两点不在同一条直线上，计算出两个点的横纵坐标的差，比如差分别是x和y，那么这个问题就转换成了横方向移动x次，纵坐标移动y次，而且x，y可以同时移动，这个问题怎么求解？明显移动的次数是x和y的最大值。</li>
</ol>
</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>[][] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最后的总和</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一位是一个点到一个点，那么问题就很简单了，只需要计算每个点到每个点的最小距离就行了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//拿到两个点的坐标</span></span><br><span class="line">            <span class="keyword">int</span> t1 = nums[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> t2 = nums[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> t3 = nums[i + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> t4 = nums[i + <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用count函数计算两个点的距离</span></span><br><span class="line">            res = res + count(t1, t2, t3, t4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算x1,y1,x2,y2这两个点的最短距离</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把x1和x2的最大值放到x1里面</span></span><br><span class="line">        <span class="keyword">if</span> (x1 &lt; x2) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = x1;</span><br><span class="line">            x1 = x2;</span><br><span class="line">            x2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//y1和y2同理</span></span><br><span class="line">        <span class="keyword">if</span> (y1 &lt; y2) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = y1;</span><br><span class="line">            y1 = y2;</span><br><span class="line">            y2 = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//c1和c2分别是两个坐标的横纵坐标差</span></span><br><span class="line">        <span class="keyword">int</span> c1 = x1 - x2;</span><br><span class="line">        <span class="keyword">int</span> c2 = y1 - y2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//res是返回值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//横向一直移动c1次，纵向一只移动c2次，而且可以c1和c2同时移动，就说明最终的移动次数就是c1和c2的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (c1 &gt; c2) &#123;</span><br><span class="line">            res = c1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = c2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回移动次数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>模拟题多找规律</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-time-visiting-all-points/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1295. 统计位数为偶数的数字</title>
    <url>/2019/12/31/leetcode-1295.%20%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [12,345,2,6,7896]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">12 是 2 位数字（位数为偶数） </span><br><span class="line">345 是 3 位数字（位数为奇数）  </span><br><span class="line">2 是 1 位数字（位数为奇数） </span><br><span class="line">6 是 1 位数字 位数为奇数） </span><br><span class="line">7896 是 4 位数字（位数为偶数）  </span><br><span class="line">因此只有 12 和 7896 是位数为偶数的数字</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [555,901,482,1771]</span><br><span class="line">输出：1 </span><br><span class="line">解释： </span><br><span class="line">只有 1771 是位数为偶数的数字。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 500</span><br><span class="line">1 &lt;= nums[i] &lt;= 10^5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>可以把每个数转换成字符串然后求字符串的长度是不是偶数</li>
<li>也可以直接判断数所在的区间来判断数的长度是不是偶数长度</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> self.check(i) == <span class="literal">True</span>:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(str(x)) % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="判断数在的区间"><a href="#判断数在的区间" class="headerlink" title="判断数在的区间"></a>判断数在的区间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &gt;= <span class="number">1</span> &amp;&amp; t &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">99</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt;= <span class="number">100</span> &amp;&amp; t &lt;= <span class="number">999</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt;= <span class="number">1000</span> &amp;&amp; t &lt;= <span class="number">9999</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt;= <span class="number">10000</span> &amp;&amp; t &lt;= <span class="number">99999</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt;= <span class="number">100000</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-13. 罗马数字转整数</title>
    <url>/2019/12/28/leetcode-13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</span><br><span class="line"></span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br><span class="line">给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>

<h2 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>

<h2 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>第一次见这道题的时候完全蒙蔽，现在居然能直接做出来了，进步了？</li>
<li>因为很明显可以直接从左往右读，所以只需要处理特殊情况，I、X、C就行了，看其后面有没有对应的4、9、40、90…。如果有，一次性就把两个字符转换成数字，否则就一次读一个字符。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//查看是否有IV、IX、XL。。。之类的存在</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'I'</span> &amp;&amp; (i+<span class="number">1</span>)&lt;s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">'V'</span>) &#123;</span><br><span class="line">                <span class="comment">//加上对应的值，然后指针多跳一个，算上for循环的i++就相当于一次读取两个字符了</span></span><br><span class="line">                res += <span class="number">4</span>;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'I'</span> &amp;&amp; (i+<span class="number">1</span>)&lt;s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">'X'</span>) &#123;</span><br><span class="line">                res += <span class="number">9</span>;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'X'</span> &amp;&amp; (i+<span class="number">1</span>)&lt;s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">'L'</span>) &#123;</span><br><span class="line">                res += <span class="number">40</span>;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'X'</span> &amp;&amp; (i+<span class="number">1</span>)&lt;s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">'C'</span>) &#123;</span><br><span class="line">                res += <span class="number">90</span>;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'C'</span> &amp;&amp; (i+<span class="number">1</span>)&lt;s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">'D'</span>) &#123;</span><br><span class="line">                res += <span class="number">400</span>;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'C'</span> &amp;&amp; (i+<span class="number">1</span>)&lt;s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">'M'</span>) &#123;</span><br><span class="line">                res += <span class="number">900</span>;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//否则就是常规情况，一次读一个字符</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'I'</span>)&#123;</span><br><span class="line">                res+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'V'</span>)&#123;</span><br><span class="line">                res+=<span class="number">5</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'X'</span>)&#123;</span><br><span class="line">                res+=<span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'L'</span>)&#123;</span><br><span class="line">                res+=<span class="number">50</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'C'</span>)&#123;</span><br><span class="line">                res+=<span class="number">100</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'D'</span>)&#123;</span><br><span class="line">                res+=<span class="number">500</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'M'</span>)&#123;</span><br><span class="line">                res+=<span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>模拟</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-130. 被围绕的区域</title>
    <url>/2020/08/11/leetcode-130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二维的矩阵，包含 &apos;X&apos; 和 &apos;O&apos;（字母 O）。</span><br><span class="line"></span><br><span class="line">找到所有被 &apos;X&apos; 围绕的区域，并将这些区域里所有的 &apos;O&apos; 用 &apos;X&apos; 填充。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会<br>被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’<br>最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它<br>们是“相连”的。</p>
<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题目说的很透彻了，所有和边界连接的O都不会被X包围，所以只需要找到所有和O连接的O，然后把剩下的O改成X就行了，而找到所有与边界O连接的O只需要对所有边界的O进行dfs就行了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> r = board.size();</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> c = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//对于所有的行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="comment">//第一列的所有行</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(board, r, c, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//最后一列的所有行</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][c - <span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(board, r, c, i, c - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于所有的列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="comment">//第一行的所有的列</span></span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(board, r, c, <span class="number">0</span>, j);</span><br><span class="line">            <span class="comment">//最后一行的所有的列</span></span><br><span class="line">            <span class="keyword">if</span> (board[r - <span class="number">1</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(board, r, c, r - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于所有边界上不是与边界O相连的O改成X</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">'X'</span>) &#123;</span><br><span class="line">                    <span class="comment">//对于没有标记过的O(即被X包围的O)</span></span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">'O'</span>) &#123;</span><br><span class="line">                        <span class="comment">//改成X</span></span><br><span class="line">                        board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                    <span class="comment">//A是与边界O相连的O，对于这种O，再把标记改回去    </span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'A'</span>) &#123;</span><br><span class="line">                        board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= r || j &lt; <span class="number">0</span> || j &gt;= c || board[i][j] != <span class="string">'O'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行标记，把与边界相连的O进行标记，表示它是与边界相连的O</span></span><br><span class="line">        board[i][j] = <span class="string">'A'</span>;</span><br><span class="line">        dfs(board, r, c, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, r, c, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, r, c, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(board, r, c, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surrounded-regions/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-133. 克隆图</title>
    <url>/2020/08/12/leetcode-133.%20%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</span><br><span class="line"></span><br><span class="line">图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">测试用例格式：</span><br><span class="line"></span><br><span class="line">简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1）</span><br><span class="line">，第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。</span><br><span class="line"></span><br><span class="line">邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</span><br><span class="line"></span><br><span class="line">给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝</span><br><span class="line"> 作为对克隆图的引用返回。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>给的节点必定是1，而且节点的值就是节点的索引，所以说用bfs来遍历图就很方便。也就是说既然要返回一个图的深拷贝 ，我们需要用来的节点进行bfs的同时去创造自己的图，因为节点的值就是索引，所以可以用数组来存储每个节点。</li>
<li>用一个标记数组判断cur-&gt;val这个节点是否走过，如果没走过就把这个节点进行bfs，把这个节点先深拷贝一份，然后对这个节点的周围也连接（如果周围节点为空首先要创建节点）。最后bfs完了，就拷贝完了，返回第一个节点的地址就行。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">cloneGraph</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="comment">//因为节点值就是节点的索引，所以用整形数组标记节点走没走过</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">book</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//同理，用数组存储指定节点的地址</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;Node *&gt; <span class="title">address</span><span class="params">(<span class="number">101</span>, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">        <span class="comment">//队列操作，因为要遍历原来的图，所以一直存放的是原来的图的地址</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;Node *&gt; q;</span><br><span class="line">        q.push(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            Node *cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//这个点必须没有走过</span></span><br><span class="line">            <span class="keyword">if</span> (book[cur-&gt;val] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//标记为走过</span></span><br><span class="line">                book[cur-&gt;val] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果这个点还没有地址，自然根据原来的点的值生成新的节点</span></span><br><span class="line">                <span class="keyword">if</span> (address[cur-&gt;val] == <span class="literal">nullptr</span>)</span><br><span class="line">                    address[cur-&gt;val] = <span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">                <span class="comment">//把每个节点的相邻的节点都放到队列里面，完成了图的bfs遍历</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur-&gt;neighbors.size(); i++) &#123;</span><br><span class="line">                    <span class="comment">//如果自己的图的这个点的邻接没有地址</span></span><br><span class="line">                    <span class="keyword">if</span> (address[cur-&gt;neighbors[i]-&gt;val] == <span class="literal">nullptr</span>)</span><br><span class="line">                        <span class="comment">//就根据原来的图中的节点的值生成新的节点</span></span><br><span class="line">                        address[cur-&gt;neighbors[i]-&gt;val] = <span class="keyword">new</span> Node(cur-&gt;neighbors[i]-&gt;val);</span><br><span class="line">                    <span class="comment">//然后让自己图中的节点连接上原来图中指定节点的连接的节点的新节点</span></span><br><span class="line">                    address[cur-&gt;val]-&gt;neighbors.push_back(address[cur-&gt;neighbors[i]-&gt;val]);</span><br><span class="line">                    <span class="comment">//继续遍历原来的图中的节点</span></span><br><span class="line">                    q.push(cur-&gt;neighbors[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//题目要求，返回第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> address[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/clone-graph/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1305. 两棵二叉搜索树中的所有元素</title>
    <url>/2019/08/03/leetcode-1305.%20%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你 root1 和 root2 这两棵二叉搜索树。</span><br><span class="line"></span><br><span class="line">请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e1.png</span><br><span class="line">输入：root1 = [2,1,4], root2 = [1,0,3]</span><br><span class="line">输出：[0,1,1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root1 = [0,-10,10], root2 = [5,1,7,0,2]</span><br><span class="line">输出：[-10,0,0,1,2,5,7,10]</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root1 = [], root2 = [5,1,7,0,2]</span><br><span class="line">输出：[0,1,2,5,7]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>最暴力的，中序遍历两个BST，然后都存到一个集合里，对集合排序。</li>
<li>或者分别中序遍历两个BST，然后双指针放入新的集合。其实就是归并排序的merger操作</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="全部放到一个集合里面"><a href="#全部放到一个集合里面" class="headerlink" title="全部放到一个集合里面"></a>全部放到一个集合里面</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getAllElements</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root1, res);</span><br><span class="line">        inOrder(root2, res);</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode cur, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(cur.left, res);</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        inOrder(cur.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getAllElements</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; a1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; a2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root1, a1);</span><br><span class="line">        inOrder(root2, a2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; a1.size() &amp;&amp; j &lt; a2.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a1.get(i) &lt; a2.get(i)) &#123;</span><br><span class="line">                res.add(a1.get(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(a2.get(j));</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= a1.size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; a2.size(); k++)</span><br><span class="line">                res.add(a2.get(k));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; a1.size(); k++)</span><br><span class="line">                res.add(a1.get(k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode cur, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(cur.left, res);</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        inOrder(cur.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-145. 二叉树的后序遍历</title>
    <url>/2019/10/17/leetcode-145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，返回它的 后序 遍历。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>同二叉树的中序遍历的封装方法。</li>
<li><a href="http://why0609why.com/2019/10/05/leetcode-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" target="_blank" rel="noopener">http://why0609why.com/2019/10/05/leetcode-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</a></li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 如果是空集合，自然就遍历不到任何值</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 声明一个栈</span></span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        stack.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 模拟系统栈调用递归中序遍历二叉树的过程</span></span><br><span class="line">        <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 每次拿到栈顶元素</span></span><br><span class="line">            cur = stack.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果cur是dict类型，也就是说这是个需要操作节点的值的标记，因为</span></span><br><span class="line">            <span class="comment"># 这个标记，所以要处理节点的值，根据题意就是把节点的值放到集合返回</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(cur, dict):</span><br><span class="line">                res.append(cur[<span class="string">'val'</span>])</span><br><span class="line">            <span class="comment"># 那么很自然的，既然这里没有需要操作节点的值的标记，那就是正常的模拟递归了</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这里把对节点需要操作的标记用字典来实现</span></span><br><span class="line">                stack.append(&#123;<span class="string">'val'</span>: cur.val&#125;)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 先把cur的右孩子入栈，别忘了栈使先进后出</span></span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(cur.right)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 同理将cur的左孩子入栈</span></span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(cur.left)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当栈为空时，系统栈模拟递归完成</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>注意处理不同的序遍历时候用栈模拟的入栈顺序，入站顺序就是递归的倒序入栈。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-141. 环形链表</title>
    <url>/2019/12/28/leetcode-141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表，判断链表中是否有环。</span><br><span class="line"></span><br><span class="line">为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4]</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的是用集合存储已经走过的链表，并且用cur指针遍历链表，如果发现当前的cur是集合中存储的内容，就说明有环，否则就把cur添加到集合中。</li>
<li>后来想到用两个指针，一个快指针j，一个慢指针i。i每次后移一个位置，j每一后移两个位置，如果i和j相遇的时候就说明有环，如果两者有一个为null就说明链表无环。</li>
<li>还有一种奇妙的做法，每遍历到一个节点，就把这个节点的值改成一个固定的特殊值，然后继续遍历，如果发现新遍历到的节点的值是这个固定的特殊值，就说明链表有环，但是这样破坏了链表，还不如给链表加一个index索引属性。所以不采取这种做法。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;ListNode&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cur标记当前链表节点</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果发现cur的节点走过，就说明有环</span></span><br><span class="line">            <span class="keyword">if</span> (arrayList.contains(cur))&#123;</span><br><span class="line">                index = arrayList.indexOf(cur);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则记录cur当前的节点</span></span><br><span class="line">                arrayList.add(cur);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当遍历过无环的链表就返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判情况，如果链表长度为0，一定无环，长度为1，如果head的next不指向自己一定也无环</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立快慢指针</span></span><br><span class="line">        ListNode i = head;</span><br><span class="line">        ListNode j = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i、j都是链表中的内容，只要有一个为空，链表自然无环</span></span><br><span class="line">        <span class="keyword">while</span> (i != <span class="keyword">null</span> &amp;&amp; j != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果两个指针相遇就说明有环</span></span><br><span class="line">            <span class="keyword">if</span> (i == j)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i向后移动一个</span></span><br><span class="line">            i = i.next;</span><br><span class="line">            <span class="comment">//因为j是移动两个位置，所以要对j的next进行空指针特判，如果有null一定无环</span></span><br><span class="line">            <span class="keyword">if</span> (j.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//j移动两个位置</span></span><br><span class="line">            j = j.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>没事可以多用双指针完成一些奇奇妙妙的东西</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-15. 三数之和</title>
    <url>/2020/02/12/leetcode-15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，</span><br><span class="line">使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>其实思路很像两数之和，如果用暴力走两数之和，那么复杂度就是O(n^2)，如果给数组排序，然后双指针，一个从头开始，一个从尾部开始，如果a[i]+a[j]&gt;target，那么j左移，如果a[i]+a[j]&lt; target，i右移，直到两个指针相遇。</li>
<li>那么回到三数之和，先把数组排序我们遍历每一个数，把这个数当作a[k]，然后从k+1到a.length-1进行类似双指针的做法。这样利用了排序的手段，减少了一个O(n)的指数上的复杂度。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//先排序数组</span></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        <span class="comment">//枚举每个a[k]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.length; k++) &#123;</span><br><span class="line">            <span class="comment">//在a[k]后面进行双指针，利用排序提供的双指针</span></span><br><span class="line">            <span class="keyword">int</span> i = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = a.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[k] + a[i] + a[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] + a[i] + a[j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = Arrays.asList(a[k], a[i], a[j]);</span><br><span class="line">                    <span class="keyword">if</span> (!res.contains(list))</span><br><span class="line">                        res.add(list);</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>遇到O(n^2)的问题，可以使用排序获得双指针的使用权，来减少一个指数上的O(n)复杂度。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-160. 相交链表</title>
    <url>/2019/12/28/leetcode-160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编写一个程序，找到两个单链表相交的起始节点。</span><br><span class="line">如下面的两个链表：</span><br><span class="line">在节点 c1 开始相交。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="keyword">null</span></span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 <span class="keyword">null</span>。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>就是给你两个链表，然后两个链表的所有节点都有自己提前分配好的内存地址，让你找这个这两个链表的相交的地方，也就是找到两个链表第一个内存地址一样的节点。</li>
<li>一开始用的是二重循环，二重遍历所有的引用值，外层是第一个链表的，内层是第二个链表的。但是这样有点慢。</li>
<li>第二个方法就是用集合存储第一个链表的所有引用值，然后遍历第二个链表，找到看看集合里面有没有存储过的。</li>
<li>第三个和第二个差不多，只不过存储用的是map</li>
<li>第四个就是两个指针，用cur1和cur2分别指向两个链表的头，然后同时向后遍历，当一个链表遍历到头的时候就去从头遍历另一个链表，另一个链表也是如此，直到两个指针相遇的时候就返回true，或者只要有一个节点是null的时候就返回false。第四种方法的图解：<a href="https://pic.leetcode-cn.com/5651993ddb76ae6a42f0b338aec9382206f567041113f49d6ca670832ac75791-Picture1.png，假设la是链表a的长度，lb是链表b的长度，那么la+lb" target="_blank" rel="noopener">https://pic.leetcode-cn.com/5651993ddb76ae6a42f0b338aec9382206f567041113f49d6ca670832ac75791-Picture1.png，假设la是链表a的长度，lb是链表b的长度，那么la+lb</a> = lb+la，而且两个链表相同节点后面的长度也是一样的，所以只要两个链表都同时往后移动一个，并且移动到尽头的时候移动到另一个节点的头节点，这样la+lb-lc = lb+la-lc，lc是公共长度。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="二重循环"><a href="#二重循环" class="headerlink" title="二重循环"></a>二重循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ListNode i = headA; i != <span class="keyword">null</span>; i = i.next) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ListNode j = headB; j != <span class="keyword">null</span>; j = j.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用数组存储引用值"><a href="#用数组存储引用值" class="headerlink" title="用数组存储引用值"></a>用数组存储引用值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        List&lt;ListNode&gt; listNodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把链表a的所有节点的引用值都放到集合里面</span></span><br><span class="line">        ListNode cur = headA;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            listNodes.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在集合中寻找b的所有节点的引用值</span></span><br><span class="line">        cur = headB;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (listNodes.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表存储引用值"><a href="#哈希表存储引用值" class="headerlink" title="哈希表存储引用值"></a>哈希表存储引用值</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        Map&lt;ListNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//哈希表存储引用值</span></span><br><span class="line">        ListNode cur = headA;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(cur,<span class="number">1</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在哈希表中寻找b的所有节点的引用值</span></span><br><span class="line">        cur = headB;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(cur))&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自己想的第4中方法，通过长度来停止两个指针的遍历"><a href="#自己想的第4中方法，通过长度来停止两个指针的遍历" class="headerlink" title="自己想的第4中方法，通过长度来停止两个指针的遍历"></a>自己想的第4中方法，通过长度来停止两个指针的遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode cur1 = headA;</span><br><span class="line">        ListNode cur2 = headB;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> la = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算a链表的长度</span></span><br><span class="line">        ListNode cur = headA;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            la++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算b链表的长度</span></span><br><span class="line">        cur = headB;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lb++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个指针开始从头遍历</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当两个指针一样地址值的时候就表明找到相交节点了。</span></span><br><span class="line">            <span class="keyword">if</span> (cur1 == cur2) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每遍历一次就记一次数,如果遍历次数过多就说明两个没有相交节点</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; la+lb)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针后移,如果某个链表遍历完之后就去遍历新节点</span></span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur1 = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            <span class="keyword">if</span> (cur2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur2 = headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出循环的时候表示两个链表没有相交的内容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用双指针来代替长度法"><a href="#用双指针来代替长度法" class="headerlink" title="用双指针来代替长度法"></a>用双指针来代替长度法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode cur1 = headA;</span><br><span class="line">        ListNode cur2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只需要判断两个cur1和cur2一不一样，因为就算两个节点没有公共节点，那么他们最后的交点也是null，所以直接返回cur1或者cur2就行了</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2)&#123;</span><br><span class="line">            <span class="comment">//如果碰到一样的直接返回true</span></span><br><span class="line">            <span class="keyword">if</span> (cur1 == cur2)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur1的后移</span></span><br><span class="line">            <span class="keyword">if</span> (cur1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur1 = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur2的后移</span></span><br><span class="line">            <span class="keyword">if</span> (cur2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur2 = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>没事多画图</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-168. Excel表列名称</title>
    <url>/2020/01/01/leetcode-168.%20Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个正整数，返回它在 Excel 表中相对应的列名称。</span><br><span class="line"></span><br><span class="line">例如，</span><br><span class="line"></span><br><span class="line">    1 -&gt; A</span><br><span class="line">    2 -&gt; B</span><br><span class="line">    3 -&gt; C</span><br><span class="line">    ...</span><br><span class="line">    26 -&gt; Z</span><br><span class="line">    27 -&gt; AA</span><br><span class="line">    28 -&gt; AB </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;A&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 28</span><br><span class="line">输出: &quot;AB&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 701</span><br><span class="line">输出: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>进制转换,从10进制转换到指定进制的时候最好从尾部开始，这里的处理方法，每次对于26取余，如果余数为0，则添加’Z’，如果余数不是0，就添加余数对应的字符。然后n/=26(为了进制转换)，这里有个特殊情况，如果余数是0，n/=26完了还要-1.</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于字符串的操作用StringBuffer会好一点,最后把StringBUffer转换成String就行了</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用类似于求10进制差不多的方法</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//先拿到余数</span></span><br><span class="line">            <span class="keyword">int</span> t = n % <span class="number">26</span>;</span><br><span class="line">            <span class="comment">//如果余数是0，表示直接整除26，自然添加Z</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">'Z'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则就是正常的，换算成余数对应的字符就行</span></span><br><span class="line">                sb.append((<span class="keyword">char</span>) (<span class="string">'A'</span> + t - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 要注意到如果余数是0，要n--，因为对应的1到26已经计算过了。所以要n--</span></span><br><span class="line">            <span class="keyword">if</span> (t==<span class="number">0</span>)&#123;</span><br><span class="line">                n/=<span class="number">26</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                n/=<span class="number">26</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为是从尾部开始计算的，所以自然算出的字符串结果要反转</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>对于进制转换的题，比如X转10进制，就和二进制变10进制的感觉是一样的，而10进制变其他进制就需要求余数，然后求除数就行了。</li>
<li>对于字符串的操作为了减少内存用StringBuffer进行操作字符串，然后再转换成String返回就行了</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/excel-sheet-column-title/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-155. 最小栈</title>
    <url>/2019/11/28/leetcode-155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</span><br><span class="line"></span><br><span class="line">push(x) -- 将元素 x 推入栈中。</span><br><span class="line">pop() -- 删除栈顶的元素。</span><br><span class="line">top() -- 获取栈顶元素。</span><br><span class="line">getMin() -- 检索栈中的最小元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>现在写的复杂度太高了，等以后实现了全部的数据结构再回来做这道题</li>
<li>用堆维护栈的最小值就行了。剩下的和普通的栈一样</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.data = []</span><br><span class="line">        self.heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.data.append(x)</span><br><span class="line">        self.heap.append(x)</span><br><span class="line">        heapq.heapify(self.heap)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        t = self.data[len(self.data) - <span class="number">1</span>]</span><br><span class="line">        self.data.pop()</span><br><span class="line">        self.heap.remove(t)</span><br><span class="line">        heapq.heapify(self.heap)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[len(self.data) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-167.两数之和 II - 输入有序数组</title>
    <url>/2019/07/29/leetcode-167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</span><br><span class="line"></span><br><span class="line">函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回的下标值（index1 和 index2）不是从零开始的。</span><br><span class="line">你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>双重遍历，j在i之后找目标的值，不出所料，时间很长</li>
<li>然后用map，键存每个值，值存每个值对应的索引</li>
<li>然后题目又提到了有序，那就不免想到二分，用二分去查找另一个加数</li>
<li>因为是有序的，也不能忘了双指针，一个从左一个从右，计算和，如果和大于target那么i就往右走，如果小于target，j就往左走，如果相等就直接返回</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="双重遍历"><a href="#双重遍历" class="headerlink" title="双重遍历"></a>双重遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双重遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; a.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i]+a[j]==target)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i+<span class="number">1</span>;</span><br><span class="line">                    res[<span class="number">1</span>] = j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为题目要求的是从1开始计数的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            map.put(a[i],i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//这里是细节，为了不让map找另一个加数的时候找到自己，在从map里面找的时候选定索引和本身加数的索引不一样</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target-a[i]) &amp;&amp; map.get(target-a[i])!=(i+<span class="number">1</span>))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i+<span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(target-a[i]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> del = target-a[i];</span><br><span class="line">            <span class="keyword">int</span> j = bin(a,del,i);</span><br><span class="line">            <span class="keyword">if</span> (j!=-<span class="number">1</span> &amp;&amp; j!=i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bin</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target,<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里用二分的时候要注意，因为存在一种情况就是当两个加数都一样的的时候，也就是两个加数在原数组中的位置是连在一起的(因为是有序的),这时候二分容易找到自己，所///以说为了避免这种情况，在查找时为了不找到自己就先把自己赋值成一个很奇怪的数，这时候用二分去找另一个加数。</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t =a[flag];</span><br><span class="line">        a[flag] = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((r-l)/<span class="number">2</span>) +l;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &gt; target)&#123;</span><br><span class="line">                r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[mid]&lt;target)&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在找完之后再把那个数变回去</span></span><br><span class="line">        a[flag] = t;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=a.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]+a[j]&gt;target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[i]+a[j]&lt;target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li><p>二分的板子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在数组里找一个值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bin</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = a.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((r-l)/<span class="number">2</span>) +l;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &gt; target)&#123;</span><br><span class="line">                r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[mid]&lt;target)&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提到有序就不能忘了二分</p>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-169.求众数</title>
    <url>/2019/07/26/leetcode-169.%E6%B1%82%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</span><br><span class="line"></span><br><span class="line">你可以假设数组是非空的，并且给定的数组总是存在众数。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>有点脑筋急转弯的感觉，此处的众数定义不同，说的是大于n/2次数的元素，分析可以知道，数组排序之后，不管数组长度是奇数还是偶数，在数组a[n/2]的位置一定是这道题的众数，如图<img src="/image/leetcode-169.png" alt>因为出现次数大于n/2，所以排了序不管怎么分布，奇数长度中间那个位置一定是众数，偶数长度中间哪两个位置一定都是众数</li>
<li>当然也可以用哈希表记录每个元素出现的次数，在记录元素出现的最大次数的时候顺路比较得出最大值</li>
<li>也可以看摩尔投票法</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="排序做法"><a href="#排序做法" class="headerlink" title="排序做法"></a>排序做法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表做法"><a href="#哈希表做法" class="headerlink" title="哈希表做法"></a>哈希表做法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组中的每一个数，统计其出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="comment">//如果不存在的话，次数就放1</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(i))&#123;</span><br><span class="line">                map.put(i,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//存在过的话就把出现的次数+1，加一之后和最大值相比，如果更新顺带更新索引</span></span><br><span class="line">                map.put(i,map.get(i)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(i) &gt; max)&#123;</span><br><span class="line">                    max = map.get(i);</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max==-<span class="number">1000000</span>? a[<span class="number">0</span>]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">            <span class="comment">//碰到一样的元素，出现的次数+1</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] == temp)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不一样的话就--</span></span><br><span class="line">                ans--;</span><br><span class="line">                <span class="comment">//如果出现的次数为1的时候，就更换记录的数字</span></span><br><span class="line">                <span class="keyword">if</span> (ans == <span class="number">0</span>)&#123;</span><br><span class="line">                    temp = a[i];</span><br><span class="line">                    ans = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接分治</span></span><br><span class="line">        <span class="keyword">return</span> divide(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出当前区间内的出现次数最多的数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这就是递归到最小的子区间了，不能再递归了</span></span><br><span class="line">        <span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[l];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样求mid不会溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">        <span class="comment">//递归左区间，得到左区间的出现次数最多数</span></span><br><span class="line">        <span class="keyword">int</span> lmax = divide(a,l,mid);</span><br><span class="line">        <span class="comment">//递归右区间，得到右区间里的出现次数最多的数</span></span><br><span class="line">        <span class="keyword">int</span> rmax = divide(a,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个区间的左半区间和一个区间的右半区间的出现次数最多的数出现了，得</span></span><br><span class="line">        <span class="comment">//判断出这两个区间所对应的的众数那个才是这整个区间的众数，进行一个判断</span></span><br><span class="line">        <span class="keyword">int</span> lmaxsum = count(a,lmax,l,r);</span><br><span class="line">        <span class="keyword">int</span> rmaxsum = count(a,rmax,l,r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lmaxsum&gt;=rmaxsum? lmax:rmax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出此区间中temp这个数出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> temp, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == temp)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>摩尔投票法 ： 假设数组的长度是n，当数组中某个元素出现的次数大于n/2的那个数是i(此时i的最小值为n/2向上取整+1)，数组中的不一样的两个数两两抵消，最终当n为奇数的时候，最后剩下一个是i，当n为偶数的时候，最后剩下两个i。原理是可以看成有n个国家打仗，你有大于n/2个国家势力，你的势力没有内讧，如果过家门两两互殴并且同归于尽，并且都没有内讧，最后剩下的一定是你的势力。因为最坏的情况就是所有国家都来打你，而你正好比全部的一半多一点点，就算这样你最后也能剩下一丢丢。更何况还存在其他国家互殴的情况，剩下的肯定是你了。摩尔投票法：大于一半的数在数组中经历了两两消失，最后剩下的一定是那个数(相同的不消失)。</li>
<li>分治的时候，mid = (r-l)/2+l可以防止溢出</li>
<li>分治的时候，分块的处理是，当长度为奇数的时候，正好是左边一半加一，如长度为5的话，左区间是1，2，3，右区间是4，5；如果长度是4的话，左区间是1、2，有区间是3、4，所有奇数偶数都符合这两个分块处理原则。</li>
<li>分治dfs的组成部分：1.最小子问题的处理、2.递归、3.递归以后的处理；分治重要的是divide的功能。把一个divide分成两个divide，两个divide再分成四个divide，直到最小的子问题。</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>分治</tag>
        <tag>摩尔投票法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-17. 电话号码的字母组合</title>
    <url>/2020/08/27/leetcode-17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</span><br><span class="line"></span><br><span class="line">给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span><br><span class="line">图片地址</span><br><span class="line">https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题目很简单就是遍历字符串，然后每次从对应按键（数字）的字母中选择一个，然后拼接成字符串就行。直接回溯</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">                                       &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;,</span><br><span class="line">                                       &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;,</span><br><span class="line">                                       &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">                                       &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;,</span><br><span class="line">                                       &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;,</span><br><span class="line">                                       &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;,</span><br><span class="line">                                       &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">string</span> temp = <span class="string">""</span>;</span><br><span class="line">        backTrace(mp, ans, digits, temp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ans用引用可以省去用全局变量</span></span><br><span class="line">    <span class="comment">//中间变量也用引用temp也很方便</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; &amp;mp, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ans, <span class="built_in">string</span> &amp;digits, <span class="built_in">string</span> &amp;temp, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == digits.size()) &#123;</span><br><span class="line">            <span class="comment">//vector的push_back很神奇，你只要插入进去，插入后的元素内容不会再发生变化。</span></span><br><span class="line">            <span class="comment">//这个java指针是不一样的，如果插入的是指针，那还是和java一样的。但是这里用的是引用</span></span><br><span class="line">            <span class="comment">//特殊的地方就是这里</span></span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : mp[digits[start]]) &#123;</span><br><span class="line">            temp.push_back(c);</span><br><span class="line">            backTrace(mp, ans, digits, temp, start + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>vector的push_back插入元素后，被插入到vector里面的元素就不会发生改变了，（前提不是指针）</li>
<li>所以以后用回溯的时候，尤其是中间变量的函数传参地方，就会很方便，当回溯到了结果的地方的时候，中间变量可以直接插入到vector里面（因为插入后就不会其在vector里面就不会因为vector外面的引用发生改变而改变）这个很特殊，</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-171. Excel表列序号</title>
    <url>/2020/01/01/leetcode-171.%20Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个Excel表格中的列名称，返回其相应的列序号。</span><br><span class="line"></span><br><span class="line">例如，</span><br><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A&quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;AB&quot;</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;ZY&quot;</span><br><span class="line">输出: 701</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显找规律，可以发现当长度为2时，第一位代表的数是26<em>(字符代表的数，如A=1,B=2)，第二位代表的数就是字符代表的数；当长度为3的时候，第一位的计算方法是26^2</em>字符代表的数，第二位是26乘以字符代表的数，第三位直接就是字符代表的数。</li>
<li>所以规律就出来了，假设有字符串的长度是n，第一位的计算方法是26^(n-1)*字符代表的数，如此往后推就行了，知道最后一位是字符代表的数。但是当n==1的时候，需要特判，也就是直接加上字符代表的数。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="map存储字符对应的数"><a href="#map存储字符对应的数" class="headerlink" title="map存储字符对应的数"></a>map存储字符对应的数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先用map存储对应的数</span></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'B'</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">'E'</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'F'</span>,<span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">'G'</span>,<span class="number">7</span>);</span><br><span class="line">        map.put(<span class="string">'H'</span>,<span class="number">8</span>);</span><br><span class="line">        map.put(<span class="string">'I'</span>,<span class="number">9</span>);</span><br><span class="line">        map.put(<span class="string">'J'</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'K'</span>,<span class="number">11</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>,<span class="number">12</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>,<span class="number">13</span>);</span><br><span class="line">        map.put(<span class="string">'N'</span>,<span class="number">14</span>);</span><br><span class="line">        map.put(<span class="string">'O'</span>,<span class="number">15</span>);</span><br><span class="line">        map.put(<span class="string">'P'</span>,<span class="number">16</span>);</span><br><span class="line">        map.put(<span class="string">'Q'</span>,<span class="number">17</span>);</span><br><span class="line">        map.put(<span class="string">'R'</span>,<span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">'S'</span>,<span class="number">19</span>);</span><br><span class="line">        map.put(<span class="string">'T'</span>,<span class="number">20</span>);</span><br><span class="line">        map.put(<span class="string">'U'</span>,<span class="number">21</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>,<span class="number">22</span>);</span><br><span class="line">        map.put(<span class="string">'W'</span>,<span class="number">23</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>,<span class="number">24</span>);</span><br><span class="line">        map.put(<span class="string">'Y'</span>,<span class="number">25</span>);</span><br><span class="line">        map.put(<span class="string">'Z'</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到字符串对应的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> t = len-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//res是最后结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//对0进行特判</span></span><br><span class="line">            <span class="keyword">if</span> (t!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//找到刚才的规律公式</span></span><br><span class="line">                <span class="keyword">int</span> tt = map.get(s.charAt(i));</span><br><span class="line">                res = res + (<span class="keyword">int</span>) (tt * Math.pow(<span class="number">26</span>, t));</span><br><span class="line">                t--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是最后一位数的话,就直接返回字符对应的数就OK。</span></span><br><span class="line">                res+=map.get(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ASCII存储对应的字符"><a href="#ASCII存储对应的字符" class="headerlink" title="ASCII存储对应的字符"></a>ASCII存储对应的字符</h2><p>因为用map花时间了，所以用ASCII码代替map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和刚才逻辑一样，只不过用ASCII代替从map获取对应的值的过程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> t = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tt = s.charAt(i) - <span class="number">64</span>;</span><br><span class="line">                res = res + (<span class="keyword">int</span>) (tt * Math.pow(<span class="number">26</span>, t));</span><br><span class="line">                t--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = res + s.charAt(i) - <span class="number">64</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>多发现规律</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/excel-sheet-column-number/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-18. 四数之和</title>
    <url>/2020/02/12/leetcode-18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中</span><br><span class="line">是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？</span><br><span class="line">找出所有满足条件且不重复的四元组。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">答案中不可以包含重复的四元组。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>O(n^5*log n)，用排序来防止存入的集合重复，每次存放结果集合的时候先排序，并且检查结果大集合里面是否已经存在这个集合了，如果有了就不存了。</li>
<li>还有同两数之和的双指针的解法，而且几乎和三数之和的双指针解法相同，枚举每一个a[z]然后再a[z]的后面枚举a[k]，然后在a[k]后面进行双指针i,j，如果四个数的和大于target，j左移，小于target就右移。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; a.length; k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> z = k + <span class="number">1</span>; z &lt; a.length; z++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (a[i] + a[j] + a[k] + a[z] == target) &#123;</span><br><span class="line">                            List&lt;Integer&gt; list = Arrays.asList(a[i], a[j], a[k], a[z]);</span><br><span class="line">                            <span class="comment">//排序确保不重复</span></span><br><span class="line">                            Collections.sort(list);</span><br><span class="line">                            <span class="keyword">if</span> (!res.contains(list))</span><br><span class="line">                                res.add(list);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//这个双指针需要排序</span></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举每一个z</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; a.length; z++) &#123;</span><br><span class="line">            <span class="comment">//在每一个z后面枚举k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = z + <span class="number">1</span>; k &lt; a.length; k++) &#123;</span><br><span class="line">                <span class="comment">//在k后面进行双指针</span></span><br><span class="line">                <span class="keyword">int</span> i = k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> j = a.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[z] + a[k] + a[i] + a[j] &gt; target) &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[z] + a[k] + a[i] + a[j] &lt; target) &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        List&lt;Integer&gt; list = Arrays.asList(a[z], a[k], a[i], a[j]);</span><br><span class="line">                        <span class="keyword">if</span> (!res.contains(list))</span><br><span class="line">                            res.add(list);</span><br><span class="line">                        i++;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>两数、三数、四数之和真的是很经典了，一个双指针能省去一个O(n)指数上的复杂度。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/4sum/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum/submissions/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-189. 旋转数组</title>
    <url>/2019/08/02/leetcode-189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li><p>有很多种处理方法</p>
</li>
<li><p>最开始想了一种方法，既然要移动原数组a，直接新开辟一块数组空间res，直接把原数组的后k位放到新空间的前k位，然后再把原数组a剩下的数字依次放到新数组res后面，但是这样是存在一种情况，如果每次都要改变数组的时候，比如长度是2，k是100，就是两个数来回在那里换，经过分析后，一个数组如果长度是len，数组中一个数变len次，最终还会回到其原来的位置，所以只需把k对数组的长度取余就可以放心的使用这种方法了。</p>
</li>
<li><p>然后又想，数组的每次变换其实都可以看成从第一个数到倒数第二个数，都往后移动一个，再把最后一个放到首位，然后如果变换k次，那就这么执行k次，就达到了变化k次的效果。</p>
</li>
<li><p>这里还有一条规律：直接把数组全部反转，然后把前k位反转，再把上下的反转，算是一个数组向右移动k位的规律</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原始数组                  : 1 2 3 4 5 6 7</span><br><span class="line">反转所有数字后             : 7 6 5 4 3 2 1</span><br><span class="line">反转前 k 个数字后          : 5 6 7 4 3 2 1</span><br><span class="line">反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果</span><br></pre></td></tr></table></figure>
</li>
<li><p>官方题解的第三种做法看不懂。</p>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="直接移动"><a href="#直接移动" class="headerlink" title="直接移动"></a>直接移动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//k先取余</span></span><br><span class="line">        k%=a.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接把原数组的后k位放到新数组的前k位</span></span><br><span class="line">        System.arraycopy(a,a.length-k,res,<span class="number">0</span>,k);</span><br><span class="line">        <span class="comment">//再把原数组剩下的数从第k位开始放，把原数组剩下的数都放完</span></span><br><span class="line">        System.arraycopy(a,<span class="number">0</span>,res,k,a.length-k);</span><br><span class="line">        <span class="comment">//因为要返回的是原数组，所以再把有结果的数组的值都放到a数组里</span></span><br><span class="line">        System.arraycopy(res,<span class="number">0</span>,a,<span class="number">0</span>,a.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移动k次"><a href="#移动k次" class="headerlink" title="移动k次"></a>移动k次</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[a.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从第一个数到倒数第二个数都往后放一个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=a.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                a[i+<span class="number">1</span>] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再把最后一个数放到第一个数上</span></span><br><span class="line">            a[<span class="number">0</span>] = t;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="规律做法"><a href="#规律做法" class="headerlink" title="规律做法"></a>规律做法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        k%=a.length;</span><br><span class="line">        <span class="comment">//先全部反转</span></span><br><span class="line">        reverse(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//再反转前k位</span></span><br><span class="line">        reverse(a,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//再反转剩下的</span></span><br><span class="line">        reverse(a,k,a.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = t;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-191. 位1的个数</title>
    <url>/2020/01/01/leetcode-191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>直接转换成二进制求1的个数就行，调用Integer的toBinaryString函数就行，没什么好说的。</li>
<li>有一个规律，一个数对1进行位运算可以得到这个数二进制的最后一位，每次右移这个数，就可以遍历到全部的二进制位上的值。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="转换二进制计算字符1的个数"><a href="#转换二进制计算字符1的个数" class="headerlink" title="转换二进制计算字符1的个数"></a>转换二进制计算字符1的个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s = Integer.toBinaryString(n);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'1'</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算计算末尾是否为1"><a href="#位运算计算末尾是否为1" class="headerlink" title="位运算计算末尾是否为1"></a>位运算计算末尾是否为1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//m是提前准备好的1</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计数器res</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为一共32位,所以循环32词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//计算末尾是否是1</span></span><br><span class="line">            <span class="keyword">if</span> ((n &amp; m) == <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//n右移</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>一个x可以与1进行位运算得到x的二进制的最后一位的二进制值</li>
<li>x可以通过 x &gt;&gt;= 1来右移，其实就相当于  x /= 2</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-190. 颠倒二进制位</title>
    <url>/2020/01/01/leetcode-190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">颠倒给定的 32 位无符号整数的二进制位。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：10111111111111111111111111111111</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class="line">因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</span><br><span class="line">在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题意就是给你一个数，让你把它的二进制翻转一下然后输出反转二进制之后的数。</li>
<li>有两种做法：<ol>
<li>最暴力的做法自然就是先拿到给的n的二进制字符串，然后反转，(因为java存储的是有符号的数，而且第一位是符号位，而且也是以补码的形式存储的)，那自然就是把这个二进制字符串反转一下，再由补码变成源码再加上符号就是要输出的结果了，这个问题需要正数负数分情况讨论，因为正数的补码就是源码，直接计算二进制就OK了，但是负数要-1然后1变0，0变1。这个注意一下就好了，但是这个方法是有问题的，如果二进制翻转过来超过int的界限这个方法就不对了。</li>
<li>所以采用最简单的位与运算，仔细想，题目要求的无非是一个新的二进制，和你这个数的关系其实不大，你产生这个数其实可以操作这个数的二进制代码来进行造这个数的，不一定非要走10进制层面的。上面那个方法是通过二进制来产生10进制的，二这个方法是由二进制的位运算来产生的。每次拿到n的二进制的最后一位，都拼接在新的数最后面，这样就不用考虑10进制越界的问题了。</li>
</ol>
</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="先变二进制再变十进制"><a href="#先变二进制再变十进制" class="headerlink" title="先变二进制再变十进制"></a>先变二进制再变十进制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为不是这道题的正确解法，所以这种做法不用太关心，因为这是一个十分暴力的😂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s = Integer.toBinaryString(n);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        s = sb.toString();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    res = (<span class="keyword">int</span>) (res + Math.pow(<span class="number">2</span>, t));</span><br><span class="line">                &#125;</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[chars.length - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                chars[chars.length - <span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        chars[i] = <span class="string">'0'</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        chars[i] = <span class="string">'1'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">30</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        res = (<span class="keyword">int</span>) (res + Math.pow(<span class="number">2</span>, t));</span><br><span class="line">                    &#125;</span><br><span class="line">                    t--;</span><br><span class="line">                &#125;</span><br><span class="line">                res *= (-<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = chars.length - <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (chars[cnt] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[cnt] = <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                    chars[i] = <span class="string">'1'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        chars[i] = <span class="string">'0'</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        chars[i] = <span class="string">'1'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">30</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        res = (<span class="keyword">int</span>) (res + Math.pow(<span class="number">2</span>, t));</span><br><span class="line">                    &#125;</span><br><span class="line">                    t--;</span><br><span class="line">                &#125;</span><br><span class="line">                res *= (-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过二进制来产生数"><a href="#通过二进制来产生数" class="headerlink" title="通过二进制来产生数"></a>通过二进制来产生数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n是给你的数，10进制的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//t用来计数，确定运行32次</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//m是产生的新数</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="comment">//先产生二进制位的位置</span></span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="comment">//这句话相当于给m加上n的最后一位，根据之前的做题经验，一个数&amp;1就是这个数的二进制的最后一位。</span></span><br><span class="line">            <span class="comment">//然后m的最后一位是空的(上一步已经产生新的位置了),这里就相当于加上了n的最后一位。</span></span><br><span class="line">            m = m | (n &amp; <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//n右移一位</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>总结一波：<ol>
<li>左移：二进制的整体左移一位，相当于*2 &lt;&lt;</li>
<li>右移：二进制的整体右移一位，相当于/2  &gt;&gt;</li>
<li>位与(&amp;): 两者都为1，对应位才是1，这也就解释了问什么n&amp;1得到的是n的二进制的最后一位</li>
<li>位或(|): 两者只要有一个1，对应位置就是1</li>
<li>位异或(^): 两者不一样，对应位是1，否则是0</li>
</ol>
</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-bits/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-2. 两数相加</title>
    <url>/2019/11/25/leetcode-2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>通过递归从头开始一位一位的进行数的相加。两个链表相加产生的和，并且获得对下次两个数字的加的进位。然后处理好递归终止条件就行了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_addTwoNumbers(l1, l2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归创建两个链表的和</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_addTwoNumbers</span><span class="params">(self, c1: ListNode, c2: ListNode, extra)</span>:</span></span><br><span class="line">        <span class="comment"># 当两个都加完，并且没有进位的时候(用于处理两个链表长度一样长的情况)</span></span><br><span class="line">        <span class="keyword">if</span> c1 == <span class="literal">None</span> <span class="keyword">and</span> c2 == <span class="literal">None</span> <span class="keyword">and</span> extra != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ListNode(extra)</span><br><span class="line">        <span class="comment"># 当当个都加完，并且有进位的时候</span></span><br><span class="line">        <span class="keyword">if</span> c1 == <span class="literal">None</span> <span class="keyword">and</span> c2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># v1是链表1的值</span></span><br><span class="line">        v1 = <span class="number">0</span></span><br><span class="line">        <span class="comment"># v2是链表2的值</span></span><br><span class="line">        v2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c1 != <span class="literal">None</span>:</span><br><span class="line">            v1 = c1.val</span><br><span class="line">            c1 = c1.next</span><br><span class="line">        <span class="keyword">if</span> c2 != <span class="literal">None</span>:</span><br><span class="line">            v2 = c2.val</span><br><span class="line">            c2 = c2.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先拿到总和，注意总和还包括进位</span></span><br><span class="line">        sum = v1 + v2 + extra</span><br><span class="line">        extra = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 拿到进位</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt;= <span class="number">10</span>:</span><br><span class="line">            extra = sum // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        t = sum // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">            t = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将sum变为原sum的个位数</span></span><br><span class="line">        sum = sum % (t * <span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 创建新节点</span></span><br><span class="line">        c3 = ListNode(sum)</span><br><span class="line">        <span class="comment"># 递归创建新节点的下面的节点</span></span><br><span class="line">        c3.next = self.recurse_addTwoNumbers(c1, c2, extra)</span><br><span class="line">        <span class="keyword">return</span> c3</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-198. 打家劫舍</title>
    <url>/2019/12/21/leetcode-198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一种很棒的方法，在做动态规划之前先考虑递归，比如说我这个递归函数的作用就是获得从第start个房子开始偷的最大值，那么在函数体中，一定是要么偷这个房子，要么不偷这个房子，那如果偷这个第start个房子的话，那么之后就是dfs(start+2)+nums[i]这么走，如果不偷这个第start个房子呢，那一定是dfs(start+1)这么走。返回一个最大值就好了。</li>
<li>递归完了之后，就知道状态转移怎么写了，我们知道对于每个start，他有两种选择，一种是选择dfs(start+2)+nums[start]，或者是选择dfs(start+1)，那么就可以推算出来，对于每个 dp[i]的值，一定是从dp[i-2]+nums[i]，或者是dp[i-1]里面选一个大的。所以状态转移方程就是dp[i]=max(dp[i+2]+nums[i],dp[i+1])。所以我们队dp数组进行倒序赋值。</li>
<li>然后又发现每次递归的时候其实都是看的是临近的几个状态，所以临近的几个状态不用一个数组，用几个变量互相更迭就可以了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归-没有剪枝，超时"><a href="#递归-没有剪枝，超时" class="headerlink" title="递归(没有剪枝，超时)"></a>递归(没有剪枝，超时)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//返回从第start个房子开始偷的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于这个房子有两种选择，要么偷，要么不偷</span></span><br><span class="line">        <span class="comment">//前者是偷这个第start房子，后者是不偷这第start个房子</span></span><br><span class="line">        <span class="keyword">return</span> max(dfs(nums, start + <span class="number">2</span>) + nums[start], dfs(nums, start + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="使用标记数组进行剪枝"><a href="#使用标记数组进行剪枝" class="headerlink" title="使用标记数组进行剪枝"></a>使用标记数组进行剪枝</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">//标记数组剪枝</span></span><br><span class="line">        <span class="keyword">int</span> book[<span class="number">20000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(book, <span class="number">-1</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> *book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明走过</span></span><br><span class="line">        <span class="keyword">if</span> (book[start] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> book[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = max(dfs(nums, start + <span class="number">2</span>, book) + nums[start], dfs(nums, start + <span class="number">1</span>, book));</span><br><span class="line">        book[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="模仿递归，倒序动态规划"><a href="#模仿递归，倒序动态规划" class="headerlink" title="模仿递归，倒序动态规划"></a>模仿递归，倒序动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">20000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">//可以发现这里和递归的规则一模一样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i] = max(dp[i + <span class="number">2</span>] + nums[i], dp[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="消除一个dp空间"><a href="#消除一个dp空间" class="headerlink" title="消除一个dp空间"></a>消除一个dp空间</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把a[i]和a[i+1]和a[i+2]缩减到3个变量</span></span><br><span class="line">        <span class="comment">//v1是a[i+1]</span></span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//v2是a[i+2]</span></span><br><span class="line">        <span class="keyword">int</span> v2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//res是a[n]</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> t1 = v1;</span><br><span class="line">            <span class="keyword">int</span> t2 = v2;</span><br><span class="line">            res = max(t1, t2 + nums[i]);</span><br><span class="line">            v2 = v1;</span><br><span class="line">            v1 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>做动态规划，考虑状态之后，递归，然后可以递归加标记数组进行剪枝，也可以直接根据递归的规律写和递归一样的顺序的动态规划，然后考虑能不能对动态规划进行空间优化</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-206. 反转链表</title>
    <url>/2019/10/18/leetcode-206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反转一个单链表。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">迭代的方法：修改每个节点的next域指向其上一个节点就实现了反转链表，也就是说具体在</span><br><span class="line">遍历每一个节点的时候，先用temp记录节点cur的下一个节点，修改cur的next域为pre，</span><br><span class="line">更新pre所指向的位置，然后再将cur更新为temp，因为要遍历全部的节点。</span><br><span class="line"></span><br><span class="line">其实迭代的方法还可以看成遍历旧链表然后头插法建造一个新链表。这样就很明了了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">递归解法呢：</span><br><span class="line">看了https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/bu-bu-chai-jie-ru-he-di-gui-di-fan-zhuan-lian-biao/这位</span><br><span class="line">大佬的牛皮解法之后，了解了递归的两个处理点，一个是第一次递归，一个是最后一次递归(递归终止点)，递归</span><br><span class="line">终止的时候不用说，至于第一次递归的时候呢，在第一次递归中再次调用方法的时候就可以看作方法已经实现，</span><br><span class="line">(所以说递归的定义一定要特别清晰，而且要特别明确的把问题逐渐缩小到越来越小的问题规模)</span><br><span class="line"></span><br><span class="line">因为大佬的写法已经很明了了，所以直接看大佬的题解就行</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># pre记录每个节点的上一个节点</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># cur是遍历的每一个节点</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 遍历每一个节点</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 先记录每一个节点的下一个节点的位置，因为后面要将节点指向节点的上一个节点</span></span><br><span class="line">            temp = cur.next</span><br><span class="line">            <span class="comment"># 将节点指向上一个节点</span></span><br><span class="line">            cur.next = pre</span><br><span class="line">            <span class="comment"># 更新pre的位置</span></span><br><span class="line">            pre = cur</span><br><span class="line">            <span class="comment"># 更新cur的位置，使正常循环</span></span><br><span class="line">            cur = temp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时pre指向的是原链表的最后一个位置，也就是反转过后的新链表的头指针</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 若空链表不存在反转</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 通过递归来获得反转链表</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_reverseList(head)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归函数的作用是返回反转之后的传入的链表的头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="comment"># 递归终止条件，若一个链表只有一个元素，那么就返回自己就行了</span></span><br><span class="line">        <span class="keyword">if</span> head.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里拿到从当前链表节点的下一个节点以及以后节点组成的链表的反转之后的链表的头节点</span></span><br><span class="line">        list = self.recurse_reverseList(head.next)</span><br><span class="line">        <span class="comment"># 将当前节点连接起来</span></span><br><span class="line">        head.next.next = head</span><br><span class="line">        <span class="comment"># 当前节点的指针域清空</span></span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 返回反转的链表</span></span><br><span class="line">        <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure>

<h2 id="c-迭代"><a href="#c-迭代" class="headerlink" title="c++迭代"></a>c++迭代</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明一个指针，</span></span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode *temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递归：</span><br><span class="line">将问题化简为同类型问题的更小规模</span><br><span class="line">处理两个极端，第一次递归，最后一次递归</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-21. 合并两个有序链表</title>
    <url>/2019/11/25/leetcode-21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>感觉递归要方便多了，，用回溯倒是不会写了😀。</li>
<li>递归每次创建c1，c2两个链表的有序链表，其中递归终止条件是当c1、c2都是空的话，递归完毕，如果有一个为空，说明有一个链表已经遍历完了，就不用再递归了。当两个都不是空的时候，放值小的就行(因为题目要求从小到大创建有序链表)</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_mergeTwoLists(l1, l2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_mergeTwoLists</span><span class="params">(self, c1: ListNode, c2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 两个链表都遍历完毕的情况</span></span><br><span class="line">        <span class="keyword">if</span> c1 == <span class="literal">None</span> <span class="keyword">and</span> c2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当有一个链表遍历完毕的时候</span></span><br><span class="line">        <span class="keyword">if</span> c1 != <span class="literal">None</span> <span class="keyword">and</span> c2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> c1</span><br><span class="line">        <span class="keyword">if</span> c1 == <span class="literal">None</span> <span class="keyword">and</span> c2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> c2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 直接创建新的节点</span></span><br><span class="line">        c3 = ListNode(min(c1.val, c2.val))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 因为继续往后遍历</span></span><br><span class="line">        <span class="keyword">if</span> c1.val &lt;= c2.val:</span><br><span class="line">            <span class="comment"># 注意这里传入的形参，谁变化了就传入谁</span></span><br><span class="line">            c3.next = self.recurse_mergeTwoLists(c1.next, c2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c3.next = self.recurse_mergeTwoLists(c1, c2.next)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c3</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>递归一发AC还是舒服鸭</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-211. 添加与搜索单词 - 数据结构设计</title>
    <url>/2019/09/02/leetcode-211.%20%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line"></span><br><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br><span class="line">search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以假设所有单词都是由小写字母 a-z 组成的。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>增添字符串和普通的字典树的建树没什么区别</li>
<li>普通查询操作也是没什么区别</li>
<li>重点是简单的正则表达式查询，因为’.’可以代表任意一个字符，所以可以看成当是’.’的时候就都匹配，也就是在遍历节点时遇到了’.’字符的话，就遍历当前节点的所有子树，然后遍历到子树的过程的时候，遍历的操作也是一样的，所以用递归写比较好</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> TreeMap&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(cur.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">                cur.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match(root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Node node, String word, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == word.length())</span><br><span class="line">            <span class="keyword">return</span> node.isWord;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若当前节点不是.的话，就和原来的查询没什么区别</span></span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> match(node.next.get(c), word, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是.，那么操作就成为遍历该节点的所有子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//            for(char nextChar: node.next.keySet())</span></span><br><span class="line"><span class="comment">//                if(match(node.next.get(nextChar), word, index + 1))</span></span><br><span class="line"><span class="comment">//                    return true;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//拿到子树的集合</span></span><br><span class="line">            Set&lt;Character&gt; characters = node.next.keySet();</span><br><span class="line">            Iterator&lt;Character&gt; it = characters.iterator();</span><br><span class="line">            <span class="comment">//遍历所有的子树</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                Character nextChar = it.next();</span><br><span class="line">                <span class="keyword">if</span>(match(node.next.get(nextChar), word, index + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>这道题不知道为什么用增强for就会超时，普通for就没事</li>
<li>这里有必要提及的一点是，在遇到.的时候要遍历当前cur节点的所有子树，而且最后的结果里面，只要有一个cur的子树返回时true，就返回true，全都是false的时候就返回false。这里一个很巧妙的地方就是在for里面用一个if。</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-208. 实现 Trie (前缀树)</title>
    <url>/2019/08/23/leetcode-208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 true</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以假设所有的输入都是由小写字母 a-z 构成的。</span><br><span class="line">保证所有输入均为非空字符串。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>说白了就是实现字典树的三个操作<ol>
<li>字符串的增添</li>
<li>字符串的查询(是否存在于字典树中)</li>
<li>查询字典树中是否存在有某个字符串为前缀的字符串</li>
</ol>
</li>
<li>这种只需要在节点中设立两个参数就行<ol>
<li>isWord，表示从根节点开始到此节点是否已经是一个字符串的布尔类型值</li>
<li>Map&lt;Character,Node&gt;，一个map存储字符和字符对应的位置</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//isWord表示从根节点到前节点是否构成一个字符串</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">        <span class="comment">//代替了长度为26的数组，用map会更方便</span></span><br><span class="line">        <span class="keyword">public</span> TreeMap&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next.put(c,<span class="keyword">new</span> Node());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur.isWord)&#123;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询字典树中是否有某个字符串以prefix为前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>字典树节点中的isWord可以标记根节点到当前节点中是否是一个字符串</li>
<li>Map&lt;Character,Node&gt;可以更方便的存储每个节点的子节点</li>
<li>每次字典树开头的时候都需要从根节点root开始，所以拿cur节点赋初值为root来使用</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-213. 打家劫舍 II</title>
    <url>/2020/03/24/leetcode-213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现</span><br><span class="line">金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房</span><br><span class="line">屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相</span><br><span class="line">邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装</span><br><span class="line">置的情况下，能够偷窃到的最高金额。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>和打家劫舍的做法几乎一样，可以这么想，既然已经成环状了，那么第一个和最后一个房子一定有不能同时选，所以就从第一个房子到倒数第二个房子跑一次，从第二个房子到最后一个房子跑一遍，选出一个最大值就好了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>因为打家劫舍的所有做法都做过了，所以这里直接用状态转移</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个房子和第一个房子不能同时选择，所以跑两次就好了</span></span><br><span class="line">        <span class="keyword">return</span> max(massage(nums, <span class="number">0</span>, nums.size() - <span class="number">2</span>), massage(nums, <span class="number">1</span>, nums.size() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> v2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> t1 = v1;</span><br><span class="line">            <span class="keyword">int</span> t2 = v2;</span><br><span class="line">            res = max(t1, t2 + nums[i]);</span><br><span class="line">            v2 = v1;</span><br><span class="line">            v1 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-217.存在重复元素</title>
    <url>/2019/07/30/leetcode-217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组，判断是否存在重复元素。</span><br><span class="line"></span><br><span class="line">如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>##示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>一看就有很多做法，但是桶排序没有做，因为不知道数据范围</li>
<li>然后有一个排序的做法，排序后，用一个数t保存上一个数，看当前这个数和上一个数一不一样，不一样的话就更新t，一样的话直接返回true就OK</li>
<li>也能用哈希表存，存的时候看有没有，有的话就返回结果</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用t保存上一个数</span></span><br><span class="line">        <span class="keyword">int</span> t = a[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]==t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当前数和上一个数不同之后就保存的上一个数，让其保存当前这个数</span></span><br><span class="line">                t = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存的时候判断有没有，有的话就返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有的话就存进去</span></span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-258. 各位相加</title>
    <url>/2020/02/11/leetcode-258.%20%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 38</span><br><span class="line">输出: 2 </span><br><span class="line">解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>写一个函数用来计算一个数的个位数相加就好了，直到这个数小于10。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = f(num);</span><br><span class="line">        <span class="keyword">while</span> (t &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            t = f(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到num的个位数的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/add-digits/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-digits/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-22. 括号生成</title>
    <url>/2019/11/12/leetcode-22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给出 n = 3，生成结果为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">明显找符合可以完全匹配的括号的全排列，经过分析过后呢，给一个从空开始的字符串往后添加&quot;(&quot;或者&quot;)&quot;来进行递归，</span><br><span class="line">通过找到特殊的条件来判断能否添加&quot;(&quot;或者&quot;)&quot;来产生特定的字符串。</span><br><span class="line"></span><br><span class="line">那么怎么找到这两个条件？</span><br><span class="line">先看添加&quot;(&quot;的条件，可以发现，在每次递归的s在不失效的情况下，是可以一直往后添加&quot;(&quot;的，那么要添加&quot;(&quot;只需要</span><br><span class="line">当前可使用的&quot;(&quot;数量大于0就可以</span><br><span class="line">再看添加&quot;)&quot;的条件，在每次递归的s在不失效的情况下，如果要添加&quot;)&quot;还不失效的话，那么这时候用过的&quot;(&quot;的数量</span><br><span class="line">一定是要比用过的&quot;)&quot;要多的，所以可以想到那么当前能用的&quot;(&quot;的数量要小于&quot;)&quot;的数量。</span><br><span class="line"></span><br><span class="line">所以这里每次递归需要4个参数，&quot;(&quot;当前可用的数量，&quot;)&quot;当前可用的数量，当前产生的字符串s，存储结果s的集合res。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.cur_generateParenthesis(n, n, res, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># l表示当前递归中可使用的"("的数量，r表")"的数量，s表示当前递归到字符串，res表结果集合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cur_generateParenthesis</span><span class="params">(self, l: int, r: int, res: list, s: str)</span>:</span></span><br><span class="line">        <span class="comment"># 当"("和")"用完之后，自然就产生了可以全匹配的s</span></span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">and</span> r == <span class="number">0</span>:</span><br><span class="line">            res.append(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要给s添加")"，必须保证当前s中的"("的数量大于s中的")"的数量</span></span><br><span class="line">        <span class="keyword">if</span> l &lt; r:</span><br><span class="line">            self.cur_generateParenthesis(l, r - <span class="number">1</span>, res, s + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要给s添加"("，只要保证有"("就可以了</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; <span class="number">0</span>:</span><br><span class="line">            self.cur_generateParenthesis(l - <span class="number">1</span>, r, res, s + <span class="string">'('</span>)</span><br></pre></td></tr></table></figure>

<h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><p>广度遍历的写法就和递归差不多了，就不解释了</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, l, r, s)</span>:</span></span><br><span class="line">        self.l = l</span><br><span class="line">        self.r = r</span><br><span class="line">        self.s = s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        q = deque()</span><br><span class="line">        q.append(node(n, n, <span class="string">''</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(q) != <span class="number">0</span>:</span><br><span class="line">            temp = q.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> temp.l == <span class="number">0</span> <span class="keyword">and</span> temp.r == <span class="number">0</span>:</span><br><span class="line">                res.append(temp.s)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> temp.l &lt; temp.r:</span><br><span class="line">                q.append(node(temp.l, temp.r - <span class="number">1</span>, temp.s + <span class="string">')'</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> temp.l &gt; <span class="number">0</span>:</span><br><span class="line">                q.append(node(temp.l - <span class="number">1</span>, temp.r, temp.s + <span class="string">'('</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="给指定位置放左括号或者右括号"><a href="#给指定位置放左括号或者右括号" class="headerlink" title="给指定位置放左括号或者右括号"></a>给指定位置放左括号或者右括号</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left_number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_number = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, left_number, right_number, n, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给index位置上放左括号或者有括号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> left_number, <span class="keyword">int</span> right_number, <span class="keyword">int</span> n, <span class="built_in">string</span> temp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果有括号数目大于左括号，就无效了</span></span><br><span class="line">        <span class="keyword">if</span> (right_number &gt; left_number)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == n * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放左括号的条件是左括号不超过n个</span></span><br><span class="line">        <span class="keyword">if</span> (left_number &lt; n) &#123;</span><br><span class="line">            dfs(index + <span class="number">1</span>, left_number + <span class="number">1</span>, right_number, n, temp + <span class="string">'('</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放有括号没哟条件，因为不符合递归条件的都会在递归的时候被终止</span></span><br><span class="line">        dfs(index + <span class="number">1</span>, left_number, right_number + <span class="number">1</span>, n, temp + <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">知道原理之后写出递归就不困难了，但是怎么发现规律是难事</span><br><span class="line">对于全排列，可以使用外部的变量代表某些元素有或没有使用来进行全排列是一个很好的方法。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-257. 二叉树的所有路径</title>
    <url>/2019/10/08/leetcode-257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，返回所有从根节点到叶子节点的路径。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>带点搜索性质的递归啦，当节点是叶子节点的时候就表明是一条路径了。然后把这个路径放到结果的list中。没啥好说的，看代码</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        self.recurse_binaryTreePaths(root, s, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_binaryTreePaths</span><span class="params">(self, cur: TreeNode, s: str, res: list)</span>:</span></span><br><span class="line">        <span class="comment"># 如果是叶子节点就直接表明已经走到一条路径了</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            s = s + str(cur.val)</span><br><span class="line">            <span class="comment"># 添加路径到结果集中</span></span><br><span class="line">            res.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 增加到cur节点的这个路径</span></span><br><span class="line">        s = s + str(cur.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 往左子树中寻找路径</span></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            self.recurse_binaryTreePaths(cur.left, s+<span class="string">'-&gt;'</span>, res)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 往右子树中寻找路径</span></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            self.recurse_binaryTreePaths(cur.right, s+<span class="string">'-&gt;'</span>, res)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-paths/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-26. 删除排序数组中的重复项</title>
    <url>/2019/08/01/leetcode-26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，</span><br><span class="line">使得每个元素只出现一次，返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>怎么感觉以前写过的样子,直接在原数组上进行修改，既然已经是有序的了，每次遍历到a[i]的时候都保留上一个数，即a[i-1]，比较a[i]与a[i-1]，一样的话就跳过，不一样的就保留在新的数组长度对应的索引上。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//一样就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]==temp)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不一样就直接保存在新数组上</span></span><br><span class="line">                a[cnt] = a[i];</span><br><span class="line">                temp = a[i];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-268.缺失数字</title>
    <url>/2019/07/29/leetcode-268.%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>说白了就是给你一个长度是n的数组，然后里面是0~n少一个，让你求出少了哪个</li>
<li>一开始想的是用一个标技数组来记录谁出现和谁没有出现，出现的话值为1，没出现的话值为0。然后遍历数组记录值为0的索引位置。</li>
<li>后来想如果可以排序的话，排序之后看那个索引上的值和索引不同就记录哪个数，注意这种做法有一种特殊情况，就是如果缺失的是最后一位的话，这样的判别不出来的，所以要加特判</li>
<li>还能用set</li>
<li>也能排序完之后用位运算，同样要判断只缺末尾的情况</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="标记数组"><a href="#标记数组" class="headerlink" title="标记数组"></a>标记数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[a.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记数组记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            book[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//遍历标记数组看谁值为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; book.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (book[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回值为0的索引值，即缺失的数字</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//特殊情况特判，如果是最后一位缺失的话就直接返回最后一位</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//若当前索引和索引位置上的值不相同就记录这个索引</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] != i)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若flag是false，那么就说明缺失的是最后一位，因为没有被记录的索引，自然缺失的是最后一位</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//都放到set里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从0到n一个一个在set里面找，看没有谁就记住谁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i))&#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//缺失末尾的特判</span></span><br><span class="line">        <span class="keyword">if</span> (a[a.length-<span class="number">1</span>] == a.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i^i = 0，也就是索引和索引上的值进行位运算，不是0的记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[i]^i;</span><br><span class="line">            <span class="keyword">if</span> (t!=<span class="number">0</span>)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/missing-number/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-279. 完全平方数</title>
    <url>/2020/02/17/leetcode-279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）</span><br><span class="line">使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n = 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n = 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 = 4 + 9.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>可以进行bfs，每次把从队列里面弹出来的数进行减平方和(1,4,9)，并且把减的结果放到队列里，这里注意减的过程中如果产生了负数，是不放到队列里面了。并且遇到过的差也放到队列，这其实是相当于剪枝了，因为当前数之前已经遇到过的话，就说明当前这个数不是最短路径，因为之前遇到过的数要么在这个数的左面，要么在左上面，一定都是走过的路径。如果差为0，那么此时bfs的层数就是最后的结果。<br><img src="/image/leetcode279.png" alt></li>
</ol>
<p><a href="https://leetcode-cn.com/problems/perfect-squares/solution/dong-tai-gui-hua-bfs-zhu-xing-jie-shi-python3-by-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares/solution/dong-tai-gui-hua-bfs-zhu-xing-jie-shi-python3-by-2/</a></p>
<p>题解链接</p>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] book = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        q.add(n);</span><br><span class="line">        <span class="comment">//对n进行bfs向下走</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.size();</span><br><span class="line">            <span class="comment">//层数++</span></span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                <span class="comment">//对于队首元素进行向下拆解</span></span><br><span class="line">                Integer remove = q.remove();</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j * j &lt;= remove) &#123;</span><br><span class="line">                    <span class="comment">//把差放到队列里面</span></span><br><span class="line">                    <span class="keyword">int</span> temp = remove - j * j;</span><br><span class="line">                    <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//差不是0并且还没有出现过，就放入队列</span></span><br><span class="line">                        <span class="keyword">if</span> (!book[temp]) &#123;</span><br><span class="line">                            q.add(temp);</span><br><span class="line">                            book[temp] = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果差为0就找到了最短路径</span></span><br><span class="line">                        <span class="keyword">return</span> ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>从开始状态到另一种状态，其中的过程有好几种方式都可以用bfs写</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-278. 第一个错误的版本</title>
    <url>/2020/02/08/leetcode-278.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品</span><br><span class="line">的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，</span><br><span class="line">所以错误的版本之后的所有版本都是错的。</span><br><span class="line"></span><br><span class="line">假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。</span><br><span class="line"></span><br><span class="line">你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version </span><br><span class="line">是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显是二分题，只需要寻找到某个元素，这个元素i符合一个特征，i不是错误的版本，但是i+1是错误的版本。由于数据是从头到尾部的排布是，都不是错误的然后一直到全是错误的，其实某种意义上来可以看成有序的，然后当二分确定好值的时候，就说明f(i)==false，并且f(i+1)==true，如果f(i)==false &amp;&amp; f(i+1)==false,就说明在左面，要去右面寻找，如果f(i)==true &amp;&amp; f(i+1)==true，就说明在右面，应该去左面寻找。如此二分就行了。</li>
<li>值得注意的是，这道题需要注意好二分的边界条件，因为api不是自己的，如果遇到1~n以外范围的数的时候，这时候的api的返回值是玄学，所以这里处理好两个端点就行了。 </li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//当前不是，并且下一个是，就是正确答案了</span></span><br><span class="line">            <span class="keyword">if</span> (!isBadVersion(mid) &amp;&amp; isBadVersion(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//两个端点，如果第一个错误的版本在第一个的话</span></span><br><span class="line">            <span class="comment">//或者在最后一个的话，特判一下</span></span><br><span class="line">            <span class="keyword">if</span>(mid==n &amp;&amp; isBadVersion(n)==<span class="keyword">true</span>  || mid==<span class="number">1</span> &amp;&amp; isBadVersion(<span class="number">1</span>)==<span class="keyword">true</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//左移</span></span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid) &amp;&amp; isBadVersion(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右移</span></span><br><span class="line">            <span class="keyword">if</span> (!isBadVersion(mid) &amp;&amp; !isBadVersion(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li><p>二分有时候有必要对边界进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分的板子</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] == target) &#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; a[mid]) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; a[mid]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回target在a数组里面的索引，如果target在a数组里面不存在</span></span><br><span class="line">        <span class="comment">//就返回-1</span></span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用心分析二分的板子可以发现，二分其实是分析可以分析到每一个数的。只不过因为二分的性质一次省略一般的数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            1~7</span><br><span class="line">        1~3      5~7         首先分析到4</span><br><span class="line">    1~1   3~3  5~5  7~7       这一行分析到了2 和 6</span><br><span class="line">    1     3    5    7          这一行分析到了1，3，5，7</span><br><span class="line"></span><br><span class="line">从中可以发现按照这个板子可以得到所有数分析的情况</span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/first-bad-version/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version/submissions/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-27.移除元素</title>
    <url>/2019/07/28/leetcode-27.%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么返回数值是整数，但输出的答案是数组呢?</span><br><span class="line"></span><br><span class="line">请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br><span class="line"></span><br><span class="line">你可以想象内部操作如下:</span><br><span class="line"></span><br><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>说白了就是以O(1)的空间复杂度把一个数组中的指定value的值删除，然后返回删除后的数组长度，其实可以看成把指定value的元素都移到后面，然后返回新数组长度就OK。</li>
<li>还有一种删除的做法很神奇，从头遍历数组，如果发现当前遍历到的元素不是val，那就把这个值放到原位，如果是val那就跳过，这个位置的值交给下个元素。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="双指针移动"><a href="#双指针移动" class="headerlink" title="双指针移动"></a>双指针移动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//i找val</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//j找非val</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先统计有多少个val</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k==val)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i&lt;a.length &amp;&amp; j&lt;a.length)&#123;</span><br><span class="line">            <span class="comment">//i找val，那么自然不是val的就不看</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] != val)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//j找非val，那么自然是val的就不看</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] == val)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//因为val要往后移，如果val本身就在后面那就不用移动，如果val在前面就得移动</span></span><br><span class="line">            <span class="keyword">if</span> (i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.length-sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="神奇做法"><a href="#神奇做法" class="headerlink" title="神奇做法"></a>神奇做法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cnt是新数组(新数组的元素都在元数组的位置上)的长度</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//新数组只保留非val的元素</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]!=val)&#123;</span><br><span class="line">                a[cnt] = a[i];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>删除数组中所有的value有个很神奇的做法</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-element/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-108. 将有序数组转换为二叉搜索树</title>
    <url>/2019/10/08/leetcode-226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">翻转一棵二叉树。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个问题是受到 Max Howell 的 原问题 启发的 ：</span><br><span class="line"></span><br><span class="line">谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>两种做法，都是递归实现</li>
<li>第一种方法，在递归每个节点的时候进行判断，如果节点是叶子节点，就返回，如果不是叶子节点，就交换左右子树的引用值。</li>
<li>第二种方法：构造一颗新树，每次递归题目给的树的节点的时候，把旧树上的节点的左右子树构造到新树对应上的节点上。当旧树递归遍历完之后，新树也就造好了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="直接交换左右子树的引用值"><a href="#直接交换左右子树的引用值" class="headerlink" title="直接交换左右子树的引用值"></a>直接交换左右子树的引用值</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        self.recurse_invertTree(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_invertTree</span><span class="params">(self, cur: TreeNode)</span>:</span></span><br><span class="line">        <span class="comment"># 当递归到叶子节点的时候，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果不是叶子节点，直接交换左右子树的引用值</span></span><br><span class="line">        t = cur.left</span><br><span class="line">        cur.left = cur.right</span><br><span class="line">        cur.right = t</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 继续左右递归</span></span><br><span class="line">        <span class="keyword">if</span> cur.left!=<span class="literal">None</span>:</span><br><span class="line">            self.recurse_invertTree(cur.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cur.right !=<span class="literal">None</span>:</span><br><span class="line">            self.recurse_invertTree(cur.right)</span><br></pre></td></tr></table></figure>

<h2 id="造新树"><a href="#造新树" class="headerlink" title="造新树"></a>造新树</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public void Mirror(TreeNode root) &#123;</span><br><span class="line">        TreeNode root2 = null;</span><br><span class="line">        root = f(root, root2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TreeNode f(TreeNode cur1, TreeNode cur2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur1 == null)</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">        cur2 = new TreeNode(cur1.val);</span><br><span class="line">        <span class="keyword">if</span> (cur1.left != null)</span><br><span class="line">            cur2.right = f(cur1.left, cur2.right);</span><br><span class="line">        <span class="keyword">if</span> (cur1.right != null)</span><br><span class="line">            cur2.left = f(cur1.right, cur2.left);</span><br><span class="line">        <span class="keyword">return</span> cur2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>在这道题上我战胜了 Max Howell 😄</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-28. 实现 strStr()</title>
    <url>/2019/09/17/leetcode-28.%20%E5%AE%9E%E7%8E%B0%20strStr()/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现 strStr() 函数。</span><br><span class="line"></span><br><span class="line">给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。</span><br><span class="line">如果不存在，则返回  -1。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</span><br><span class="line"></span><br><span class="line">对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>很常规的一道题，可以直接调用API、也可以用暴力O(m*n)的复杂度、也可以用KMP</li>
<li>API的做法就不解释了，处理好不存在的异常就行了</li>
<li>暴力就是遍历每一个i，对于每一个i都当做子串在主串中的开头，而且进行一次主串和子串的匹配</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="内置API"><a href="#内置API" class="headerlink" title="内置API"></a>内置API</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">-111</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里因为语法的关系，python3中在主串中找子串的时候，如果找不到会抛出异常ValueError</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = haystack.index(needle)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            res = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, a: str, b: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        la = len(a)</span><br><span class="line">        lb = len(b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> lb == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历主串中合适索引位置的所有主串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, la - lb + <span class="number">1</span>):</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对于每一个i都当做子串在主串中的开头，而且进行一次主串和子串的匹配</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, lb):</span><br><span class="line">                <span class="keyword">if</span> a[i + j] != b[j]:</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="比较python写法的暴力代码，十分简洁，原理同暴力"><a href="#比较python写法的暴力代码，十分简洁，原理同暴力" class="headerlink" title="比较python写法的暴力代码，十分简洁，原理同暴力"></a>比较python写法的暴力代码，十分简洁，原理同暴力</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">-1</span></span><br><span class="line">        la = len(haystack)</span><br><span class="line">        lb = len(needle)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, la - lb + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 直接切片来比较，比原来的要简洁的多</span></span><br><span class="line">            <span class="keyword">if</span> haystack[i:i + lb] == needle:</span><br><span class="line">                res = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    __next = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(self, p: str)</span>:</span></span><br><span class="line">        self.__next.append(<span class="number">-1</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(p):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">-1</span> <span class="keyword">or</span> p[i] == p[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i == len(p):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                self.__next.append(j)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = self.__next[j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kmp</span><span class="params">(self, t: str, p: str)</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(t) <span class="keyword">and</span> j &lt; len(p):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">-1</span> <span class="keyword">or</span> t[i] == p[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = self.__next[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j == len(p):</span><br><span class="line">            <span class="keyword">return</span> i - j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        self.get_next(needle)</span><br><span class="line">        res = self.kmp(haystack, needle)</span><br><span class="line">        <span class="comment"># 注意这里要清空next数组，leetcode上有毛病</span></span><br><span class="line">        self.__next.clear()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_next</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__next)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>python3中在主串中找子串的时候，如果找不到会抛出异常ValueError</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-283.移动零</title>
    <url>/2019/07/27/leetcode-283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">必须在原数组上操作，不能拷贝额外的数组。</span><br><span class="line">尽量减少操作次数。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>明显可以用双指针，i,j从头开始找非0元素和0，找到之后比较i,j的大小，当0在非0元素之前才能交换，也就是说i&gt;j的时候才能交换，不然就不换并且i继续找之后的非0元素，直到找到了在0之后的非0元素，然后交换</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找非0</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找0</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;a.length &amp;&amp; j&lt;a.length)&#123;</span><br><span class="line">            <span class="comment">//找非0元素，即跳过0元素</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找0，即跳过非0元素</span></span><br><span class="line">            <span class="keyword">if</span> (a[j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当0在前时交换</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;j)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//0在后面是不仅不交换而且还重新找非0元素</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>数组题很多都可以用双指针的</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-289. 生命游戏</title>
    <url>/2020/04/02/leetcode-289.%20%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</span><br><span class="line"></span><br><span class="line">给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</span><br><span class="line"></span><br><span class="line">如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</span><br><span class="line">如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</span><br><span class="line">如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</span><br><span class="line">如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</span><br><span class="line">根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>大致就是对二维数组里面的所有的数进行同时变化，这个变化的规则是需要每个格子周围的所有的不越界的格子来决定这个格子的变化的结果。</li>
<li>首先可以赋值一个新数组，然后根据原来的数组进行变化，将变化的结果产生到新数组里，达到变化和产生的分离。</li>
<li>或者可以省去一个二维数组的空间，因为这道题的变化是有特点的，因为1表示活，0表示死，而且对于每个格子的变换结果只需要记录某个格子周围有几个活的，那么问题就是如何对格子变化，使得这个格子的性质不变(也就是变化之后的格子对其他格子的影响不变)，我们可以先将格子的值变成另一个值(这个值的性质是正确的)，然后最后对于每个格子的值都进行一次变为最终结果的变化</li>
<li>比如这里的处理就是对于每个格子周围计数有几个活的，然后对于这个格子的值加几个10，比如这个格子是活的，周围有3个活的，那么这个格子的值就变成31。这个31虽说不是最后的结果，但是性质是对的，仍然保持了它是一个活的，而且还能让人知道他周围有3个活的。对于每个格子都这样变化完之后，就知道了每个格子的活的还是死的，并且也知道每个格子周围有几个活的。然后根据规则进行归类就行了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="开辟一个二维数组"><a href="#开辟一个二维数组" class="headerlink" title="开辟一个二维数组"></a>开辟一个二维数组</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">ans</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                ans[i][j] = f(board, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                board[i][j] = ans[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回坐标x，y最后应该变的值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//x，y周围8个格子1的个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> nx = x + i;</span><br><span class="line">                <span class="keyword">int</span> ny = y + j;</span><br><span class="line">                <span class="comment">//越界</span></span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[nx][ny] == <span class="number">1</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">2</span> || cnt == <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="利用规则，省去二维的额外的内存"><a href="#利用规则，省去二维的额外的内存" class="headerlink" title="利用规则，省去二维的额外的内存"></a>利用规则，省去二维的额外的内存</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//遍历所有的格子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">//遍历8个方向</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">-1</span>; k &lt;= <span class="number">1</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">-1</span>; l &lt;= <span class="number">1</span>; l++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; l == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="comment">//拿到8个方向的坐标</span></span><br><span class="line">                        <span class="keyword">int</span> nx = i + k;</span><br><span class="line">                        <span class="keyword">int</span> ny = j + l;</span><br><span class="line">                        <span class="comment">//越界</span></span><br><span class="line">                        <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="comment">//如果周围有1个活细胞，那就这个值就加10</span></span><br><span class="line">                        <span class="keyword">if</span> (board[nx][ny] % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                            board[i][j] += <span class="number">10</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">//活细胞</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//t是周围活细胞的个数</span></span><br><span class="line">                    <span class="keyword">int</span> t = board[i][j] / <span class="number">10</span>;</span><br><span class="line">                    <span class="comment">//知道活细胞的个数然后根据规则判断就行了</span></span><br><span class="line">                    <span class="keyword">if</span> (t &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        board[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span> || t == <span class="number">3</span>) &#123;</span><br><span class="line">                        board[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                        board[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        board[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//死细胞</span></span><br><span class="line">                    <span class="keyword">int</span> t = board[i][j] / <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="number">3</span>) &#123;</span><br><span class="line">                        board[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        board[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>可以利用复合性质，省去额外的内存空间。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/game-of-life/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-292. Nim 游戏</title>
    <url>/2019/11/28/leetcode-292.%20Nim%20%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 </span><br><span class="line">拿掉最后一块石头的人就是获胜者。你作为先手。</span><br><span class="line">你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: false </span><br><span class="line">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="line">因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>根据题解分析得到，如果n==4，然后你先手，你必输，因为每个人都能拿1~3个石头，然后就有一个结论，当n==4的时候，谁先手谁输，那么5,6,7的情况的话，就可以营造一个n==4的情况，比如说到我这个时候了，剩6个，我拿两个，剩四个，而且到你了，你比输。那么既然5，6，7我先手一定是我赢，那么8如果我先手一定是我输，因为如果我是8，就能给你营造出5，6，7的情况，刚才也说了，5，6，7必赢，自然就可以推断谁拿到4的倍数谁就输。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">4</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nim-game/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-88.合并两个有序数组</title>
    <url>/2019/10/27/leetcode-3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一开始想的是暴力，首先一个二重循环找到所有可能的字符串，对于每一个字符串在遇到新的字符的时候都需要判断，如果是当前字符串已经包</span><br><span class="line">括新的字符的话，就重新开始记录字符串，如果遇到的新字符字符串中没有的话，就把这个字符添加到字符串中，然后判断新字符串的长度和最</span><br><span class="line">大的字符串长度谁大，大的话就更新</span><br><span class="line"></span><br><span class="line">自然暴力一定超时，这里用一种滑动窗口的姿势，用窗口来寻找最大的字符串，用窗口暂时保存字符串，每次遍历到新的字符的时候，如果窗口</span><br><span class="line">中不存在该字符的时候，窗口右边界右移，同时记录最大的题目要求的子串长度，如果存在的话，就从窗体中从左切割到该字符的位置，然后</span><br><span class="line">让切割后的窗体包括下新字符。以此遍历全部的字符串，一定可以找到最大的子串长度。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># max记录最大长度</span></span><br><span class="line">    max = <span class="number">-100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 空串直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历所有字符串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            <span class="comment"># 用list记录每次产生的字符串</span></span><br><span class="line">            list = []</span><br><span class="line">            list.append(s[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 枚举新的字符</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(s)):</span><br><span class="line">                <span class="comment"># 如果碰到新的字符在list中有的话，那就说明重复了</span></span><br><span class="line">                <span class="keyword">if</span> s[j] <span class="keyword">in</span> list:</span><br><span class="line">                    <span class="comment"># 重复的话重新枚举字符串</span></span><br><span class="line">                    list.clear()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果不包括就继续扩充字符串</span></span><br><span class="line">                    list.append(s[j])</span><br><span class="line">                    <span class="comment"># 更新最大长度</span></span><br><span class="line">                    <span class="keyword">if</span> len(list) &gt; self.max:</span><br><span class="line">                        self.max = len(list)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里是为了避免字符串中全部的字符都一样的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> self.max == <span class="number">-100</span> <span class="keyword">else</span> self.max</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    max = <span class="number">-100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 窗体</span></span><br><span class="line">        list = []</span><br><span class="line">        <span class="comment"># 遍历全部的字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            <span class="comment"># 如果窗体中不存在该字符</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s[i] <span class="keyword">in</span> list:</span><br><span class="line">                <span class="comment"># 把字符加入到窗体中</span></span><br><span class="line">                list.append(s[i])</span><br><span class="line">                <span class="comment"># 记录最大子串长度</span></span><br><span class="line">                self.max = max(self.max, len(list))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果存在先把该字符放到窗体中</span></span><br><span class="line">                list.append(s[i])</span><br><span class="line">                <span class="comment"># 找到窗体中第一个该字符的位置</span></span><br><span class="line">                index = list.index(s[i])</span><br><span class="line">                <span class="comment"># 切割窗体</span></span><br><span class="line">                list = list[index+<span class="number">1</span>: i + <span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 再次寻找子串长度</span></span><br><span class="line">                self.max = max(self.max, len(list))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.max</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>字符串的题窗体似乎很常用</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-309. 最佳买卖股票时机含冷冻期</title>
    <url>/2020/07/08/leetcode-309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</span><br><span class="line"></span><br><span class="line">设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span><br><span class="line"></span><br><span class="line">你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题解，写的太好了<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/</a></li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="comment">// f[i][0]: 手上持有股票的最大收益</span></span><br><span class="line">        <span class="comment">// f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益</span></span><br><span class="line">        <span class="comment">// f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>))</span></span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            f[i][<span class="number">2</span>] = max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-300. 最长上升子序列</title>
    <url>/2019/11/06/leetcode-300.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个无序的整数数组，找到其中最长上升子序列的长度。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</span><br><span class="line">你算法的时间复杂度应该为 O(n2) 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>dp写法，最主要的还是找到状态转移方程。</li>
<li>大佬题解，写得很清楚：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/</a></li>
<li>注意这里dp[i]的值是以nums[i]为结尾的从头到nums[i]的最大子序列的长度。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, a: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(a)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a)):</span><br><span class="line">            dp.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 外重循环找所有子序列的结尾</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a)):</span><br><span class="line">            <span class="comment"># 内部循环找开头</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                <span class="comment"># 如果当前结尾的值大于当前j的值</span></span><br><span class="line">                <span class="keyword">if</span> a[i] &gt; a[j]:</span><br><span class="line">                    <span class="comment"># 再去看看是不是需要更新一下最大子序列的长度</span></span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>

<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dp) &#123;</span><br><span class="line">            res = Math.max(i, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>遍历所有子串的方法不仅有外重循环找开头，内容循环找结尾，也可以外重循环找结尾，内部循环找开头。</li>
<li>子串和子序列的区别：子串是必须是连续的，子序列可以是不连续的。</li>
<li>做dp的时候首先明确dp的含义，然后试图寻找方程。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-307. 区域和检索 - 数组可修改</title>
    <url>/2019/08/22/leetcode-307.%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</span><br><span class="line"></span><br><span class="line">update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [1, 3, 5]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 9</span><br><span class="line">update(1, 2)</span><br><span class="line">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组仅可以在 update 函数下进行修改。</span><br><span class="line">你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显的线段树，可以用数组实现或者链表实现</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是线段树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tree[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            data[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length*<span class="number">4</span>];</span><br><span class="line">        buildSegTree(<span class="number">0</span>,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            tree[treeIndex] = data[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightIndex = rightChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        buildSegTree(leftIndex,l,mid);</span><br><span class="line">        buildSegTree(rightIndex,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">        tree[treeIndex] = tree[leftIndex] + tree[rightIndex];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        data[index] = val;</span><br><span class="line"></span><br><span class="line">        update(<span class="number">0</span>,<span class="number">0</span>,data.length-<span class="number">1</span>, index, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r &amp;&amp; l == index)&#123;</span><br><span class="line">            tree[treeIndex] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightIndex = rightChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            update(rightIndex, mid + <span class="number">1</span>, r, index, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &lt;= mid)&#123;</span><br><span class="line">            update(leftIndex, l, mid, index, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tree[treeIndex] = tree[leftIndex] + tree[rightIndex];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, data.length-<span class="number">1</span>, queryL, queryR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == queryL &amp;&amp; r == queryR)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightIndex = rightChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queryL &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> query(rightIndex, mid+<span class="number">1</span>, r, queryL, queryR);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (queryR &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> query(leftIndex, l, mid, queryL, queryR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftResult = query(leftIndex, l, mid, queryL, mid);</span><br><span class="line">        <span class="keyword">int</span> rightResult = query(rightIndex, mid+<span class="number">1</span>, r, mid+<span class="number">1</span>, queryR);</span><br><span class="line">        <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*index + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Merger</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">merge</span><span class="params">(E a, E b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkArrSegTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="comment">//每个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</span><br><span class="line">        <span class="comment">//把一个节点的左右区间封装到节点内部中</span></span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        E value;</span><br><span class="line">        <span class="comment">//左右孩子也是</span></span><br><span class="line">        SegmentTreeNode leftChild;</span><br><span class="line">        SegmentTreeNode rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.l = l;</span><br><span class="line">            <span class="keyword">this</span>.r = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    Merger&lt;E&gt; merger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把nums数组按照merger操作造成一颗线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkArrSegTree</span><span class="params">(E[] nums,Merger&lt;E&gt; merger)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先把merger操作复制了</span></span><br><span class="line">        <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了类中的成员变量能访问到nums的内容，所以让data代替nums</span></span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            data[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从根节点开始建树</span></span><br><span class="line">        root = build(<span class="number">0</span>, data.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个区间范围是l~r的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SegmentTreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不管啥先创建一个新的节点</span></span><br><span class="line">        SegmentTreeNode node = <span class="keyword">new</span> SegmentTreeNode(l,r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果遍历到了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            node.value = data[l];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        node.leftChild = build(l, mid);</span><br><span class="line">        node.rightChild = build(mid + <span class="number">1</span>, r);</span><br><span class="line">        node.value = merger.merge(node.leftChild.value, node.rightChild.value);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询区间queryL到queryR的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要从根节点开始查找区间</span></span><br><span class="line">        <span class="keyword">return</span> query(root, queryL, queryR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次查询递归的函数,treeNode对应的区间已经封装在treeNode节点里面了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(SegmentTreeNode treeNode, <span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (treeNode.l == queryL &amp;&amp; treeNode.r == queryR)&#123;</span><br><span class="line">            <span class="keyword">return</span> treeNode.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = treeNode.l + (treeNode.r - treeNode.l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (queryL &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> query(treeNode.rightChild, queryL, queryR);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (queryR &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> query(treeNode.leftChild, queryL, queryR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        E leftResult = query(treeNode.leftChild, queryL, mid);</span><br><span class="line">        E rightResult = query(treeNode.rightChild, mid + <span class="number">1</span>, queryR);</span><br><span class="line">        <span class="keyword">return</span> merger.merge(leftResult,rightResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把index索引位置上的值更新为e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">        data[index] = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新线段树的某个点需要从树的根节点开始更新</span></span><br><span class="line">        update(root, index, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是真正用来递归的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(SegmentTreeNode treeNode, <span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (treeNode.l == index &amp;&amp; treeNode.r == index)&#123;</span><br><span class="line">            treeNode.value = e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = treeNode.l + (treeNode.r - treeNode.l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            update(treeNode.rightChild, index, e);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &lt;= mid)&#123;</span><br><span class="line">            update(treeNode.leftChild,index, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        treeNode.value = merger.merge(treeNode.leftChild.value, treeNode.rightChild.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkArrSegTree linkArrSegTree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Integer[] data = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            data[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        linkArrSegTree = <span class="keyword">new</span> LinkArrSegTree&lt;&gt;(data,((a, b) -&gt; a+b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        linkArrSegTree.update(i,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) linkArrSegTree.query(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>线段树的板子之前写过<a href="https://why0609why.github.io/2019/08/21/%E7%BA%BF%E6%AE%B5%E6%A0%91/" target="_blank" rel="noopener">https://why0609why.github.io/2019/08/21/%E7%BA%BF%E6%AE%B5%E6%A0%91/</a></li>
<li>用数组实现线段树的重要的一个点：每次递归中的l,r分别代表的是treeIndex所对应的区间，这个区间必须是这个节点的区间，必须符合对照，不能随意把l扩大或者把r缩小</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-query-mutable/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-315. 计算右侧小于当前元素的个数</title>
    <url>/2020/07/08/leetcode-315.%20%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums，按要求返回一个新数组 counts。</span><br><span class="line">数组 counts 有该性质： counts[i] 的值是  nums[i] </span><br><span class="line">右侧小于 nums[i] 的元素的数量。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/shou-hua-tu-jie-er-fen-cha-zhao-si-lu-by-hyj8/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/shou-hua-tu-jie-er-fen-cha-zhao-si-lu-by-hyj8/</a>  </li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countSmaller = (nums) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">const</span> counts = <span class="keyword">new</span> Array(len);</span><br><span class="line">  <span class="keyword">const</span> sorted = [];</span><br><span class="line">  <span class="keyword">for</span> (let i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = findIndex(sorted, nums[i]); <span class="comment">// 当前数字理应出现在右边排序后的位置，也即是有index个右边元素比它小</span></span><br><span class="line">    sorted.splice(index, <span class="number">0</span>, nums[i]); <span class="comment">// 将nums[i]插入到sorted数组的index处</span></span><br><span class="line">    counts[i] = index; <span class="comment">// 将index存到counts数组的索引i处</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> counts;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findIndex = (arr, target) =&gt; &#123;</span><br><span class="line">  let lo = <span class="number">0</span>;</span><br><span class="line">  let hi = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">// 目标值比中间元素大，mid不是想要的</span></span><br><span class="line">      lo = mid + <span class="number">1</span>;         <span class="comment">// 最后返回的是lo，逼到mid+1,</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 目标值小于等于中间元素 </span></span><br><span class="line">      hi = mid;             <span class="comment">// mid可能是想要的，hi不能mid-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[lo] &lt; target) <span class="keyword">return</span> lo + <span class="number">1</span>; <span class="comment">// target正好比lo元素大，lo还需+1</span></span><br><span class="line">  <span class="keyword">return</span> lo;    <span class="comment">// 否则 返回lo</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-32. 最长有效括号</title>
    <url>/2020/07/04/leetcode-32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个只包含 &apos;(&apos; 和 &apos;)&apos; 的字符串，找出最长的包含有效括号的子串的长度。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的遍历所有的子串，然后从子串里面验证有效括号，然后统计有效每个字串的长度。并且记录最大值。但是超时</li>
<li>后来看到题解的用栈，先用栈存一个-1，遇到’(‘，入栈这个’(‘的索引，当遇到’)’的时候，就出栈一次，然后用当前’)’的索引减去新的栈顶的索引，就能得到这个’)’对应的最大长度。而且当栈空的时候，就把’)’的坐标放到栈当第一个-1的指针用。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力遍历所有子串"><a href="#暴力遍历所有子串" class="headerlink" title="暴力遍历所有子串"></a>暴力遍历所有子串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="comment">//二重循环遍历所有子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//l是左括号个数</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//r是右括号个数</span></span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">'('</span>)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">')'</span>)</span><br><span class="line">                    r++;</span><br><span class="line">                <span class="comment">//只要r&gt;l就说明当前这个子串不是有效的，然后这个子串就</span></span><br><span class="line">                <span class="comment">//不看了</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt; l)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//拿到最大有效</span></span><br><span class="line">                <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                    ans = max(ans, l * <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//左括号入栈</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(i);</span><br><span class="line">            <span class="comment">//有括号出栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="comment">//记录这个有括号对应的有效长度</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">stack</span>.empty())</span><br><span class="line">                    ans = max(ans, i - <span class="built_in">stack</span>.top());</span><br><span class="line">                <span class="comment">//如果出栈后发现栈空，就入一个新的参照物</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">stack</span>.empty())</span><br><span class="line">                    <span class="built_in">stack</span>.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-35.搜索插入位置</title>
    <url>/2020/07/17/leetcode-35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。</span><br><span class="line">如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span><br><span class="line"></span><br><span class="line">你可以假设数组中无重复元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>大致意思就是有一个有序数组和一个目标值，在要求返回一个整形值，如果能在有序数组中找到目标值的话，就返回目标值的索引，如果找不到就返回一个目标值可以插入的位置，使得插入后的数组还是一个有序数组</li>
<li>可以先二分查找有没有这个数，没有的话再找出其可以插入的位置，但是这样有点没必要</li>
<li>仔细想想，在遍历到每个数字的时候，如果当前索引上的数等于target，那就直接返回索引，如果大于target当前索引上的数(之前说了没有重复元素)，那就也返回索引，自然可以得出如果当前索引上的数大于等于target的时候，就返回索引。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//由上面的分析得出的结果，当a[i]&gt;=target的时候就返回其索引</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]&gt;=target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当走到这里的时候就说明要插入的元素的位置在最后，也就是最后一个索引的后面，自然索引就是数组长度</span></span><br><span class="line">        <span class="keyword">return</span> a.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-337. 打家劫舍 III</title>
    <url>/2020/03/24/leetcode-337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地</span><br><span class="line">区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有</span><br><span class="line">且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方</span><br><span class="line">的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚</span><br><span class="line">上被打劫，房屋将自动报警。</span><br><span class="line"></span><br><span class="line">计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>和之前的做法一样，递归，然后做好剪枝就好了，这里用unordered_map&lt;TreeNode*,int&gt;，注意用unordered_map存储指针的时候是不用重写哈希函数的。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="树形dp反而要比常规dp简单"><a href="#树形dp反而要比常规dp简单" class="headerlink" title="树形dp反而要比常规dp简单"></a>树形dp反而要比常规dp简单</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用map进行剪枝</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TreeNode *, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *cur, <span class="built_in">unordered_map</span>&lt;TreeNode *, <span class="keyword">int</span>&gt; &amp;<span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果发现走过，自然就返回之前计算下来的结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.find(cur) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是如果偷此层的孙子层的全部</span></span><br><span class="line">        <span class="keyword">int</span> do_it = cur-&gt;val + (cur-&gt;left == <span class="literal">nullptr</span> ? <span class="number">0</span> : dfs(cur-&gt;left-&gt;left, <span class="built_in">map</span>) + dfs(cur-&gt;left-&gt;right, <span class="built_in">map</span>)) +</span><br><span class="line">                    (cur-&gt;right == <span class="literal">nullptr</span> ? <span class="number">0</span> : dfs(cur-&gt;right-&gt;left, <span class="built_in">map</span>) +</span><br><span class="line">                                                 dfs(cur-&gt;right-&gt;right, <span class="built_in">map</span>));</span><br><span class="line">        <span class="comment">//这里是偷儿子层的全部</span></span><br><span class="line">        <span class="keyword">int</span> not_do_it = dfs(cur-&gt;left, <span class="built_in">map</span>) + dfs(cur-&gt;right, <span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">//选一个最大值存起来就好咯</span></span><br><span class="line">        <span class="built_in">map</span>[cur] = max(do_it, not_do_it);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>用map或者unordered_map存储自定义类型指针的时候什么都不需要重写。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-347. 前 K 个高频元素</title>
    <url>/2019/08/20/leetcode-347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</span><br><span class="line">你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>首先想到的思路：<ol>
<li>既然要找的是前k个出现频率最大的数，那么首先一定就能想到先用map存储上所有的数以及数出现的次数</li>
<li>在全部的数以及数出现的次数都放到map里面之后，就可以想该怎么获得前k个最大的频率数，而且还能根据频率数获得频率数对应的哪个数字，这里用一个类来存放出现数以及数出现的次数出现的数用k表示，数对应的频率用v来表示，再用优先队列存放这个类。</li>
<li>优先队列来维护，这里维护的方式有两种<ol>
<li>第一种是把全部的对象都放到优先队列里面，然后从头取k个对象，从这k个对象中获取所有的k就是结果中的k</li>
<li>第二种是把优先队列的容量就设置为k，然后维护一个v的最小堆，每次比较堆顶的v与遍历到的v，如果遍历到的v要比优先队列中的最小的v大的话，就把那个最小的v所对应的的对象出队，再把大的那个v入队。</li>
</ol>
</li>
<li>遍历优先队列里面的k，放入list就OK。</li>
</ol>
</li>
<li>还有解决方法是和上面差不多的，只不过不用对象来封装数及其数出现的次数，优先队列存储k，每次需要用到v的时候就用map来获取到k对应的v。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pre</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Pre&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Pre&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Pre o1, Pre o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.v &lt; o2.v)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (o1.v &gt; o2.v)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计数和数出现的频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优先队列维护一个从小到大的最小堆，队首是最小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:map.keySet())&#123;</span><br><span class="line">            <span class="comment">//先封装成对象</span></span><br><span class="line">            Pre pre = <span class="keyword">new</span> Pre();</span><br><span class="line">            pre.k = num;</span><br><span class="line">            pre.v = map.get(num);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (queue.size()&lt;k)&#123;</span><br><span class="line">                queue.add(pre);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当遍历到的v大于最小的v时，就把小的v出队，大的v入队</span></span><br><span class="line">            <span class="keyword">if</span> (pre.v &gt; queue.peek().v)&#123;</span><br><span class="line">                queue.remove();</span><br><span class="line">                queue.add(pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            res.add(queue.remove().k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(o1) &gt; map.get(o2))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(o1) &lt; map.get(o2))&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:map.keySet())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (queue.size()&lt;k)&#123;</span><br><span class="line">                queue.add(num);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.get(num) &gt; map.get(queue.peek()))&#123;</span><br><span class="line">                queue.remove();</span><br><span class="line">                queue.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            res.add(queue.remove());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>java内置的优先队列的实现是最小堆，也就是最小的是队首，在定义优先级的时候只需定义什么样的是优先级高的就行，如</li>
<li>其实最大堆和最小堆是没有多大区别的，仔细想他俩的共同点都是堆顶的的优先级都是高于或者低于所有节点的。所以在使用最大堆和最小堆的时候其实都一样的，你只需要根据业务逻辑判断出什么时候优先级大，什么时候优先级小就行了。</li>
<li>最大堆：优先级高的返回1，最小堆：优先级高的返回-1。</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-365. 水壶问题</title>
    <url>/2020/03/21/leetcode-365.%20%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，</span><br><span class="line">从而可以得到恰好 z升 的水？</span><br><span class="line"></span><br><span class="line">如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</span><br><span class="line"></span><br><span class="line">你允许：</span><br><span class="line"></span><br><span class="line">装满任意一个水壶</span><br><span class="line">清空任意一个水壶</span><br><span class="line">从一个水壶向另外一个水壶倒水，直到装满或者倒空</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p><a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/tu-jie-bfs-c-jie-zhu-unordered_set-queue-shi-xian-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/solution/tu-jie-bfs-c-jie-zhu-unordered_set-queue-shi-xian-/</a><br>大佬题解</p>
<p>简单来说需要把问题转换成bfs来做，就是一个状态转换的问题，用一个state表示两杯水每次的状态，state是一个pair，每次的状态其实有6种变化，分别为倒满A/B，倒空A/B，A倒入B，B倒入A 六种方法。用bfs模拟这六种操作，然后把每次得到的结果放到set里，知道出现state.first(第一杯水)==z或者state.secong(第二杯水)==z或者state.first+state.second==z(两杯水的和)的时候就表明水杯问题成立。当队列为空的时候水杯问题不成立。</p>
<p>这里主要用unorder_set存储自定义类型的pair&lt;int,int&gt;的时候要重写hash方法，不用重写equal_to方法</p>
<p>这里为什么不用set而用unorder_set呢，因为set底层是红黑树,所有操作都是log n级别的，而unorder_set的底层是哈希，所以所有操作几乎都是O(1)，也试了一下，这道题用set虽然不出错，但是超时。<br><br><br><br></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明set标记走过的状态</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, HashPair&gt; mark;</span><br><span class="line">        <span class="comment">//bfs用的队列</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//当状态是这三种的时候就表明造出了z的情况</span></span><br><span class="line">            <span class="keyword">if</span> (f.first == z || f.second == z || f.first + f.second == z)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//5种操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//通过传入不同的操作码(i),得到不同的状态</span></span><br><span class="line">                <span class="keyword">auto</span> next = op(i, f, x, y);</span><br><span class="line">                <span class="comment">//如果set中存在这个状态，就不看这个了</span></span><br><span class="line">                <span class="keyword">if</span> (mark.find(next) != mark.end())</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//否则不存在就加入到队列中继续产生新的状态</span></span><br><span class="line">                mark.insert(next);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//哈希值的计算方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashPair</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;key)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">size_t</span>(key.first) * <span class="number">100000007</span> + key.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把bfs的状态转换操作封装成了一个函数，通过type的不同来实现不同的操作</span></span><br><span class="line"><span class="comment">     * @param type  不同的type对应不同的操作</span></span><br><span class="line"><span class="comment">     * @param state 是当前状态的两杯水的各自的容量</span></span><br><span class="line"><span class="comment">     * @param x 题目的x</span></span><br><span class="line"><span class="comment">     * @param y 题目的y</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pair&lt;int, int&gt; op(int type, const pair&lt;int, int&gt; &amp;state, int x, int y) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment">//第一种操作，把a灌满</span></span><br><span class="line">                <span class="keyword">return</span> make_pair(x, state.second);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">//第二种，把b灌满</span></span><br><span class="line">                <span class="keyword">return</span> make_pair(state.first, y);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="comment">//第三种，把a倒光</span></span><br><span class="line">                <span class="keyword">return</span> make_pair(<span class="number">0</span>, state.second);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="comment">//第四种，把b倒光</span></span><br><span class="line">                <span class="keyword">return</span> make_pair(state.first, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line">                <span class="comment">//把a倒到b里面</span></span><br><span class="line">                <span class="comment">//先看要倒多少，如果b和装b的容积差的多，就把a全倒进去，如果a比b和装b的容积的差小，就倒a那么多</span></span><br><span class="line">                <span class="comment">//仔细想想倒水能倒多少的原理</span></span><br><span class="line">                <span class="keyword">int</span> move = min(state.first, y - state.second);</span><br><span class="line">                <span class="keyword">return</span> make_pair(state.first - move, state.second + move);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: &#123;</span><br><span class="line">                <span class="comment">//同上，把b倒到a里面</span></span><br><span class="line">                <span class="keyword">int</span> move = min(x - state.first, state.second);</span><br><span class="line">                <span class="keyword">return</span> make_pair(state.first + move, state.second - move);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>bfs多找状态</li>
<li>当使用set或者map的时候不需要顺序的时候，直接用unorder_set或者unorder_map就行，这两个因为是哈希操作，都是O(1)，比红黑树实现的set或者map的复杂度都是Olog n，要快。不过使用unorder的时候要注意自定义类型的hash和equal_to的问题。这个c++知识点里有写。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-350. 两个数组的交集 II</title>
    <url>/2020/07/13/leetcode-350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个数组，编写一个函数来计算它们的交集。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>对两个数组排序，然后从两个数组开头开始，分别两个索引，如果索引位置上的值相同，就记录这个值，然后索引都后移，如果两个索引位置上的值不一样大，就让值小的那个索引后移。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-383. 赎金信</title>
    <url>/2019/12/17/leetcode-383.%20%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。</span><br><span class="line"></span><br><span class="line">(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>水题,其实就是看第一个字符串里面的字符能不能由第二个字符串里面的所有字符组成</li>
<li>分别统计一下两个字符串里面所有字符以及个数，看第二个能不能全部包含就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] booka = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] bookb = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : a.toCharArray()) &#123;</span><br><span class="line">            booka[c-<span class="number">97</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : b.toCharArray()) &#123;</span><br><span class="line">            bookb[c-<span class="number">97</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (booka[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (bookb[i] &lt; booka[i])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>用字符串的题最好用ascii码来做</li>
<li>a = 97, A = 65。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/ransom-note/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ransom-note/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-38. 报数</title>
    <url>/2019/11/25/leetcode-38.%20%E6%8A%A5%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</span><br><span class="line"></span><br><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。</span><br><span class="line">11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。</span><br><span class="line">21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。</span><br><span class="line"></span><br><span class="line">给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</span><br><span class="line"></span><br><span class="line">注意：整数顺序将表示为一个字符串。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>其实就是外观数列，’11’产生的就是’21’，因为是两个1，那’21’产生的是’1211’，因为1个2，1个1。去掉’个’，就是产生的新的外观数列，那也就是遍历原来的字符串，从头开始计数，如果遇到一样的计数，不一样的就把当前结果拼接到字符串中，然后再往后遍历字符串。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># python快速生成集合的方法</span></span><br><span class="line">        strs = [<span class="string">''</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 为了索引的方便就不要索引0的位置啦，直接从1开始计算</span></span><br><span class="line">        strs[<span class="number">1</span>] = <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为每一个新的字符串都是由旧字符串产生的，所以不断生成新的字符串，直到最后产生最新的字符串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 因为每一个新的字符串都是由旧字符串产生的，所以先拿到旧字符串</span></span><br><span class="line">            temp = strs[i - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 这里产生新的字符串的中介字符串</span></span><br><span class="line">            res = <span class="string">''</span></span><br><span class="line">            <span class="comment"># t是表示当前记录的字符</span></span><br><span class="line">            t = <span class="string">'.'</span></span><br><span class="line">            <span class="comment"># q表示t的个数，注意q的初始值一定是0不是1</span></span><br><span class="line">            q = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(temp)):</span><br><span class="line">                <span class="comment"># 遍历旧字符串的过程中如果没有遇到新字符计数器就++</span></span><br><span class="line">                <span class="keyword">if</span> t == temp[j]:</span><br><span class="line">                    q += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 遇到新字符就更新res内容，然后重新计数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 第一次一定是不一样的，t的初始值定义的很奇怪。这样其实很方便</span></span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                        t = temp[j]</span><br><span class="line">                        q = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 更新res</span></span><br><span class="line">                    res += str(q)</span><br><span class="line">                    res += t</span><br><span class="line">                    <span class="comment"># 更新t、q</span></span><br><span class="line">                    t = temp[j]</span><br><span class="line">                    q = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 因为最后一个字符没有记录到res中，所以这里加上</span></span><br><span class="line">            res += str(q)</span><br><span class="line">            res += t</span><br><span class="line">            <span class="comment"># 把res放到结果数组中</span></span><br><span class="line">            strs[i] = res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strs[n]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-and-say/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-378. 有序矩阵中第K小的元素</title>
    <url>/2020/07/03/leetcode-378.%20%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个 n x n 矩阵，其中每行和每列元素均按升</span><br><span class="line">序排序，找到矩阵中第 k 小的元素。</span><br><span class="line"></span><br><span class="line">请注意，它是排序后的第 k 小元素，而不是第 k </span><br><span class="line">个不同的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">返回 13。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题目要求的是二维数组中第K大的元素，那么自然可以把二维数组里面的所有的数都放到一个数组里面，然后找索引为K-1的元素就OK了</li>
<li>既然每一行从左到右越来越大，那个就可以进行利用一个优先队列来对多个数组进行归并(和用优先队列来归并多个链表一样)，当归并K次时，堆顶元素就是最大值。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="存储全部元素，找索引为K-1的元素"><a href="#存储全部元素，找索引为K-1的元素" class="headerlink" title="存储全部元素，找索引为K-1的元素"></a>存储全部元素，找索引为K-1的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> r = nums.size();</span><br><span class="line">        <span class="keyword">int</span> c = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">                temp.push_back(nums[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(temp.begin(), temp.end());</span><br><span class="line">        <span class="keyword">return</span> temp[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="用队列进行归并"><a href="#用队列进行归并" class="headerlink" title="用队列进行归并"></a>用队列进行归并</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用优先队列存储每一行的第一个元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="comment">//每个点的值</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">//每个点的横坐标</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="comment">//纵坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    point(<span class="keyword">int</span> val, <span class="keyword">int</span> x, <span class="keyword">int</span> y) : val(val), x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照值从小到大排序</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(point t1, point t2) &#123;</span><br><span class="line">        <span class="keyword">return</span> t1.val &gt; t2.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;point&gt; q;</span><br><span class="line">        <span class="keyword">int</span> r = nums.size();</span><br><span class="line">        <span class="keyword">int</span> c = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//最开始的时候把每一行的第一个元素放进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">            q.push(point(nums[i][<span class="number">0</span>], i, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后进行归并，k-1次，从这个循环出去，对顶元素就是第K大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            point temp = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//纵坐标没有越界</span></span><br><span class="line">            <span class="keyword">if</span> (temp.y &lt; c<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">//把这一个点对应的这一行的下一个最左面的点放到队列里</span></span><br><span class="line">                q.push(point(nums[temp.x][temp.y + <span class="number">1</span>], temp.x, temp.y + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q.top().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>优先队列可以对多个有序数组或者队列进行排序(利用归并排序的merge的思想)。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-39. 组合总和</title>
    <url>/2019/12/04/leetcode-386.%20%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数 n, 返回从 1 到 n 的字典顺序。</span><br><span class="line">例如，</span><br><span class="line">给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</span><br><span class="line">请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>字典序其实就是字符串顺序，把1~n每个数都看成字符串，相当于把字符串排序了。这也就是为什么11在2的后面，也就是上面那个例子的意思。</li>
<li>其实也简单，举个例子，n=13，那么顺序就是1,10,11,12,13,2,3,…,9，那就相当于从1开始进行递归，每次对于temp*10+1到9，如果遍历到的数不大于n，那么这个数就是需要的数，同理1，，，9也是递归。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lexicalOrder</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.recurse_lexicaOrder(n, <span class="number">0</span>, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_lexicaOrder</span><span class="params">(self, n: int, temp: int, res: list)</span>:</span></span><br><span class="line">        <span class="comment"># 递归终止条件，temp不大于n</span></span><br><span class="line">        <span class="keyword">if</span> temp &gt; n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 0不添加到结果集中</span></span><br><span class="line">        <span class="keyword">if</span> temp != <span class="number">0</span>:</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="comment"># 每个数都可以进行temp*10+i的操作，用来模拟高位的数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="comment"># 0不考虑</span></span><br><span class="line">            <span class="keyword">if</span> temp * <span class="number">10</span> + i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 将temp变为更高位然后再次进行递归。</span></span><br><span class="line">            self.recurse_lexicaOrder(n, temp * <span class="number">10</span> + i, res)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/lexicographical-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lexicographical-numbers/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-39. 组合总和</title>
    <url>/2019/11/29/leetcode-39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的自然是递归，想法是从0开始递归，每次递归的时候每个数都试一遍，然后递归终止的条件是，当尝试的和到了target，就记录下这个尝试的序列，但是有一个问题，这个没法剪枝，因为是从0开始递归的，到target是不能剪枝的。(我现在还没有想到剪枝的方法)</li>
<li>至于去重的话，因为相同答案的话，组成元素都是一样的，比如[3,2,2]和[2,3,2]虽然数字的顺序不一样，但是内容是一样的，所以当一个结果被确定为结果的时候，都会用一个字典集合去记录它的组成元素，每次再确定新结果的时候只需要从字典集合里判断有没有一样的就行了，如果字典集合有一样的内容，说明这个结果被记录过了。然后这个算法是O(N^N),虽然没超时但是时间有点长，，，。</li>
<li>看了题解的思路，是从target开始往下递归的，然后剪枝方面的话，每次产生分枝，后面的分枝一定比前面的分枝的运行少，因为剪枝的操作，后面的分枝递归的数不会地前面递归的数小，这是由于排序，很棒棒。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, nums, target: int)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        self.recurse_combinationSum(res, [], target, <span class="number">0</span>, nums, &#123;&#125;, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># res是结果集合，temp是中间集合，tsum是中间产生的和，nums是结果数组，d是中间的字典，dres是确定的结果的字典集合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_combinationSum</span><span class="params">(self, res: list, temp: list, target: int, tsum: int, nums: list, d: dict, dres: list)</span>:</span></span><br><span class="line">        <span class="comment"># 如果产生了结果</span></span><br><span class="line">        <span class="keyword">if</span> tsum == target:</span><br><span class="line">            <span class="comment"># 先看这个结果有没有被记录过</span></span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">not</span> <span class="keyword">in</span> dres:</span><br><span class="line">                <span class="comment"># 注意，放新集合一定要产生新地址</span></span><br><span class="line">                t = []</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(temp)):</span><br><span class="line">                    t.append(temp[i])</span><br><span class="line">                res.append(t)</span><br><span class="line">                <span class="comment"># 字典也要产生新的。而且这个字典是记录确定的结果的组成</span></span><br><span class="line">                dd = &#123;&#125;</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> d.keys():</span><br><span class="line">                    dd[k] = d[k]</span><br><span class="line">                dres.append(dd)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里是为了终止递归</span></span><br><span class="line">        <span class="keyword">if</span> tsum &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对于每个数进行递归，因为没有剪枝，所以复杂度是N的N次方，我的天。。。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)):</span><br><span class="line">            <span class="comment"># 日常的新增temp集合</span></span><br><span class="line">            temp.append(nums[i])</span><br><span class="line">            <span class="comment"># 不日常的增加字典集合</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> d.keys():</span><br><span class="line">                d[nums[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[nums[i]] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 开始递归</span></span><br><span class="line">            self.recurse_combinationSum(res, temp, target, tsum + nums[i], nums, d, dres)</span><br><span class="line">            <span class="comment"># 为了确保递归的不影响性，所以这里要把temp和d的变化都清除掉</span></span><br><span class="line">            temp.pop()</span><br><span class="line">            d[nums[i]] -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 为什么要加这句话呢？因为&#123;'a':1,'b':0&#125;和&#123;'a':1&#125;是不一样的，因为b的值位0和不存在b是不一样的</span></span><br><span class="line">            <span class="comment"># 而且上面的变化是如果没有就变成1，这里自然是如果原来没有就要变成原来没有的样子</span></span><br><span class="line">            <span class="keyword">if</span> d[nums[i]] == <span class="number">0</span>:</span><br><span class="line">                d.pop(nums[i])</span><br></pre></td></tr></table></figure>

<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组排序从小到大。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, nums, target: int)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.recurse_combinationSum(<span class="number">0</span>, nums, res, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_combinationSum</span><span class="params">(self, start: int, nums: list, res: list, tsum: int, temp: list)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tsum == <span class="number">0</span>:</span><br><span class="line">            t = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(temp)):</span><br><span class="line">                t.append(temp[i])</span><br><span class="line">            res.append(t)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> tsum - nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            temp.append(nums[i])</span><br><span class="line">            self.recurse_combinationSum(i, nums, res, tsum-nums[i], temp)</span><br><span class="line">            temp.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组排序从大到小</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, nums: list, target: int)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="comment"># 数组排序从大到小</span></span><br><span class="line">        nums.reverse()</span><br><span class="line">        self.recurse_combinationSum(<span class="number">0</span>, target, res, [], <span class="number">0</span>, nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_combinationSum</span><span class="params">(self, tsum: int, target: int, res: list, temp: list, start: int, nums: list)</span>:</span></span><br><span class="line">        <span class="comment"># 如果tsum的值是target，也就是找到了结果</span></span><br><span class="line">        <span class="keyword">if</span> tsum == target:</span><br><span class="line">            t = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(temp)):</span><br><span class="line">                t.append(temp[i])</span><br><span class="line">            res.append(t)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            <span class="comment"># 剪枝一部分</span></span><br><span class="line">            <span class="keyword">if</span> tsum + nums[i] &gt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># temp日常变化</span></span><br><span class="line">            temp.append(nums[i])</span><br><span class="line">            <span class="comment"># 注意下次递归在数组中的索引是i，也就是剪枝的地方，因为数组是从大往小的</span></span><br><span class="line">            <span class="comment"># 大数的所有组合已经走过了(包括大数组合各种小数)，所以到小数的时候就去找比</span></span><br><span class="line">            <span class="comment"># 小数更小的小数了。这样就达到了剪枝的效果。</span></span><br><span class="line">            self.recurse_combinationSum(tsum+nums[i], target, res, temp, i, nums)</span><br><span class="line">            <span class="comment"># temp日常变化</span></span><br><span class="line">            temp.pop()</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>emmm，确定剪枝的话，如果暴力能写出来，就画个递归的图叭，从递归中找能剪枝的地方，看哪些地方是不需要递归的。</li>
<li>这道题的剪枝效果很棒。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>剪纸</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-404. 左叶子之和</title>
    <url>/2019/10/16/leetcode-404.%20%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算给定二叉树的所有左叶子之和。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">    9  20</span><br><span class="line">    /  \</span><br><span class="line">    15   7</span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>首先明确几点：<ol>
<li>因为是树，所以用递归很方便，这里用递归求解。</li>
<li>当只有根节点的时候，只返回0，因为根节点没有左子树。</li>
<li>确立好递归的内容。</li>
</ol>
</li>
<li>这里的递归长这个样子<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode cur, <span class="keyword">int</span> temp, <span class="keyword">boolean</span> flag)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>cur是递归到当前节点的节点，temp是递归到当前节点已经这个节点之前的所有的节点的左子树之和，flag表示当前节点是否是左子树，true表左子树，false表右子树。所以递归的做法就是先判断终止条件，当cur是叶子节点并且该叶子节点是左子树(也就是flag是true的时候，返回该叶子节点的值；如果不是终止条件的话，就递归求cur的左子树的和lsum，再求cur的右子树的和rsum，然后再返回lsum和rsum的和就是cur的整个递归过程。</p>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根节点直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚开始是false的原因是这种递归一开始就是从根节点开始的，因为根节点一定不是左子树，所以这里写false</span></span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode cur, <span class="keyword">int</span> temp, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件：是叶子节点并且是左子树才返回值</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span> &amp;&amp; flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> cur.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">int</span> lsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rsum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往左子树递归</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//往左子树递归需要将temp加上cur的值，并且flag为true</span></span><br><span class="line">            lsum = sumOfLeftLeaves(cur.left, temp + cur.val, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//往右子树递归</span></span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//原理同上因为是右子树，所以不加cur的值，并且flag为false</span></span><br><span class="line">            rsum = sumOfLeftLeaves(cur.right, temp, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cur的所有左子树的值就是cur的左子树的左子树的值加上cur的右子树的左子树的值</span></span><br><span class="line">        <span class="keyword">return</span> lsum+rsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>像这道题，明显可以分治，也就是把求cur的所有左子树的和分解成cur的左子树的左子树的和加上cur的右子树的左子树的和，当是这种分治递归的时候，我觉得做法有三步：<ol>
<li>确立递归终止条件</li>
<li>先不用管最后的返回值，采用局部变量的形式接收左右分治的结果，如这题就是lsum接收cur的左子树的所有左子树和，用rum接收cur的右子树的所有左子树和</li>
<li>综合左右分治的结果，就是当前问题的解。</li>
</ol>
</li>
<li>总的来说就是用当前过程的左右分治的结果造出当前过程的解。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-left-leaves/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-409. 最长回文串</title>
    <url>/2020/03/19/leetcode-409.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span><br><span class="line"></span><br><span class="line">在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">假设字符串的长度不会超过 1010。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>果然不会，看了题解后，发现如果要构造回文串s，当s的长度是偶数的时候，里面的字符都是成双成对的，当s的长度是奇数的时候，只有s的中间那个字符是单个的，剩下的都是成对的。所以可以用unorder_map存储每个字符出现的次数，然后遍历map，看每个字符出现的次数能凑几个对，凑出的对全部的都加起来(因为要求最后s的长度)res，因为res每次加的时候都是偶数，所以res在没有加上中间那个字符的时候一直都是偶数，当遇到某个字符出现的次数是奇数并且res还是偶数的时候，让res加一，相当于是拿到了中间的字符，拿到中间字符之后就一直从两侧拼接对就可以了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="c++"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{
        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;
        <span class="keyword">for</span> (<span class="keyword">char</span> c: s) {
            <span class="built_in">map</span>[c]++;
        }

        <span class="keyword">int</span> res = <span class="number">0</span>;
        <span class="comment">//增强for，因为map的元素是pair，所以用pair来遍历map</span>
        <span class="keyword">for</span> (pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; p: <span class="built_in">map</span>) {
            res += p.second / <span class="number">2</span> * <span class="number">2</span>;
            <span class="keyword">if</span> ((p.second &amp; <span class="number">1</span>) &amp;&amp; (!res &amp; <span class="number">1</span>)) {
                res += <span class="number">1</span>;
            }
        }
        <span class="keyword">return</span> res;
    }
};</code></pre>
<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-40. 组合总和 II</title>
    <url>/2020/09/10/leetcode-40.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 candidates 和一个目标数 target ，找出 </span><br><span class="line">candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的每个数字在每个组合中只能使用一次。</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有数字（包括目标数）都是正整数。</span><br><span class="line">解集不能包含重复的组合。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>记录中间的sum中和与存放的数据元素temp数组。当sum到了数据target的时候就存放temp，否则就往下递归咯</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[candidates.length];</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(ans, temp, book, <span class="number">0</span>, candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; temp, <span class="keyword">int</span>[] book, <span class="keyword">int</span> index, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果加到了指定值，就记录咯</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            List&lt;Integer&gt; t = <span class="keyword">new</span> ArrayList&lt;&gt;(temp);</span><br><span class="line">            <span class="keyword">if</span>(!ans.contains(t))</span><br><span class="line">                ans.add(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果sum大了，就不继续递归了</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target || index&gt;=nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果标记过就不走了</span></span><br><span class="line">            <span class="keyword">if</span> (book[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去重，如果发现要添加的数小于temp末尾的数，就不添加了，因为全排列很全</span></span><br><span class="line">            <span class="comment">//一定会有a在b前与b在a前发生</span></span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt; temp.get(temp.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//标记元素</span></span><br><span class="line">            book[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//添加temp</span></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            <span class="comment">//更新sum</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">            dfs(ans, temp, book, index + <span class="number">1</span>, nums, target, sum);</span><br><span class="line">            book[i] = <span class="number">0</span>;</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-413. 等差数列划分</title>
    <url>/2020/02/17/leetcode-413.%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</span><br><span class="line"></span><br><span class="line">例如，以下数列为等差数列:</span><br><span class="line"></span><br><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br><span class="line">以下数列不是等差数列。</span><br><span class="line"></span><br><span class="line">1, 1, 2, 5, 7</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 </span><br><span class="line">(P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</span><br><span class="line"></span><br><span class="line">如果满足以下条件，则称子数组(P, Q)为等差数组：</span><br><span class="line"></span><br><span class="line">元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</span><br><span class="line"></span><br><span class="line">函数要返回数组 A 中所有为等差数组的子数组个数。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], </span><br><span class="line">[2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的是暴力，遍历所有子数组，然后挨个判断是否是等差数组就完事了</li>
<li>其实并不需要遍历所有的子数组，可以对上面的暴力进行优化，比如说a[p]…a[q]确定了是等差数组，那么判断a[p]…a[q+1]其实并不需要再遍历一遍a[p]到a[q+1]，只需要看看a[q+1]和a[q]的差值是不是和a[p]..a[q]里面的差值相同就行了，也就是如果以a[p]开头的某个子数组找到了第一个a[q]，那么要继续判断以a[p]开头的等差数组只需要直接往后看a[q]后面的是不是继续等差，如果是，计数器继续加一，如果不是，那么以a[p]开头的所有等差数组的个数就记录完了。</li>
<li>动态规划，首先明确dp[i]代表什么，这里dp[i]代表的是以a[i]为结尾的所有的等差数组的个数，那么状态转移方程是<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i] - a[i - <span class="number">1</span>] == a[i - <span class="number">1</span>] - a[i - <span class="number">2</span>]) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果a[i]和a[i-1]的差值和a[i-1]与a[i-2]的差值相同，假设dp[i-1]的值代表的是所有以a[i-1]为结尾的等差数组的个数，那么必然存在a[x…i-1]是等差的，而a[i-1]和a[i]也是等差的，那么就一定有a[x+1…i]也是等差的，而且此时，dp[i]是dp[i-1]，但是又因为a[i]在a[x…i-1]后面拼接上了，所以还有一个等差数组是a[x…i]，所以dp[i]=dp[i-1]+1是这么来的。所有的dp[i]算出来之后，求和就行了，因为求的数所有等差数组，而每个dp[i]里面的等差数组又不重复，所以sum(dp数组)就完事了</p>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力判断所有子数组"><a href="#暴力判断所有子数组" class="headerlink" title="暴力判断所有子数组"></a>暴力判断所有子数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//二重循环拿到所有的子数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (check(a, i, j))</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断a[p]...a[q]这个子数组是不是等差子数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p + <span class="number">1</span> &gt;= q)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = a[p + <span class="number">1</span>] - a[p];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= q - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] - a[i] != temp)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向后判断是否继续等差"><a href="#向后判断是否继续等差" class="headerlink" title="向后判断是否继续等差"></a>向后判断是否继续等差</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//直接向后判断是否继续等差</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果等差计数器就加一</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] - a[j - <span class="number">1</span>] == a[j - <span class="number">1</span>] - a[j - <span class="number">2</span>])</span><br><span class="line">                    ans++;</span><br><span class="line">                <span class="comment">//不等差就说明以a[p]开头的所有等差数组结束了。</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//注意状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] - a[i - <span class="number">1</span>] == a[i - <span class="number">1</span>] - a[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            sum += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>做dp首先找出dp[i]代表的含义，然后找状态转移方程，其实就是dp[i]和dp[i-1]的关系。</li>
<li>dp的套路无非都是<em>重叠子问题<em>，</em>最优子结构</em></li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/arithmetic-slices/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/arithmetic-slices/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-415. 字符串相加</title>
    <url>/2020/02/11/leetcode-415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">num1 和num2 的长度都小于 5100.</span><br><span class="line">num1 和num2 都只包含数字 0-9.</span><br><span class="line">num1 和num2 都不包含任何前导零。</span><br><span class="line">你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>用两个指针，从后往前模拟加法，如果两者相加大于十就保留进位。到了前面的加法就加上这个进位。这里有个很好的处理方法，因为两个字符串大部分时候不一样长，所以当两个指针都小于0的时候循环才结束，当有一个字符串已经遍历完的时候，还是照常加，只不过这时候用0代替到头的字符串的数值。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个指针</span></span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//产生的结果字符串</span></span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//用于保留进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里的处理，为了方便处理，当两个字符串都遍历完再停</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//因为有可能一个字符串会提前到，所以让提前到的字符串</span></span><br><span class="line">            <span class="comment">//的值变为0，这样不会有越界的问题</span></span><br><span class="line">            <span class="keyword">int</span> n = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//temp存储所有的值相加，包括进位的值</span></span><br><span class="line">            <span class="keyword">int</span> temp = n + m + carry;</span><br><span class="line">            <span class="comment">//计算此处的进位</span></span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//计算最后一位</span></span><br><span class="line">            res.append(temp % <span class="number">10</span>);</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最后有进位，记得要加上这个进位</span></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">            res.append(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为拼接答案的时候使一直向后添加的，所以这里要reverse一下。</span></span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">"0"</span> &amp;&amp; num2 == <span class="string">"0"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = num1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = num2.size();</span><br><span class="line">        <span class="keyword">int</span> i = len1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = len2 - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//保留多出来的数字</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                a = num1[i] - <span class="string">'0'</span>;</span><br><span class="line">                b = num2[j] - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                a = num1[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                b = num2[j] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到这里a与b都赋值完毕了</span></span><br><span class="line">            <span class="keyword">int</span> tsum = a + b + t;</span><br><span class="line">            <span class="keyword">int</span> ge = tsum % <span class="number">10</span>;</span><br><span class="line">            t = tsum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//拼接个位</span></span><br><span class="line">            <span class="keyword">char</span> c = ge + <span class="string">'0'</span>;</span><br><span class="line">            res += c;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新索引</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">0</span>)</span><br><span class="line">            res += <span class="string">'1'</span>;</span><br><span class="line">        reverse(res.begin(),  res.end());</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/add-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-strings</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>有必要看看</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-414. 第三大的数</title>
    <url>/2019/08/03/leetcode-414.%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 2, 1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 第三大的数是 1.</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第三大的数不存在, 所以返回最大的数 2</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 2, 3, 1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><br><span class="line">存在两个值为2的数，它们都排第二。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>不能排序，就遍历的时候就分别找第一大、第二大、第三大的数，有些数据很奇怪</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为有的数据很特殊，比如第三大的正好是整形的最小值，所以这里用long的最小值</span></span><br><span class="line">        <span class="keyword">long</span> max1 = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">long</span> max2 = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">long</span> max3 = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a.length == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>]&gt;a[<span class="number">1</span>]?a[<span class="number">0</span>]:a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="comment">//这里相同的数就不看了，如果左边加了等号，那么相同的数也会被记录的</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;max1)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;max2 &amp;&amp; i&lt;max1)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;max3 &amp;&amp; i&lt;max2)&#123;</span><br><span class="line">                max3 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果说max3的值没有更新，那就说明这个数组里面没有第三大的数，那就根据题意返回第一大的数</span></span><br><span class="line">        <span class="keyword">return</span> max3==Long.MIN_VALUE? (<span class="keyword">int</span>)max1:(<span class="keyword">int</span>)max3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/third-maximum-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/third-maximum-number/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-43. 字符串相乘</title>
    <url>/2020/08/13/leetcode-43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num1 和 num2 的长度小于110。</span><br><span class="line">num1 和 num2 只包含数字 0-9。</span><br><span class="line">num1 和 num2 均不以零开头，除非是数字 0 本身。</span><br><span class="line">不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>最开始想的是既然是字符串的乘法，而且乘法可以用加法表示，所以让num1自己加自己num2次，然后超时。</li>
<li>然后就是模拟笔算乘法的方法，用num2的每一位乘出来的字符串加起来就是num1和num2相乘的结果，注意num2的从后往前的每一位乘出来的字符串要在后面补0，想想笔算乘法的时候，从倒数第二个数开始乘出来的结果都要比上一个数往前移动一位，这里的移动一位用在字符串末尾补0来实现。总的来说就是把num2的每一位与num1乘出来的字符串（注意补0）相加。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">//需要补0的个数</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//j是num2的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//cur是num2的第j位和num1的每一位相乘的产生的结果</span></span><br><span class="line">            <span class="built_in">string</span> cur = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> tt = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//拼接0，拼接t个0</span></span><br><span class="line">            <span class="keyword">while</span> (tt &lt;= t) &#123;</span><br><span class="line">                cur += <span class="string">'0'</span>;</span><br><span class="line">                tt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拿到num2对应的字符的数字</span></span><br><span class="line">            <span class="keyword">int</span> ch2 = num2[j] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//拿到num1对应的字符的数字</span></span><br><span class="line">                <span class="keyword">int</span> ch1 = num1[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//拿到这一位的相乘的结果</span></span><br><span class="line">                <span class="keyword">int</span> tsum = ch1 * ch2 + carry;</span><br><span class="line">                <span class="comment">//拿到新的个位</span></span><br><span class="line">                <span class="keyword">int</span> ge = tsum % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//计算进位</span></span><br><span class="line">                carry = tsum / <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">char</span> ch_ge = ge + <span class="string">'0'</span>;</span><br><span class="line">                cur += ch_ge;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同字符串相加的问题，如果最后还有进位</span></span><br><span class="line">            <span class="comment">//自然也要加上</span></span><br><span class="line">            <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch_carry = carry + <span class="string">'0'</span>;</span><br><span class="line">                cur += ch_carry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//反转cur</span></span><br><span class="line">            reverse(cur.begin(), cur.end());</span><br><span class="line">            <span class="comment">//相加</span></span><br><span class="line">            ans = addStrings(ans, cur);</span><br><span class="line">            <span class="comment">//从倒数第二位开始。每一位都要补0，t的个数就是补0的个数 </span></span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//之前写的字符串相加的问题</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">"0"</span> &amp;&amp; num2 == <span class="string">"0"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = num1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = num2.size();</span><br><span class="line">        <span class="keyword">int</span> i = len1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = len2 - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//保留多出来的数字</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                a = num1[i] - <span class="number">48</span>;</span><br><span class="line">                b = num2[j] - <span class="number">48</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                a = num1[i] - <span class="number">48</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                b = num2[j] - <span class="number">48</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到这里a与b都赋值完毕了</span></span><br><span class="line">            <span class="keyword">int</span> tsum = a + b + t;</span><br><span class="line">            <span class="keyword">int</span> ge = tsum % <span class="number">10</span>;</span><br><span class="line">            t = tsum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//拼接个位</span></span><br><span class="line">            <span class="keyword">char</span> c = ge + <span class="number">48</span>;</span><br><span class="line">            res += c;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新索引</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">0</span>)</span><br><span class="line">            res += <span class="string">'1'</span>;</span><br><span class="line">        reverse(res.begin(), res.end());  </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/multiply-strings/</a>    </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-42. 接雨水</title>
    <url>/2020/04/04/leetcode-42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br></pre></td></tr></table></figure>

<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" target="_blank" rel="noopener">https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png</a><br>题目图片</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>可以分别计算每一列的雨水，每一列的雨水能盛的谁的高度等于这一列左面的最大列和右面的最大列的较小的那一列减去这一列的高度。也就是对于每一列，都拿到这一列的左面的最大列，右面的最大列，然后两个取一个最小值，最小值减去这一列的高度，就是这一列能盛水的高度。</li>
<li>上面的暴力方法超时，原因就是对于每个列我们都需要重新计算这个列的左面的最大值和这个列的右面的最大值，这个是很花时间的，所以我们可以发现，计算每一列的左面的最大值和右面的最大值是可以用一个辅助空间存储的，也就是相当于，用一个数组记录每一列的左面的最大值，用一个数组记录每一列的右面的最大值，这样看是不是很简单，这里我的做法是把这两个数组放到一个二维dp[][]数组里，dp[i][0]代表a[i]左面的最大列，dp[i][1]代表a[i]右面的最大列。</li>
<li>双指针方法<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/327718/，官方题解下Lucien的评论讲解双指针很明了。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/327718/，官方题解下Lucien的评论讲解双指针很明了。</a></li>
<li>这里简要说一下双指针，left_max记录从左往右的最大值，right_max记录从右往左的最大值，那么有一个明显的问题，left_max和right_max是不能同时使用的，因为你要完全的从左到右才能得到准确的left_max，从右往左才能得到准确的right_max，所以说，这里需要取巧，因为是双指针，走l指针的时候我们是从左往右的，此时left_max是准确的，那么对于此时的a[l]这一列来说，此时记录的left_max一定是正确的，此时记录的right_max不一定的正确的，而且真正的right_max一定是大于等于此时记录的right_max的，所以当此时记录的left_max小于等于此时记录的right_max的时候，就相当于明确了当前a[l]这一列的能存的是left_max-a[l]。同理对于右面也一样</li>
<li>单调栈，维护一个单调递减的栈。<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/啧啧啧啧啧啧寻" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/啧啧啧啧啧啧寻</a></li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="找左右两边的高度-超时"><a href="#找左右两边的高度-超时" class="headerlink" title="找左右两边的高度(超时)"></a>找左右两边的高度(超时)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftmax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightmax = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找出左面最大列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">                leftmax = max(leftmax, a[j]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出右面最大列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.size(); j++)</span><br><span class="line">                rightmax = max(rightmax, a[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左面最大列和右面最大列的最小值减去这一列的高度就是这一列能盛的水的高度</span></span><br><span class="line">            ans = ans + min(leftmax, rightmax) - a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划，用辅助空间记录每一列的左面的最大值和右面的最大值"><a href="#动态规划，用辅助空间记录每一列的左面的最大值和右面的最大值" class="headerlink" title="动态规划，用辅助空间记录每一列的左面的最大值和右面的最大值"></a>动态规划，用辅助空间记录每一列的左面的最大值和右面的最大值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="comment">//第二维的0记录左面最大值，第二维的1记录右面最大值,dp[i][0]表示a[i]左面的最大值</span></span><br><span class="line">        <span class="comment">//dp[i][1]表示a[i]右面的最大值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="comment">//那么最左面的数的左面的最大值就是自己</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//最右面的数的右面的最大值也是自己</span></span><br><span class="line">        dp[n - <span class="number">1</span>][<span class="number">1</span>] = a[n - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//计算所有元素的左面的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算所有元素的右面的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i + <span class="number">1</span>][<span class="number">1</span>], a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = ans + min(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>]) - a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//此时记录的左面的最大值</span></span><br><span class="line">        <span class="keyword">int</span> left_max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//此时记录的右面的最大值</span></span><br><span class="line">        <span class="keyword">int</span> right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="comment">//此时对于从左往右的列来说,left_max是确定是正确的，而真正的right_max</span></span><br><span class="line">            <span class="comment">//是一定大于等于当前记录的right_max，那么如果当前记录的left_max&lt;当前记录的</span></span><br><span class="line">            <span class="comment">//right_max的时候，对于真正的right_max我们就没有必要看了，所以直接用</span></span><br><span class="line">            <span class="comment">//left_max来计算这一列能盛的水的高度就行了。</span></span><br><span class="line">            <span class="keyword">if</span> (left_max &lt; right_max) &#123;</span><br><span class="line">                <span class="comment">//更新左面的最大值</span></span><br><span class="line">                left_max = max(left_max, a[l]);</span><br><span class="line">                <span class="comment">//计算结果</span></span><br><span class="line">                ans = ans + left_max - a[l];</span><br><span class="line">                l++;</span><br><span class="line">            <span class="comment">//右面是同理的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right_max = max(right_max, a[r]);</span><br><span class="line">                ans = ans + right_max - a[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = a.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造一个单调递减的栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="comment">//如果发生大于栈顶的元素，也就是可以产生积水的地方</span></span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; a[i] &gt; a[<span class="built_in">stack</span>.top()]) &#123;</span><br><span class="line">                <span class="comment">//获得最低点的高度</span></span><br><span class="line">                <span class="keyword">int</span> h = a[<span class="built_in">stack</span>.top()];</span><br><span class="line">                <span class="comment">//更新栈顶，因为计算宽度计算的是底部左右两端的距离，而不是最低点</span></span><br><span class="line">                <span class="comment">//和右端的距离</span></span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">stack</span>.empty())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//得到最低点左右两端的距离</span></span><br><span class="line">                <span class="keyword">int</span> distance = i - <span class="built_in">stack</span>.top() - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//得到最低点左右两端的最低高度</span></span><br><span class="line">                <span class="keyword">int</span> min_height = min(a[i], a[<span class="built_in">stack</span>.top()]);</span><br><span class="line">                <span class="comment">//计算这一行的面积</span></span><br><span class="line">                ans = ans + distance * (min_height - h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//存入坐标</span></span><br><span class="line">            <span class="built_in">stack</span>.push(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water/submissions/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-434. 字符串中的单词数</title>
    <url>/2019/10/18/leetcode-434.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</span><br><span class="line"></span><br><span class="line">请注意，你可以假定字符串里不包括任何不可打印的字符。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Hello, my name is John&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找规律，可以发现定义单词的情况就是当前字符非空格，前一个字符是空格，这样就算一个单词。（这</span><br><span class="line">道题比较特殊）</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSegments</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s)):</span><br><span class="line">            <span class="comment"># 明确一个单词的情况，当前字符非空格，上一个字符是空格</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span> <span class="keyword">or</span> s[i<span class="number">-1</span>]==<span class="string">' '</span>) <span class="keyword">and</span> s[i]!=<span class="string">' '</span>:</span><br><span class="line">                cnt+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-segments-in-a-string/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-448.找到所有数组中消失的数字</title>
    <url>/2019/07/29/leetcode-448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</span><br><span class="line"></span><br><span class="line">找到所有在 [1, n] 范围之间没有出现在数组中的数字。</span><br><span class="line"></span><br><span class="line">您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>明显可以用哈希表先存储，然后从1到n开始遍历，看set里面有没有，没有的都记上</li>
<li>因为值得特殊性，1&lt;=a[i]&lt;=n，正好可以从索引下手，把所有索引对应的位置上的值变成负数，变完之后数组上的值如果还是正数就表明这个正数所对应的的索引值是没有经过上一步的操作的，就表明原数组中索引值的缺失。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从1到n开始找，没有谁就记住谁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i))&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从索引下手"><a href="#从索引下手" class="headerlink" title="从索引下手"></a>从索引下手</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把对应索引上的值变成负数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = Math.abs(i)-<span class="number">1</span>;</span><br><span class="line">            a[t] = Math.abs(a[t])*(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看那个索引上的值是没有变成负数的，就说明原来的数组缺那个索引值，如a[i]&gt;0，那么原数组就没有i这个元素。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-44. 通配符匹配</title>
    <url>/2020/07/06/leetcode-44.%20%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &apos;?&apos; 和 &apos;*&apos; 的通配符匹配。</span><br><span class="line"></span><br><span class="line">&apos;?&apos; 可以匹配任何单个字符。</span><br><span class="line">&apos;*&apos; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &apos;*&apos; 可以匹配任意字符串。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;cb&quot;</span><br><span class="line">p = &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &apos;?&apos; 可以匹配 &apos;c&apos;, 但第二个 &apos;a&apos; 无法匹配 &apos;b&apos;。</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;adceb&quot;</span><br><span class="line">p = &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &apos;*&apos; 可以匹配空字符串, 第二个 &apos;*&apos; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure>

<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;acdcb&quot;</span><br><span class="line">p = &quot;a*c?b&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>这种题最简单的思路就是递归，但是这道题递归超时，题意?匹配一个字符，*匹配任意个，？这个符号没什么好说的，主要是 *,假如s是匹配串，p是模式串，那么i，j分别是s和p的指针，如果p[j]当前是 *，那么有两种情况，要么i不动，j后移，表示 *匹配一个空格，要么i后移，j不动，表示j * 匹配一个字符。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果两个指针都到了最后</span></span><br><span class="line">        <span class="keyword">if</span> (i == s.size() - <span class="number">1</span> &amp;&amp; j == p.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= s.size() || j &gt;= p.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果字符相同或者是?</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'?'</span>)</span><br><span class="line">            <span class="keyword">return</span> dfs(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果模式串碰到了*</span></span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">'*'</span>)</span><br><span class="line">            <span class="comment">//要么i不动，j后移表示*匹配一个空格 </span></span><br><span class="line">            <span class="keyword">return</span> dfs(s, p, i, j + <span class="number">1</span>) ||</span><br><span class="line">                    <span class="comment">//要么i后移，j不动，表示匹配一个字符</span></span><br><span class="line">                   dfs(s, p, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>对于*这个匹配，要么字符串指针右移一个，要么模式串指针右移一个。</p>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-441. 排列硬币</title>
    <url>/2020/02/14/leetcode-441.%20%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。</span><br><span class="line"></span><br><span class="line">给定一个数字 n，找出可形成完整阶梯行的总行数。</span><br><span class="line"></span><br><span class="line">n 是一个非负整数，并且在32位有符号整型的范围内。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n = 5</span><br><span class="line"></span><br><span class="line">硬币可排列成以下几行:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤</span><br><span class="line"></span><br><span class="line">因为第三行不完整，所以返回2.</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n = 8</span><br><span class="line"></span><br><span class="line">硬币可排列成以下几行:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤ ¤</span><br><span class="line">¤ ¤</span><br><span class="line"></span><br><span class="line">因为第四行不完整，所以返回3.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>直觉就行了，其实也可以二分。但是这个题有点玄学，二分完老是不太对。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= sum) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>存储sum一般用long???</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/arranging-coins/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/arranging-coins/submissions/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-455. 分发饼干</title>
    <url>/2020/02/14/leetcode-455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只</span><br><span class="line">能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的</span><br><span class="line">饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们</span><br><span class="line">可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越</span><br><span class="line">多数量的孩子，并输出这个最大数值。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">你可以假设胃口值为正。</span><br><span class="line">一个小朋友最多只能拥有一块饼干。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>因为一个饼干只能分给一个孩子，所以将孩子数组和饼干数组都从小到大排序，确保小饼干分给胃口小的孩子。一个饼干分出去之后就换一个饼干，孩子得到饼干之后就换下一个孩子，如果当前饼干不够大，就换下一个饼干(注意这时是不能换孩子的，因为此时孩子就已经是胃口最小的孩子了，当前饼干如果都不够，那么后面的孩子更不够。)</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; g.length &amp;&amp; j &lt; s.length) &#123;</span><br><span class="line">            <span class="comment">//当前饼干够</span></span><br><span class="line">            <span class="keyword">if</span> (g[i] &lt;= s[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                res++;</span><br><span class="line">            <span class="comment">//饼干不够就换饼干</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/assign-cookies/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-485.最大连续1的个数</title>
    <url>/2019/07/28/leetcode-485.%20%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二进制数组， 计算其中最大连续1的个数。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,0,1,1,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入的数组只包含 0 和1。</span><br><span class="line">输入数组的长度是正整数，且不超过 10,000。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>求最长的连续的1的个数，那么逐个遍历咯，用一个变量表示当前已经连续的个数，再用一个变量表示最大的连续个数，每次看遍历到的数是1还是0，如果是1那么连续的个数就加一并且再和最大的数进行一次比较，如果是0那么连续的个数直接就是0，然后进行下一个数，很奇妙。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历到当前数字的当前最大的连续个数，时时变得</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最终的</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果这个数是1那么连续的个数+1</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则就重新开始及</span></span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次res发生变化时都进行一次比较</span></span><br><span class="line">            <span class="keyword">if</span> (res&gt;max)&#123;</span><br><span class="line">                max = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-consecutive-ones/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-495. 提莫攻击</title>
    <url>/2020/01/02/leetcode-495.%20%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</span><br><span class="line">现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。</span><br><span class="line"></span><br><span class="line">你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,4], 2</span><br><span class="line">输出: 4</span><br><span class="line">原因: 在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。</span><br><span class="line">在第 4 秒开始时，提莫再次攻击艾希，使得艾希获得另外 2 秒的中毒时间。</span><br><span class="line">所以最终输出 4 秒。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2], 2</span><br><span class="line">输出: 3</span><br><span class="line">原因: 在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。</span><br><span class="line">但是在第 2 秒开始时，提莫再次攻击了已经处于中毒状态的艾希。</span><br><span class="line">由于中毒状态不可叠加，提莫在第 2 秒开始时的这次攻击会在第 3 秒钟结束。</span><br><span class="line">所以最终输出 3。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以假定时间序列数组的总长度不超过 10000。</span><br><span class="line">你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过 10,000,000。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>buff的持续时间么，模拟就行了。</li>
<li>判断两个时间的间隔够不够一个持续时间，如果够，最后的结果res加一个持续时间，如果不够，就加两个时间段内的间隔。然后遍历完所有的时间间隔后再让最后的结果res加一个持续时间，因为最后肯定是有一个持续时间的。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + d &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                res += d;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = res + nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res += d;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/teemo-attacking/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/teemo-attacking/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-49. 字母异位词分组</title>
    <url>/2020/02/14/leetcode-49.%20%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的是把每个字符串都表示称自己的哈希模式(那个字符出现几次)，然后再双重循环遍历字符串数组，如果一样的就放在一起。但是这个想法十分超时。</li>
<li>后来根据题意分析，要把组成相同的字符串放在一起，为何不根据这个性质造一个map呢？在map里面维护一个字符串对应一个集合，这个字符串是某个字符串按字典序排序的，假设这个字符串原来是s1，按照字典序排序完之后叫他s0,下次遇到和s1组成的字符串组成相同的s2的时候，只需要将s2按照字典序排序和s0比较一下是否相同，如果相同，就放在s0对应的集合里面，同理出现和s1性质相同的s3也是一个道理。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="字符串对应集合"><a href="#字符串对应集合" class="headerlink" title="字符串对应集合"></a>字符串对应集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] ss) &#123;</span><br><span class="line">        <span class="comment">//字典序字符串对应相同字符串组成的字符串集合</span></span><br><span class="line">        Map&lt;String, ArrayList&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历每个字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chs = ss[i].toCharArray();</span><br><span class="line">            <span class="comment">//按照字典序排序</span></span><br><span class="line">            Arrays.sort(chs);</span><br><span class="line">            String s = <span class="keyword">new</span> String(chs);</span><br><span class="line">            <span class="comment">//如果map里面没有这个字符串，就put进去</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s)) &#123;</span><br><span class="line">                ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(ss[i]);</span><br><span class="line">                map.put(s, list);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果包含。那就巧了，直接放在s0对应的计划金额里面就行了。</span></span><br><span class="line">                ArrayList&lt;String&gt; list = map.get(s);</span><br><span class="line">                list.add(ss[i]);</span><br><span class="line">                map.put(s, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后把map里面的字符串集合统一就行了。</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : map.keySet()) &#123;</span><br><span class="line">            res.add(map.get(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>找共性</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-5. 最长回文子串</title>
    <url>/2019/10/28/leetcode-5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">暴力的方法自然是二重循环遍历到所有的字符串，然后看遍历到的字符串是不是会回文串，如果是回文串再看看是不是最长的回文串，遍历完全部的</span><br><span class="line">字符串的时候最大的回文串也就找到了。</span><br><span class="line"></span><br><span class="line">还有dp的解法：遵照题解中的https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 遍历所有的字符串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            list = []</span><br><span class="line">            list.append(s[i])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">                res = s[i]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(s)):</span><br><span class="line">                list.append(s[j])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> self.isReverse(list) == <span class="literal">True</span> <span class="keyword">and</span> len(list) &gt; len(res):</span><br><span class="line">                    res = <span class="string">""</span></span><br><span class="line">                    <span class="keyword">for</span> temp <span class="keyword">in</span> list:</span><br><span class="line">                        res += temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断传入的字符串是不是回文串的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isReverse</span><span class="params">(self, l: list)</span> -&gt; bool:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(l) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> l[i] != l[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp数组</span></span><br><span class="line">        <span class="keyword">boolean</span> dp[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        # 先随便记录一个最大长度和最大子串</span><br><span class="line">        <span class="keyword">int</span> lenmax = <span class="number">1</span>;</span><br><span class="line">        String strmax = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二重循环遍历所有的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; s.length(); r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++) &#123;</span><br><span class="line">                <span class="comment">// 根据dp性质，根据dp递归公式，快速判断当前s[l...r]是不是一个回文串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(l) == s.charAt(r) &amp;&amp; (r - l &lt;= <span class="number">2</span> || dp[l + <span class="number">1</span>][r - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[l][r] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 如果是回文串的话看看是不是最大的回文串</span></span><br><span class="line">                    <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; lenmax) &#123;</span><br><span class="line">                        lenmax = r - l + <span class="number">1</span>;</span><br><span class="line">                        strmax = s.substring(l, r + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最大的回文串 </span></span><br><span class="line">        <span class="keyword">return</span> strmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这道题的dp优化是从暴力中来的，暴力需要O(n^2)找到所有字符串，然后再在其中再来一个O(n)判断是否是回文串，dp则是在最内层的的</span><br><span class="line">一个O(n)中快速判断是否是回文串。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-39. 组合总和</title>
    <url>/2019/12/04/leetcode-500.%20%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">输出: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以重复使用键盘上同一字符。</span><br><span class="line">你可以假设输入的字符串将只包含字母。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>模拟题，，，本质就是看一个字符串里面有没有另一个字符串的组成</p>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 提前准备好</span></span><br><span class="line">        strs = [<span class="string">'QWERTYUIOP'</span>, <span class="string">'ASDFGHJKL'</span>, <span class="string">'ZXCVBNM'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历每个输入数据的字符串</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> words:</span><br><span class="line">            tt = s</span><br><span class="line">            <span class="comment"># 为方便直接用大写处理</span></span><br><span class="line">            s = s.upper()</span><br><span class="line">            <span class="keyword">for</span> ss <span class="keyword">in</span> strs:</span><br><span class="line">                <span class="comment"># 用flag标记是否在一个字符串中存在另一个字符串</span></span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">                    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> ss:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                    res.append(tt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/keyboard-row/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/keyboard-row/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-513. 找树左下角的值</title>
    <url>/2020/02/27/leetcode-513.%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，在树的最后一行找到最左边的值。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       / \</span><br><span class="line">      2   3</span><br><span class="line">     /   / \</span><br><span class="line">    4   5   6</span><br><span class="line">       /</span><br><span class="line">      7</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>bfs层序遍历树的每一层，每次遇到每一层的第一个节点的时候都保留住这个值，当bfs完了之后，最后一个保存的值就是最下面一层的最左面的值。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//用来标记这个是不是此层的第一个数</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//正常层序遍历</span></span><br><span class="line">            <span class="keyword">int</span> t = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                TreeNode remove = q.remove();</span><br><span class="line">                <span class="comment">//遇到了第一个数</span></span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    res = remove.val;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (remove.left != <span class="keyword">null</span>)</span><br><span class="line">                    q.add(remove.left);</span><br><span class="line">                <span class="keyword">if</span> (remove.right != <span class="keyword">null</span>)</span><br><span class="line">                    q.add(remove.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-509.斐波那契数</title>
    <url>/2019/07/24/leetcode-509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</span><br><span class="line"></span><br><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">给定 N，计算 F(N)。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line">0 ≤ N ≤ 30</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>首先最容易想到的就是暴力递归，但是递归的复杂度等于子问题的个数*单个问题的时间，从这里可以分析f(5) = f(4)+f(3)，f(4) = f(3)+f(2),如下图<img src="/image/leetcode-509.png" alt>，根据递归的特性求走到f(5)会去求f(4)，求f(4)的时候会去求f(3)，顺序如下图<img src="/image/leetcode-509(2).png" alt>按照这个顺序走完之后其实递归所需要的东东都已经求完了，剩下蓝色部分的内容都是递归写法的必要要走到的地方，正因为这些内容造成了暴力递归的指数级的复杂度的浪费。</li>
<li>然后就随之而来有一种解决方法，把已经知道的值不在需要递归，如在求f(5)需要知道f(4)与f(3)，但是在求f(4)的时候需要求f(3)和f(2)，根据递归的特性，先求f(4)，所以在求完f(5)下面的f(4)之后就不用再求f(5)下面的f(3)。这个不用求的操作可以用一个标技数组来做。这就是最简单的剪枝。</li>
<li>把这个备忘录数组提取出来之后就是DP啦。不再用递归写，而是用状态转移方程，就是DP的写法，而且DP的过程就是第二种方法的逆向过程，从下往上推，这样的是最快的。状态转移方程式递归的最终解，也就是最简式。状态转移方程可以从前两种方法的看出来。</li>
<li>再优化DP的话就只能从空间进行优化了，这就是分析了。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力递归，复杂度是指数级的O(2的n次方)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排除0,1情况</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常递归</span></span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用这个备忘录数组存储已经计算过的值，在进行递归之前先看一下有木有</span></span><br><span class="line">        <span class="keyword">int</span> memo[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> helper(n, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这里已经有计算过的值了，就直接返回已经有的值</span></span><br><span class="line">        <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//否则就正常的递归</span></span><br><span class="line">        memo[n] = helper(n-<span class="number">1</span>, memo) + helper(n-<span class="number">2</span>, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排除0，1情况</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp赋初值</span></span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//状态转移方程</span></span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DP省空间的做法"><a href="#DP省空间的做法" class="headerlink" title="DP省空间的做法"></a>DP省空间的做法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化了第三种做法的空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为分析后得知，要算出f(n)只需知道f(n-1)和f(n-2)。用三个数就可以替代了之前的所有结果</span></span><br><span class="line">        <span class="keyword">int</span> t1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum = t1+t2;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>做动态规划的题的时候，可以分三步：1.暴力递归，2.剪枝，3.得出结论写出状态转移方程。</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fibonacci-number/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-51. N 皇后</title>
    <url>/2020/09/05/leetcode-51.%20N%20%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span><br><span class="line">上图为 8 皇后问题的一种解法。</span><br><span class="line"></span><br><span class="line">给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</span><br><span class="line"></span><br><span class="line">每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &apos;Q&apos; 和 &apos;.&apos; 分别代表了皇后和空位。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：[</span><br><span class="line"> [&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>回溯，每次dfs的时候找到可以放格子的位置，然后进行下一层的bfs，然后再继续dfs。</li>
<li>官方题解写得不错</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结果数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ans;</span><br><span class="line">        <span class="comment">//cols存储用了哪些列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="comment">//用于记录已经存在的格子的左值(左值一样不能放)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line">        <span class="comment">//用于记录已经存在的格子的右值(右值一样不能放)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第一层到第n-1层开始递归</span></span><br><span class="line">        dfs(ans, cols, l1, l2, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l2, <span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果递归到了最后一层</span></span><br><span class="line">        <span class="keyword">if</span> (num == n) &#123;</span><br><span class="line">            <span class="comment">//根据保存的列的下标，生成棋盘</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp = generateString(cols, n);</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//如果不符合N皇后的标准</span></span><br><span class="line">            <span class="comment">//如果列存在（不同列）</span></span><br><span class="line">            <span class="keyword">if</span> (find(cols.begin(), cols.end(), i) != cols.end()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保证左值不存在（不在一个对角线）</span></span><br><span class="line">            <span class="keyword">int</span> left = num - i;</span><br><span class="line">            <span class="keyword">if</span> (find(l1.begin(), l1.end(), left) != l1.end())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//保证右值不存在</span></span><br><span class="line">            <span class="keyword">int</span> right = num + i;</span><br><span class="line">            <span class="keyword">if</span> (find(l2.begin(), l2.end(), right) != l2.end())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果这个位置可以放，就往下递归</span></span><br><span class="line">            cols.push_back(i);</span><br><span class="line">            <span class="comment">//记录这个格子的左值</span></span><br><span class="line">            l1.push_back(left);</span><br><span class="line">            <span class="comment">//记录这个格子的右值</span></span><br><span class="line">            l2.push_back(right);</span><br><span class="line">            <span class="comment">//往下递归</span></span><br><span class="line">            dfs(ans, cols, l1, l2, num + <span class="number">1</span>, n);</span><br><span class="line">            <span class="comment">//消除影响，回溯的保证</span></span><br><span class="line">            cols.pop_back();</span><br><span class="line">            <span class="comment">//消除这个格子的影响</span></span><br><span class="line">            l1.pop_back();</span><br><span class="line">            l2.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给的列的数字生成一个棋盘</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                s += <span class="string">'.'</span>;</span><br><span class="line">            <span class="comment">//给指定的列放Q</span></span><br><span class="line">            s[cols[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            ans.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>回溯的时候记得处理消除此次回溯的影响</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-52. N皇后 II</title>
    <url>/2020/09/05/leetcode-52.%20N%E7%9A%87%E5%90%8E%20II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 4 皇后问题存在如下两个不同的解法。</span><br><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>和51那道题的N皇后一样咯，直接交。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cols存储用了哪些列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="comment">//用于记录已经存在的格子的左值(左值一样不能放)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line">        <span class="comment">//用于记录已经存在的格子的右值(右值一样不能放)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第一层到第n-1层开始递归</span></span><br><span class="line">        dfs(ans, cols, l1, l2, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l2, <span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果递归到了最后一层</span></span><br><span class="line">        <span class="keyword">if</span> (num == n) &#123;</span><br><span class="line">            <span class="comment">//根据保存的列的下标，生成棋盘</span></span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//如果不符合N皇后的标准</span></span><br><span class="line">            <span class="comment">//如果列存在（不同列）</span></span><br><span class="line">            <span class="keyword">if</span> (find(cols.begin(), cols.end(), i) != cols.end()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保证左值不存在（不在一个对角线）</span></span><br><span class="line">            <span class="keyword">int</span> left = num - i;</span><br><span class="line">            <span class="keyword">if</span> (find(l1.begin(), l1.end(), left) != l1.end())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//保证右值不存在</span></span><br><span class="line">            <span class="keyword">int</span> right = num + i;</span><br><span class="line">            <span class="keyword">if</span> (find(l2.begin(), l2.end(), right) != l2.end())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果这个位置可以放，就往下递归</span></span><br><span class="line">            cols.push_back(i);</span><br><span class="line">            <span class="comment">//记录这个格子的左值</span></span><br><span class="line">            l1.push_back(left);</span><br><span class="line">            <span class="comment">//记录这个格子的右值</span></span><br><span class="line">            l2.push_back(right);</span><br><span class="line">            <span class="comment">//往下递归</span></span><br><span class="line">            dfs(ans, cols, l1, l2, num + <span class="number">1</span>, n);</span><br><span class="line">            <span class="comment">//消除影响，回溯的保证</span></span><br><span class="line">            cols.pop_back();</span><br><span class="line">            <span class="comment">//消除这个格子的影响</span></span><br><span class="line">            l1.pop_back();</span><br><span class="line">            l2.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给的列的数字生成一个棋盘</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                s += <span class="string">'.'</span>;</span><br><span class="line">            <span class="comment">//给指定的列放Q</span></span><br><span class="line">            s[cols[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            ans.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens-ii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-53. 最大子序和</title>
    <url>/2019/07/31/leetcode-53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>最开始想的是用O(n^2)法子，枚举所有子串，然后求和，这种做法的关键点是O(n^2)可以枚举所有子串这tm就很神奇。</li>
<li>后来想到用一维的dp，dp[i]表示，从第一个元素开始到a[i]这个元素可以求到的最大的子序列和，每次计算dp[i]的时候都是先看dp[i-1]是不是大于0，如果大于零就说明从一个元素到第i-1有最大的子序和，就说明可以把当前a[i]加到dp[i-1]上来求得dp[i]，否则如果dp[i-1]小于零就说明从第一个数开始到第i-1个数不存在最大的子序和(因为是负数的原因)，所以就重新开始计最大的子序和，也就是从a[i]开始计，然后每次更新dp[i]的时候都看看它是不是最大值，是的话就记录最大值。</li>
<li>题解的解法是：用sum表示遍历到当前的元素之前的有可能取到最大值得总和，用max表示遍历到当前元素之前已经有的最大值，每次遍历到某个元素的时候，看sum是否大于0，若大于零则把当前数与sum加上，加上的结果与max进行比大小，如果小于0就用当前数组值取代sum，再与max比较大小，也算是一种方法。其实就是dp的简化，因为从状态转移方程可以看出来，dp[i]只与dp[i-1]有关，所以就没有必要浪费一个O(n)的内存，可以用一个sum遍历来存储。</li>
<li>也能用分治，但是现在还不会</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="枚举所有子串"><a href="#枚举所有子串" class="headerlink" title="枚举所有子串"></a>枚举所有子串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a.length==<span class="number">1</span>)&#123;</span><br><span class="line">        	<span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首元素的第一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        	sum = <span class="number">0</span>;</span><br><span class="line">        	sum+=a[i];</span><br><span class="line">        	<span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">        		max = sum;</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="comment">//从这里开始枚举所有连续的并且长度不确定的子串，长度逐渐增大</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;</span><br><span class="line">        		sum+=a[j];</span><br><span class="line">        		<span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">        			max = sum;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一位数组的dp"><a href="#一位数组的dp" class="headerlink" title="一位数组的dp"></a>一位数组的dp</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">         <span class="comment">//照dp的来说，只有一个元素的时候确实是只能选自己</span></span><br><span class="line">         dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">         <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">             <span class="comment">//状态转移方程</span></span><br><span class="line">             dp[i] = dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>? dp[i-<span class="number">1</span>]+a[i] : a[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新最大值</span></span><br><span class="line">             max = dp[i]&gt;max? dp[i]:max;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一位数组的dp的省去空间的方法"><a href="#一位数组的dp的省去空间的方法" class="headerlink" title="一位数组的dp的省去空间的方法"></a>一位数组的dp的省去空间的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="comment">//sum保留当前元素之前的有可能成为最大值的总和</span></span><br><span class="line">            <span class="keyword">if</span> (sum&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//sum小于0就不要sum</span></span><br><span class="line">                sum = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//sum&gt;0就加上当前元素</span></span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次更新sum之后都判断sum与max的大小</span></span><br><span class="line">            max = sum&gt;max?sum:max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-538. 把二叉搜索树转换为累加树</title>
    <url>/2020/01/10/leetcode-538.%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            /   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            /   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题意就是把二叉树中每个节点都加上比这个节点值大的所有节点的值么。</li>
<li>那如果从二叉树的值最大到最小遍历一下，每次遍历到新节点就加上之前遍历过的节点的值不就达到了效果了么。</li>
<li>那么怎么倒序遍历一颗BST？既然中序遍历可以从小到大遍历BST，那么从中序遍历反过来不就是从大到小遍历树么。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="中序遍历递归"><a href="#中序遍历递归" class="headerlink" title="中序遍历递归"></a>中序遍历递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(cur.right);</span><br><span class="line">        sum += cur.val;</span><br><span class="line">        cur.val = sum;</span><br><span class="line">        inOrder(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历的非递归"><a href="#中序遍历的非递归" class="headerlink" title="中序遍历的非递归"></a>中序遍历的非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用操作类封装，来模拟系统栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Opt</span> </span>&#123;</span><br><span class="line">        <span class="comment">//flag为true表示操作为置入节点操作,falg为false表示此次操作是加值操作。</span></span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Opt</span><span class="params">(<span class="keyword">boolean</span> flag, TreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//模拟系统栈</span></span><br><span class="line">        Stack&lt;Opt&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//每次存放的是封装后的内容</span></span><br><span class="line">        stack.push(<span class="keyword">new</span> Opt(<span class="keyword">true</span>, root, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//当栈为空表示系统栈调用完毕</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Opt temp = stack.pop();</span><br><span class="line">            <span class="comment">//判断当前操作应该是针对节点的操作还是针对值的操作</span></span><br><span class="line">            <span class="keyword">if</span> (temp.flag) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.node.left != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Opt(<span class="keyword">true</span>, temp.node.left, <span class="number">0</span>));</span><br><span class="line">                <span class="comment">//针对节点的操作包括加值操作的操作，只不过对值的操作不是在对节点的操作里面的</span></span><br><span class="line">                stack.push(<span class="keyword">new</span> Opt(<span class="keyword">false</span>, temp.node, temp.node.val));</span><br><span class="line">                <span class="keyword">if</span> (temp.node.right != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Opt(<span class="keyword">true</span>, temp.node.right, <span class="number">0</span>));</span><br><span class="line">            <span class="comment">//这里就是针对值的操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += temp.node.val;</span><br><span class="line">                temp.node.val = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>BST的中序遍历既可以从小到大遍历树，也可以从大到小遍历树，只需要先遍历右子树就OK。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-535. TinyURL 的加密与解密</title>
    <url>/2019/11/14/leetcode-535.%20TinyURL%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TinyURL是一种URL简化服务， 比如：当你输入一个URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk.</span><br><span class="line"></span><br><span class="line">要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">很自由的一道题，自由设置加密方式和解密方式，这里的做法和题解类似，先拿到原字符串的哈希值，</span><br><span class="line">把这个哈希值和这个字符串以键值对的形式放到map中，然后那一个特定的字符串拼接上这个哈希值</span><br><span class="line">就产生了一个新的字符串，这个新的字符串就是加密后的字符串。</span><br><span class="line"></span><br><span class="line">那么解密就是把这个加密后的字符串去掉原来的特定的字符串，然后这个字符串中就只剩字符串形式的</span><br><span class="line">哈希值了，把这个哈希值转换成整形，然后从map中获取到这个哈希值对应的字符串就达到了解码的效果。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(String longUrl)</span> </span>&#123;</span><br><span class="line">        Integer hash = longUrl.hashCode();</span><br><span class="line">        map.put(hash, longUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://tinyurl/"</span>+hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decode</span><span class="params">(String shortUrl)</span> </span>&#123;</span><br><span class="line">        String nstr = shortUrl.replace(<span class="string">"http://tinyurl/"</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> map.get(Integer.parseInt(nstr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/encode-and-decode-tinyurl/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/encode-and-decode-tinyurl/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>随意</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-532. 数组中的K-diff数对</title>
    <url>/2019/09/12/leetcode-532.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), </span><br><span class="line">其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 1, 4, 1, 5], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:[1, 2, 3, 4, 5], k = 1</span><br><span class="line">输出: 4</span><br><span class="line">解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 3, 1, 5, 4], k = 0</span><br><span class="line">输出: 1</span><br><span class="line">解释: 数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数对 (i, j) 和数对 (j, i) 被算作同一数对。</span><br><span class="line">数组的长度不超过10,000。</span><br><span class="line">所有输入的整数的范围在 [-1e7, 1e7]。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>最开始想的是遍历二重循环，找出所有可能的i，j，然后看nums[i]与nums[j]的差的绝对值是不是k，如果是就把这两个数放到list中，再把list放入set中，最后输出set的大小。但是这种方法是完全不正确的，且不说二重循环的浪费时间，而且把list放到set是不能实现的，因为python中的set是有序的，自然是unhashable的(具体参考我的博客的python分类的语法糖中的set的解释)list不能放入set中的，所以这种思路是不可取的。</li>
<li>因为实在不会做这道题就看了题解，最后的思路是：保存i，j的时候只需要保存i，j中的较小值保存到set中，这样就实现了去重，因为k是一定的，set中的较小值也是唯一的，而且那个较大值等于k加较小值，所以较大值也是唯一的，去重就实现了。然后对于k为不同情况的时候进行分情况讨论，当k==0的时候，把每个元素用字典进行计数，如果出现次数大于1的元素就记录下来，哪个出现次数大于1就表明这个数字就是一组答案，因为k为0，只有自身和自身相减才是0，而且结果有要求唯一，那么每个数字只需要记录一次就好了，那剩下k不为0的时候，就需要把初始的nums变为set，然后遍历set，每次从set中寻找set是否存在使得两数相减的绝对值为k。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> k&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当k为0的时候就用字典记录数字出现的次数</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">            dic = &#123;&#125;</span><br><span class="line">            sum=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                    dic[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic[i] = dic[i]+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="comment"># 如果出现次数大于1，并且k为0，就表明这个数组存在一组解</span></span><br><span class="line">                <span class="keyword">if</span> dic[i]&gt;<span class="number">1</span>:</span><br><span class="line">                    sum+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> sum</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当k&gt;0的时候，需要转换为set，因为set查找更快</span></span><br><span class="line">        temp = set(nums)</span><br><span class="line">        <span class="comment"># s2是存放结果的数组</span></span><br><span class="line">        s2 = set()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> temp:</span><br><span class="line">            <span class="comment"># 因为绝对值的关系和存放小值，所以这么写</span></span><br><span class="line">            <span class="keyword">if</span> i-k <span class="keyword">in</span> temp:</span><br><span class="line">                s2.add(i-k)</span><br><span class="line">            <span class="keyword">if</span> i+k <span class="keyword">in</span> temp:</span><br><span class="line">                s2.add(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len(s2)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>在set中查找的速度比在list中的查找速度快</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-542. 01 矩阵</title>
    <url>/2020/02/11/leetcode-542.%2001%20%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</span><br><span class="line"></span><br><span class="line">两个相邻元素间的距离为 1 。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定矩阵的元素个数不超过 10000。</span><br><span class="line">给定矩阵中至少有一个元素是 0。</span><br><span class="line">矩阵中的元素只在四个方向上相邻: 上、下、左、右。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>遍历矩阵，当遍历到值为1的节点的时候，就返回就开始bfs，去寻找节点值为0的节点。并且在找的规程中记录，因为队列是先进后出的，所以队列顺序一定是先处理所有最近的节点。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个点的坐标</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">//这个节点属于bfs中的第几次遍历。其实也是第几圈。</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.j = j;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> rows = a.length;</span><br><span class="line">        <span class="keyword">int</span> cols = a[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="comment">//每次bfs的时候用来标记节点是否走过</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] book = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    res[i][j] = a[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果此节点不是0，就bfs去寻找0</span></span><br><span class="line">                    res[i][j] = bfs(rows, cols, book, i, j, a);</span><br><span class="line">                    <span class="comment">//每次bfs都是独立的，所以直接每次bfs完清零</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; book.length; k++)</span><br><span class="line">                        Arrays.fill(book[k], <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[][] book, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//新放入的节点</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> Node(i, j, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> times = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; times; k++) &#123;</span><br><span class="line">                Node node = queue.remove();</span><br><span class="line">                <span class="keyword">int</span> ni = node.i;</span><br><span class="line">                <span class="keyword">int</span> nj = node.j;</span><br><span class="line">                <span class="keyword">int</span> nval = node.val;</span><br><span class="line">                <span class="comment">//如果找到0，就直接返回这个点的层数就行了</span></span><br><span class="line">                <span class="keyword">if</span> (a[ni][nj] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//放入新的坐标的时候首先要保证新坐标不越界，并且没有走过</span></span><br><span class="line">                <span class="comment">//上下左右四个方向 上</span></span><br><span class="line">                <span class="keyword">if</span> (ni + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ni + <span class="number">1</span> &lt; rows &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; cols &amp;&amp; !book[ni + <span class="number">1</span>][nj]) &#123;</span><br><span class="line">                    book[ni + <span class="number">1</span>][nj] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//这里放的其实就是下一圈，下一圈的值要+1，相当于走两步</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> Node(ni + <span class="number">1</span>, nj, nval + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//下</span></span><br><span class="line">                <span class="keyword">if</span> (ni - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ni - <span class="number">1</span> &lt; rows &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; cols &amp;&amp; !book[ni - <span class="number">1</span>][nj]) &#123;</span><br><span class="line">                    book[ni - <span class="number">1</span>][nj] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Node(ni - <span class="number">1</span>, nj, nval + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; rows &amp;&amp; nj + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nj + <span class="number">1</span> &lt; cols &amp;&amp; !book[ni][nj + <span class="number">1</span>]) &#123;</span><br><span class="line">                    book[ni][nj + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Node(ni, nj + <span class="number">1</span>, nval + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; rows &amp;&amp; nj - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nj - <span class="number">1</span> &lt; cols &amp;&amp; !book[ni][nj - <span class="number">1</span>]) &#123;</span><br><span class="line">                    book[ni][nj - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Node(ni, nj - <span class="number">1</span>, nval + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] a = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] ints = <span class="keyword">new</span> Solution().updateMatrix(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/01-matrix/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-543. 二叉树的直径</title>
    <url>/2019/10/09/leetcode-543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树</span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line">返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</span><br><span class="line"></span><br><span class="line">注意：两结点之间的路径长度是以它们之间边的数目表示。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始理解的是可以把以根节点为cur的树的直径看做两部分的组成，分别是cur节点的左子树的最大深度加上cur节点的右子树的最大深度，而且要注意到这么做是一定过根节点的，所以就可以求左右子树的最大深度。这个想法求直径的方法倒是对了，但是当cur的右子树内容特别多，而且右子树里面有直径更大的一条路径的话就不对了，所以要把每个节点都这么求一遍，在遍历的过程中找到直径的最大值。</li>
<li>上面的做法其实可以简化，没必要遍历每个节点，然后在每个节点里面求出最大左右子树的深度。其实在求最大深度的过程中，就已经在判断左右子树的最大深度了，所以只需要在递归求最大深度的过程中顺路判断过程中求出的左右子树的最大深度和是不是最大直径。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="求每个节点的左右子树的最大深度，然后求和"><a href="#求每个节点的左右子树的最大深度，然后求和" class="headerlink" title="求每个节点的左右子树的最大深度，然后求和"></a>求每个节点的左右子树的最大深度，然后求和</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    res = <span class="number">-1000000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_maxDepth(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 求cur节点的最大深度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_maxDepth</span><span class="params">(self, cur: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        lnum = <span class="number">0</span></span><br><span class="line">        rnum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求左子树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            lnum = self.recurse_maxDepth(cur.left)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求右子树的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            rnum = self.recurse_maxDepth(cur.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求左右子树的最大深度的最大值，然后加1就是cur这颗树的最大深度。</span></span><br><span class="line">        <span class="keyword">return</span> max(lnum, rnum) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.recurse_diameterOfBinaryTree(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_diameterOfBinaryTree</span><span class="params">(self, cur: TreeNode)</span>:</span></span><br><span class="line">        <span class="comment"># 当递归到叶子节点的时候，最大值应该是0，如果当前记录的值小于0，自然要更新成0</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &gt; self.res:</span><br><span class="line">                self.res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求左子树的最大深度</span></span><br><span class="line">        l1 = self.maxDepth(cur.left)</span><br><span class="line">        <span class="comment"># 求右子树的最大深度</span></span><br><span class="line">        l2 = self.maxDepth(cur.right)</span><br><span class="line">        <span class="comment"># 将两者的和与记录的最大值比较</span></span><br><span class="line">        <span class="keyword">if</span> l1 + l2 &gt; self.res:</span><br><span class="line">            self.res = l1 + l2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以同样的思路继续往左子树递归</span></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            self.recurse_diameterOfBinaryTree(cur.left)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 往右子树递归</span></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            self.recurse_diameterOfBinaryTree(cur.right)</span><br></pre></td></tr></table></figure>

<h2 id="在求最大深度的时候顺便求出最大直径"><a href="#在求最大深度的时候顺便求出最大直径" class="headerlink" title="在求最大深度的时候顺便求出最大直径"></a>在求最大深度的时候顺便求出最大直径</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    res = <span class="number">-10000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.recurse_diameterOfBinaryTree(root)</span><br><span class="line">        <span class="keyword">return</span> max(self.res, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_diameterOfBinaryTree</span><span class="params">(self, cur: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">and</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        lnum = <span class="number">0</span></span><br><span class="line">        rnum = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            lnum = self.recurse_diameterOfBinaryTree(cur.left)</span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            rnum = self.recurse_diameterOfBinaryTree(cur.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求出左右子树的最大深度之后，直接判断是不是最大直径</span></span><br><span class="line">        self.res = max(self.res, lnum + rnum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(lnum, rnum) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-561.数组拆分 I</title>
    <url>/2019/07/23/leetcode-561.%20%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, </span><br><span class="line">例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n 是正整数,范围在 [1, 10000].</span><br><span class="line">数组中的元素范围在 [-10000, 10000].</span><br></pre></td></tr></table></figure>

<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>首先能看出数组长度一定为偶数</li>
<li>其次把数组中的数两两分对，并且从取每对的最小值，并且要这些最小值加起来是最大，就能分析出肯定是每对里面的数越接近越好，相当于你你从每对里面扔一个大数取小数，那就让小数尽可能大，大数尽可能小，但大数还是要大于小数，所以能得出越接近越好，明显排序之后隔一个取一个就OK。</li>
<li>试了一下用优先队列做，先把所有的数都放进去，然后隔一个取一个，虽然过了，但是时间炸了，100ms。应该是创建优先队列和每次优先队列更新最小值的时候花了太多的时间。<br>

</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组做法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//隔一个取一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            sum+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先队列做法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明优先队列</span></span><br><span class="line">        Queue queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">var</span> : a) &#123;</span><br><span class="line">            <span class="comment">//优先队列的入队</span></span><br><span class="line">            queue.add(<span class="keyword">var</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//优先队列的出队</span></span><br><span class="line">            Integer temp = (Integer)queue.remove();</span><br><span class="line">            <span class="comment">//隔一个取一个</span></span><br><span class="line">            <span class="keyword">if</span>(flag%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum+=temp;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(arrayPairSum(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/array-partition-i/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/array-partition-i/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-566.重塑矩阵</title>
    <url>/2019/07/26/leetcode-566.%20%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</span><br><span class="line"></span><br><span class="line">给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</span><br><span class="line"></span><br><span class="line">重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</span><br><span class="line"></span><br><span class="line">如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定矩阵的宽和高范围在 [1, 100]。</span><br><span class="line">给定的 r 和 c 都是正数。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>说白了就是把一个矩阵的值按行分配给一个指定列数和行数的新矩阵。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.length*a[<span class="number">0</span>].length &lt; r*c)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> ni=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nj=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                res[ni][nj] = a[i][j];</span><br><span class="line">                nj++;</span><br><span class="line">                <span class="comment">//列数满了之后列数清零，然后切换行</span></span><br><span class="line">                <span class="keyword">if</span> (nj &gt;= c)&#123;</span><br><span class="line">                    nj %= c;</span><br><span class="line">                    ni++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>没得什么知识点</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/reshape-the-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reshape-the-matrix/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-563. 二叉树的坡度</title>
    <url>/2019/12/17/leetcode-563.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，计算整个树的坡度。</span><br><span class="line"></span><br><span class="line">一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</span><br><span class="line"></span><br><span class="line">整个树的坡度就是其所有节点的坡度之和。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">结点的坡度 2 : 0</span><br><span class="line">结点的坡度 3 : 0</span><br><span class="line">结点的坡度 1 : |2-3| = 1</span><br><span class="line">树的坡度 : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任何子树的结点的和不会超过32位整数的范围。</span><br><span class="line">坡度的值不会超过32位整数的范围。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>自然就是每次遍历节点的时候求左右节点的所有子树和，然后求这两个的绝对值差，加起来就是啦</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于保留全部的坡度和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归求cur以及cur的子树的所有的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left==<span class="keyword">null</span> &amp;&amp; cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            lsum = dfs(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rsum = dfs(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算坡度</span></span><br><span class="line">        res = res+Math.abs(lsum-rsum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意求的是全部的子树和,要加上cur.val</span></span><br><span class="line">        <span class="keyword">return</span> lsum+rsum+cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>注意转化问题，坡度和其实就是求左右子树和的绝对值差</li>
<li>注意子树和要加上cur.val的值,以前没有做过子树和的问题。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-tilt/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-tilt/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-567. 字符串的排列</title>
    <url>/2019/11/06/leetcode-567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</span><br><span class="line"></span><br><span class="line">换句话说，第一个字符串的排列之一是第二个字符串的子串。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入的字符串只包含小写字母</span><br><span class="line">两个字符串的长度都在 [1, 10,000] 之间</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>正常的超时想法肯定是找到字符串的全排列，然后逐个判断主字符串里面有没有。</li>
<li>采用窗口的模式，判断在s2中长度为s1长度的窗口的哈希表和s1本身的哈希表是否一样。官方题解写的很好。窗口滑动。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s1)&gt;len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先哪两个哈希表，l1表示s1整个的一个哈希表,l2表示s2每次滑动窗口产生的哈希表</span></span><br><span class="line">        l1 = []</span><br><span class="line">        l2 = []</span><br><span class="line">        <span class="comment"># 因为是字符对应的哈希表，所以长度设置为26就好了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">26</span>):</span><br><span class="line">            l1.append(<span class="number">0</span>)</span><br><span class="line">            l2.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 给两个哈希表赋初始值，窗口长度为s1的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s1)):</span><br><span class="line">            <span class="comment"># ord('a')相当于是获得a字符的ascii码，这就相当于java</span></span><br><span class="line">            <span class="comment"># 中的l1[s1[i]-'a']，只不过python得显示的给ascii计算</span></span><br><span class="line">            l1[ord(s1[i]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">            l2[ord(s2[i]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每次先比较当前窗口里面的哈希值和s1中的哈希值是否一样，然后s2每次滑动窗口，每次滑动一个</span></span><br><span class="line">        <span class="comment"># 字符，滑动之后更新窗口中的哈希值，更新的地方主要有两个，增加新字符的哈希值，减去旧字符</span></span><br><span class="line">        <span class="comment">#  的哈希值。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s2) - len(s1)):</span><br><span class="line">            <span class="keyword">if</span> l1 == l2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新窗口，添加新字符的哈希值</span></span><br><span class="line">            l2[ord(s2[i + len(s1)]) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 减少旧字符的哈希值</span></span><br><span class="line">            l2[ord(s2[i]) - ord(<span class="string">'a'</span>)] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为这里窗口最后一次的更新没有进行比较，所以这里在比较一次。</span></span><br><span class="line">        <span class="keyword">return</span> l1 == l2</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>字符串中滑动窗口貌似经常用</p>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutation-in-string/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-589. N叉树的前序遍历</title>
    <url>/2020/09/07/leetcode-589.%20N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个 N 叉树，返回其节点值的前序遍历。</span><br><span class="line"></span><br><span class="line">例如，给定一个 3叉树 :</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回其前序遍历: [1,3,5,6,2,4]。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>前序的非递归好写。先遍历栈顶节点，然后右孩子入栈，左孩子入栈。N叉树同理。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(ans, root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; ans, Node cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child : cur.children) &#123;</span><br><span class="line">                dfs(ans, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//查看栈顶</span></span><br><span class="line">            Node temp = stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">            ans.add(temp.val);</span><br><span class="line">            <span class="comment">//从最右面的孩子开始入栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.push(temp.children.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>前序的非递归好说，每次访问栈顶元素，从最右面的孩子开始入栈。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-58. 最后一个单词的长度</title>
    <url>/2019/11/26/leetcode-58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个仅包含大小写字母和空格 &apos; &apos; 的字符串，返回其最后一个单词的长度。</span><br><span class="line"></span><br><span class="line">如果不存在最后一个单词，请返回 0 。</span><br><span class="line"></span><br><span class="line">说明：一个单词是指由字母组成，但不包含任何空格的字符串。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>从末尾开始计数就行了</li>
<li>需要注意的是如果末尾有空格的话，是不能算的，因为这道题比较简单，只有3中字符：大写英文，小写英文，空格。所以注意这个特殊情况就行了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># flag为1表示末尾是空格的时候不用停止循环</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        l = len(s) - <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 当末尾是空格，但是flag是1就不用返回值，flag为1表示末尾的空格是不算停止的</span></span><br><span class="line">            <span class="keyword">if</span> s[l] == <span class="string">' '</span> <span class="keyword">and</span> flag == <span class="number">1</span>:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 这就表示最后一个单词已经遍历完</span></span><br><span class="line">            <span class="keyword">if</span> s[l] == <span class="string">' '</span> <span class="keyword">and</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># 说明记录到了单词数，这里flag就可以置1了，说明这之后再遇到的空格就不是末尾的空格了，而是单词</span></span><br><span class="line">            <span class="comment"># 和单词之间的空格了</span></span><br><span class="line">            <span class="keyword">if</span> s[l] != <span class="string">' '</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/length-of-last-word/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-617. 合并二叉树</title>
    <url>/2019/11/22/leetcode-617.%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</span><br><span class="line"></span><br><span class="line">你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    / \</span><br><span class="line">	   4   5</span><br><span class="line">	  / \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意: 合并必须从两个树的根节点开始。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>说到二叉树的遍历，就一定少不了二叉树的前序、后序、中序遍历，这里可以通过遍历t1或者t2的任意一棵树来产生一颗新树。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1: TreeNode, t2: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_mergeTrees(t1, t2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据t1和t2的当前节点产生t1和t2合并后的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_mergeTrees</span><span class="params">(self, t1: TreeNode, t2: TreeNode)</span>:</span></span><br><span class="line">        <span class="comment"># 两者都为空就是返回空</span></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="literal">None</span> <span class="keyword">and</span> t2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 有一个是空就返回不是空的那个</span></span><br><span class="line">        <span class="comment"># 因为有一个存在、另一个不存在的情况就说明没有覆盖的情况，所以自然就直接返回存在的</span></span><br><span class="line">        <span class="comment"># 枝就行了</span></span><br><span class="line">        <span class="keyword">elif</span> t1 != <span class="literal">None</span> <span class="keyword">and</span> t2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        <span class="keyword">elif</span> t1 == <span class="literal">None</span> <span class="keyword">and</span> t2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果两者都不是空，就存在覆盖的情况了，所以这里就得重新递归</span></span><br><span class="line">        t3 = TreeNode(t1.val + t2.val)</span><br><span class="line">        t3.left = self.recurse_mergeTrees(t1.left, t2.left)</span><br><span class="line">        t3.right = self.recurse_mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> t3</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>合并二叉树具体到某个节点的时候，只有当两个节点都有值得时候才存在覆盖得情况，如果一个有另一个没有是不存在覆盖得情况得。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-623. 在二叉树中增加一行</title>
    <url>/2020/02/12/leetcode-623.%20%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。</span><br><span class="line"></span><br><span class="line">添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，</span><br><span class="line">为 N 创建两个值为 v 的左子树和右子树。</span><br><span class="line"></span><br><span class="line">将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。</span><br><span class="line"></span><br><span class="line">如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">二叉树如下所示:</span><br><span class="line">       4</span><br><span class="line">     /   \</span><br><span class="line">    2     6</span><br><span class="line">   / \   / </span><br><span class="line">  3   1 5   </span><br><span class="line"></span><br><span class="line">v = 1</span><br><span class="line"></span><br><span class="line">d = 2</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">       4</span><br><span class="line">      / \</span><br><span class="line">     1   1</span><br><span class="line">    /     \</span><br><span class="line">   2       6</span><br><span class="line">  / \     / </span><br><span class="line"> 3   1   5</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">二叉树如下所示:</span><br><span class="line">      4</span><br><span class="line">     /   </span><br><span class="line">    2    </span><br><span class="line">   / \   </span><br><span class="line">  3   1    </span><br><span class="line"></span><br><span class="line">v = 1</span><br><span class="line"></span><br><span class="line">d = 3</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">      4</span><br><span class="line">     /   </span><br><span class="line">    2</span><br><span class="line">   / \    </span><br><span class="line">  1   1</span><br><span class="line"> /     \  </span><br><span class="line">3       1</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>给第d行添加一行，那么直接bfs到第d-1行，对d-1行的节点进行操作，操作完之后退出bfs就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">            TreeNode res = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            res.left = root;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//当bfs到第d-1行的时候</span></span><br><span class="line">            <span class="keyword">if</span> (depth == d - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = queue.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                    <span class="comment">//对于第d-1行的每个节点</span></span><br><span class="line">                    TreeNode remove = queue.remove();</span><br><span class="line">                    <span class="comment">//根据题意造新节点</span></span><br><span class="line">                    TreeNode l = remove.left;</span><br><span class="line">                    TreeNode r = remove.right;</span><br><span class="line">                    <span class="comment">//然后让原来的第d行的节点连接上新造的节点</span></span><br><span class="line">                    remove.left = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">                    remove.right = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">                    remove.left.left = l;</span><br><span class="line">                    remove.right.right = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是第d-1行就正常bfs</span></span><br><span class="line">            <span class="keyword">int</span> t = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                TreeNode remove = queue.remove();</span><br><span class="line">                <span class="keyword">if</span> (remove.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(remove.left);</span><br><span class="line">                <span class="keyword">if</span> (remove.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(remove.right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/add-one-row-to-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-one-row-to-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-628.三个数的最大乘积</title>
    <url>/2019/08/01/leetcode-628.%20%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</span><br><span class="line">输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>先用暴力试一发，i,j,k枚举所有互不为同一个数来求最大值，不出所料超时</li>
<li>然后又想了个法子，把所有的数用根据绝对值排序，首先直接去最后两位的乘积res，根据后两位的乘积的正负来从倒数第三位开始往前找是正数还是负数的第三个数，如果res是负数，就从倒数第三位开始往前找负的数，因为已经绝对值排好序了，就找负数就可以，当res是正数的时候同理。虽然结果正确但还是超时，想了一下如果存在一种情况：当找负数的时候，如果就第一位是负数，也就是说当从倒数第三位开始往前找时，只有除了第一位是负数，剩下的都是正数的时候，几乎跑了一遍O(n)，明显是浪费时间的。</li>
<li>然后又想：无非求最大值，那就把数组排个序，然后找最后三位和前两位和最后一位的乘积。</li>
<li>上一种做法其实可以优化，因为最后的结果其实只用到了5个数，也就是最大的三个和最小的两个，可以用5个变量存储这5个数，用一个O(n)的时间就可以省去一个排序的时间，找到这5个数之后做法不变</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i，j，k枚举所有的数求最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=j+<span class="number">1</span>; k&lt;a.length; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i]*a[j]*a[k] &gt; max)&#123;</span><br><span class="line">                        max = a[i]*a[j]*a[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绝对值排序"><a href="#绝对值排序" class="headerlink" title="绝对值排序"></a>绝对值排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据绝对值排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;a.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(a[j]) &gt; Math.abs(a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    <span class="keyword">int</span> t = a[j];</span><br><span class="line">                    a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到后两位的乘积</span></span><br><span class="line">        res*=a[a.length-<span class="number">1</span>];</span><br><span class="line">        res*=a[a.length-<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//从倒数第三位开始找最大乘积所需要的第三个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = a.length-<span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果res小于0，那第三个数就找负数</span></span><br><span class="line">        <span class="keyword">if</span> (res &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找负数,索引得大于0</span></span><br><span class="line">            <span class="keyword">while</span> (cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//因为是找负数，所以正数就不看</span></span><br><span class="line">                <span class="keyword">if</span> (a[cnt]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                    <span class="comment">//continue没什么用，但是是习惯</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找正数</span></span><br><span class="line">            <span class="keyword">while</span> (cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//因为是找正数所以负数不看</span></span><br><span class="line">                <span class="keyword">if</span> (a[cnt]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为此时的第三个数是已经找到的，直接返回就OK</span></span><br><span class="line">        <span class="keyword">return</span> res*a[cnt];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序找5个数"><a href="#排序找5个数" class="headerlink" title="排序找5个数"></a>排序找5个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res1 = a[a.length-<span class="number">1</span>]*a[a.length-<span class="number">2</span>]*a[a.length-<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> res2 = a[<span class="number">0</span>]*a[<span class="number">1</span>]*a[a.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res1&gt;res2? res1:res2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="O-n-找5个数"><a href="#O-n-找5个数" class="headerlink" title="O(n)找5个数"></a>O(n)找5个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最大的数</span></span><br><span class="line">        <span class="keyword">int</span> max1 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//第二大的数</span></span><br><span class="line">        <span class="keyword">int</span> max2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//第三大的数</span></span><br><span class="line">        <span class="keyword">int</span> max3 = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最小的数</span></span><br><span class="line">        <span class="keyword">int</span> min1 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//第二小的数</span></span><br><span class="line">        <span class="keyword">int</span> min2 = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="comment">//画个坐标轴就OK，当i比最大的数都要大的时候，第三大变成第二大，第二大变成第一大，第一大变成i，下面的变化同理</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;=max1)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;=max2 &amp;&amp; i&lt;max1)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;=max3 &amp;&amp; i&lt;max2)&#123;</span><br><span class="line">                max3 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i&lt;=min1)&#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i&lt;=min2 &amp;&amp; i&gt;min1) &#123;</span><br><span class="line">                min2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max1*max2*max3 &gt; min1*min2*max1 ? max1*max2*max3 : min1*min2*max1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>当只需要排序后的几个数的时候，不用全部排序，可以遍历一遍，在遍历的时候找到对应所需要的数</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-three-numbers/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>643. 子数组最大平均数 I</title>
    <url>/2019/09/10/leetcode-643.%20%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0I/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出: 12.75</span><br><span class="line">解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= k &lt;= n &lt;= 30,000。</span><br><span class="line">所给数据范围 [-10,000，10,000]。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li><p>最开始的想法是从头遍历每一个i，然后从每个i开始往后找共k个元素，然后把这些元素求和，求完和之后进行求平均数然后再与记录的最大的平均数进行比较，不出所料的用python就会超时</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超时代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; float:</span></span><br><span class="line">        res = <span class="number">-1000000.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums) - k + <span class="number">1</span>):</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, i + k):</span><br><span class="line">                sum += nums[j]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sum / k &gt; res:</span><br><span class="line">                res = sum / k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>仔细分析上面的方法发现，如果k特别大的话上面的方法就相当于O(n^2)的算法了，于是很自然的想办法取消掉第二层的k次的循环。因为是连续的子数组，而且还是要从头开始寻找的，这里提出一个名字叫做滑动窗口来计算和，也就是算出一个长度为k的和，然后每次后移的之后把当前的值加到窗口中，再把上一个窗体的第一个值减去，就实现了窗口的移动。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="窗口移动"><a href="#窗口移动" class="headerlink" title="窗口移动"></a>窗口移动</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="comment"># 拿到第一个窗体</span></span><br><span class="line">        sum1 = sum(nums[<span class="number">0</span>:k])</span><br><span class="line">        res = sum1 / k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)):</span><br><span class="line">            <span class="comment"># 加上新的一个值</span></span><br><span class="line">            sum1 += nums[i]</span><br><span class="line">            <span class="comment"># 再减去原来窗体的第一个值</span></span><br><span class="line">            sum1 -= nums[i - k]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 拿到res的最大值</span></span><br><span class="line">            res = max(res, sum1 / k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>每次求最大值的时候直接用max()函数，不用if</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-average-subarray-i/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-637. 二叉树的层平均值</title>
    <url>/2020/02/14/leetcode-637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出: [3, 14.5, 11]</span><br><span class="line">解释:</span><br><span class="line">第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>bfs统计每层的平均数就完事了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">//常规bfs</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = queue.size();</span><br><span class="line">            <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                TreeNode remove = queue.remove();</span><br><span class="line">                <span class="comment">//统计每层的数字和</span></span><br><span class="line">                d += remove.val;</span><br><span class="line">                <span class="comment">//统计每层节点个数</span></span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (remove.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(remove.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (remove.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(remove.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算平均数</span></span><br><span class="line">            res.add(d / cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-63. 不同路径 II</title>
    <url>/2020/07/06/leetcode-63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</span><br><span class="line"></span><br><span class="line">机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角</span><br><span class="line">（在下图中标记为“Finish”）。</span><br><span class="line"></span><br><span class="line">现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>dp最好写，dp[i][j]表示从nums[0][0]到nums[i][j]的走法种数，而且最简单的是对于第一行的所有位置dp[0][j]，在没有遇到障碍物之前都是1，遇到障碍物时和遇到障碍物后都是0，因为第一行的每一个位置都只能从第一行的左面走过来，自然最大为1，当当前或者左面都是障碍物的时候，这个位置就走不到了，自然就是0了，第一列也是同理。</li>
<li>而对于每一个dp[i][j]，i从1到r-1，j从1到c-1，中间的位置，自然是dp[i][j] = dp[i-1][j]+dp[i][j-1]，因为总的方向是向右和向下，每一个格子走法要么是从上面走来的，要么是从左面走来的，所以是这样，不过要注意当nums[i][j]是障碍的时候，dp[i][j]为0，分析中间的格子不用分析左面或者上面是不是障碍物，因为如果时障碍物，dp为0，不影响dp[i][j]最后的值。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = nums.size();</span><br><span class="line">        <span class="keyword">int</span> c = nums[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dp[r][c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            fill(dp[i], dp[i] + c, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给所有的第一列赋值为1</span></span><br><span class="line">        <span class="keyword">bool</span> flag1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="comment">//只要不是障碍物,当遇见障碍物的时候值都变0，因为</span></span><br><span class="line">            <span class="comment">//当上一行时障碍物的时候，这一行就不可达到了</span></span><br><span class="line">            <span class="keyword">if</span> (flag1 &amp;&amp; nums[i][<span class="number">0</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag1 = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给所有的第一列的赋值为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="comment">//只要不是障碍物,列同理</span></span><br><span class="line">            <span class="keyword">if</span> (flag2 &amp;&amp; nums[<span class="number">0</span>][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag2 = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于中间的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="comment">//如果是障碍物</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//如果不是障碍物</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//因为这个格子一定是从左面或者上面走过来的</span></span><br><span class="line">                    <span class="comment">//所以就把左面和上面的走法加回来就行</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> dp[r - <span class="number">1</span>][c - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>这种寻路问题最好的做法就是dp，要分别注意第一行和第一列的情况，中间的情况。</li>
<li>当有障碍物的时候，要注意不可达的情况。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>寻路问题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-64. 最小路径和</title>
    <url>/2019/12/19/leetcode-64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span><br><span class="line"></span><br><span class="line">说明：每次只能向下或者向右移动一步。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的是递归，每次向右、向下递归,越界的时候停止递归，到达终点的时候计算路径和，但是这个方法超时了。</li>
<li>做法自然是dp，用dp[i][j]表示从grid[0][0]到grid[i][j]的最短路径和,那么当走到的点i=0的时候,也就是最上面一行,到达这一行的走法只能是从这个点的左边那一列走过来,此时状态转移方程是dp[i][j] = grid[i][j]+dp[i][j-1]，同样的,在j=0的时候,也是在边界上,此时状态转移方程是dp[i][j] = grid[i][j]+dp[i-1][j]。当走到不是边界上的点时,也就是i与j都不是0的时候,此时为了最短路径,而又因为dp[i][j]的旁边的dp[i-1][j]和dp[i][j-1]都已经确定了是最短的了,那就需要选择一个最小的就行了,那么此时的状态转移方程就是dp[i][j] = grid[i][j]+min(dp[i-1][j],dp[i][j-1])</li>
<li>二维dp完成以后,自然就可以考虑一下一维dp。可以发现,每次求dp[i][j],每次求第i行的时候只需要第i-1行的内容,而且第一行需要特殊处理,求第一行以下的第一列去要特殊处理,剩下的都很简单。于是有状态转移方程：<ol>
<li>当时i=0时,j=0时dp[j] = grid[i][j]。</li>
<li>当时i=0时,j&gt;0时dp[j] = grid[i][j]+dp[j-1]。</li>
<li>当i&gt;0时,j=0时dp[j] = dp[j]+grid[i][j]</li>
<li>当i&gt;0时,j&gt;0时dp[j] = grid[i][j] + min(dp[j],dp[j-1])</li>
</ol>
</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//m是横坐标的终点,n是纵坐标的终点</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m, n, grid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> tj, <span class="keyword">int</span> temp, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//越界判断</span></span><br><span class="line">        <span class="keyword">if</span> (ti &gt; m || tj &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到达终点判断</span></span><br><span class="line">        <span class="keyword">if</span> (ti == m &amp;&amp; tj == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp + grid[ti][tj] &lt; res) &#123;</span><br><span class="line">                res = temp + grid[ti][tj];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右、向下进行递归</span></span><br><span class="line">        dfs(ti + <span class="number">1</span>, tj, temp + grid[ti][tj], m, n, grid);</span><br><span class="line">        dfs(ti, tj + <span class="number">1</span>, temp + grid[ti][tj], m, n, grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">//起点不用看</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = grid[i][j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当在最上面的时候,最上面的所有点都只能从当前点的左边走过来</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//所以状态转移方程就是很简单</span></span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在最左面的时候也是同理</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当i!=0&amp;&amp;j!=0的时候,当前格子的值是由左面和上面那个格子进行选择的</span></span><br><span class="line">                dp[i][j] = grid[i][j] + Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一维dp"><a href="#一维dp" class="headerlink" title="一维dp"></a>一维dp</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一维dp,且长度为原数组的列长</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//当是第一行的时候</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="comment">//当是起点的时候</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[j] = grid[i][j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//当时第一行的其他点的时候</span></span><br><span class="line">                        dp[j] = grid[i][j] + dp[j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当不是第一行的时候</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="comment">//当是第一列的时候</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[j] = dp[j] + grid[i][j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//当不是第一列的时候</span></span><br><span class="line">                        dp[j] = grid[i][j] + Math.min(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>状态转移方程最好从头开始模拟一遍,像这种向下、向右走都是有规律的。</li>
<li>尝试二维转一维。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-647. 回文子串</title>
    <url>/2020/08/19/leetcode-647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</span><br><span class="line"></span><br><span class="line">具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>自然可以二重循环遍历到所有子串，然后双指针判断是否是回文。</li>
<li>另外，像这种找所有回文子串的题目，自然是可以用dp,复杂度是O(N^2)，双层循环，外层循环枚举每一个终点，内层循环都从头开始，为什么外部循环要枚举每一个终点呢，为了dp，因为终点字符是不断后移的，所以当s[i]==s[j]并且dp[i+1][j-1]==true的时候就能直接说明dp[i][j] = true。这个枚举终点就方便在这里，主要是枚举起点的状态转移方程不会写。太笨了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="双重-双指针"><a href="#双重-双指针" class="headerlink" title="双重+双指针"></a>双重+双指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//双重循环遍历到所有的字符串的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ishuiwen(s.substr(i, j - i + <span class="number">1</span>)))</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ishuiwen</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">""</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> dp[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双重循环拿到所有子串</span></span><br><span class="line">        <span class="comment">//枚举每一个终点,前闭后闭区间[l,r]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; len; r++) &#123;</span><br><span class="line">            <span class="comment">//对于每个终点起点自然是0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= r; l++) &#123;</span><br><span class="line">                <span class="comment">//注意s[r]是针对于转移来的，当s[r]==s[l]，并且s[l+1...r-1]是回文时，s[r...l]自然也是回文</span></span><br><span class="line">                <span class="comment">//而且如果s[l...r]长度小于等于3的时候，而且首字符和末尾字符也相等，此时一定是回文。</span></span><br><span class="line">                <span class="keyword">if</span> ((s[r] == s[l]) &amp;&amp; ((r - l + <span class="number">1</span> &lt;= <span class="number">3</span>) || (dp[l + <span class="number">1</span>][r - <span class="number">1</span>]))) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    dp[l][r] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>以后枚举子串，就从尾部枚举，因为可以使用状态转移</li>
<li>s[i]==s[j] &amp;&amp; (dp[i+1][j-1] || j-i+1&lt;=3)? dp[i][j]=true:false;</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindromic-substrings/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>好题</tag>
        <tag>字符串</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-650. 只有两个键的键盘</title>
    <url>/2020/02/12/leetcode-650.%20%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最初在一个记事本上只有一个字符 &apos;A&apos;。你每次可以对这个记事本进行两种操作：</span><br><span class="line"></span><br><span class="line">Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</span><br><span class="line">Paste (粘贴) : 你可以粘贴你上一次复制的字符。</span><br><span class="line">给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 &apos;A&apos;。输出能够打印出 n 个 &apos;A&apos; 的最少操作次数。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 &apos;A&apos;。</span><br><span class="line">第 1 步, 我们使用 Copy All 操作。</span><br><span class="line">第 2 步, 我们使用 Paste 操作来获得 &apos;AA&apos;。</span><br><span class="line">第 3 步, 我们使用 Paste 操作来获得 &apos;AAA&apos;。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>要注意到这道题的是不能部分赋值的，并且是要复制的话必须赋值全部的内容，所以可以发现，<ol>
<li>当n是质数的时候，因为n没有因子，所以n不能通过大于1的小部分拼成，而且还必须是用1拼成，所以n的返回值就是n，因为要赋值一次，拼接n-1次，操作数总共n次。</li>
<li>当n不是质数的时候，因为n有因子，所以选取一个最大的因子i，假设现在已经有一个长度为i的部分了，那么将这部分赋值，然后赋值n/i-1次，就能得到n的效果，而至于获取长度为i的过程，其实就是得到n的过程，所以这里可以得到f(n) = f(i)+n/i，其中i是n的最大因子(非1非n)。</li>
</ol>
</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="质数或者非质数"><a href="#质数或者非质数" class="headerlink" title="质数或者非质数"></a>质数或者非质数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊判断，如果是1是不需要返回值的</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找n的最大因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//如果找到了i</span></span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> minSteps(i) + n / i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>质数是一个使用很多次的概念</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/2-keys-keyboard/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/2-keys-keyboard/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-654. 最大二叉树</title>
    <url>/2019/11/09/leetcode-654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</span><br><span class="line"></span><br><span class="line">二叉树的根是数组中的最大元素。</span><br><span class="line">左子树是通过数组中最大值左边部分构造出的最大二叉树。</span><br><span class="line">右子树是通过数组中最大值右边部分构造出的最大二叉树。</span><br><span class="line">通过给定的数组构建最大二叉树，并且输出这个树的根节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,2,1,6,0,5]</span><br><span class="line">输出：返回下面这棵树的根节点：</span><br><span class="line"></span><br><span class="line">      6</span><br><span class="line">    /   \</span><br><span class="line">   3     5</span><br><span class="line">    \    / </span><br><span class="line">     2  0   </span><br><span class="line">       \</span><br><span class="line">        1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">给定的数组的大小在 [1, 1000] 之间。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 题目已经很明显了，用递归，要求把整个数组的最大值的左半边成为数组的左子树，</span><br><span class="line">右半边成为右子树。那么一定不能少的操作有：</span><br><span class="line">   1. 递归创建左子树</span><br><span class="line">   2. 递归创建右子树</span><br><span class="line">   3. 找到当前递归的数组中的最大值</span><br><span class="line">然后就可以写递归函数啦。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.createMaxTree(<span class="number">0</span>, len(nums) - <span class="number">1</span>, nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归创建数组中l~r区间的最大二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createMaxTree</span><span class="params">(self, l: int, r: int, nums: list)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 递归边界</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[l])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到区间l~r的最大值的索引</span></span><br><span class="line">        maxIndex = l</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[maxIndex]:</span><br><span class="line">                maxIndex = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建当前节点</span></span><br><span class="line">        cur = TreeNode(nums[maxIndex])</span><br><span class="line">        <span class="comment"># 递归创建左右子节点</span></span><br><span class="line">        cur.left = self.createMaxTree(l, maxIndex - <span class="number">1</span>, nums)</span><br><span class="line">        cur.right = self.createMaxTree(maxIndex + <span class="number">1</span>, r, nums)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-binary-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-657. 机器人能否返回原点</title>
    <url>/2020/08/28/leetcode-657.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。</span><br><span class="line"></span><br><span class="line">移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。</span><br><span class="line"></span><br><span class="line">注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;UD&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，</span><br><span class="line">因此它最终回到它开始的原点。因此，我们返回 true。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LL&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的</span><br><span class="line">距离。我们返回 false，因为它在移动结束时没有返回原点。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>给的字符串的每个字符代表向4个方向移动。只需要看向左和向右的幅度相同，向下和向上的幅度相同。即l的个数与r的个数相同，u的个数与d的个数相同。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c:moves) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'R'</span>) &#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'L'</span>) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'U'</span>) &#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/robot-return-to-origin/</a>  </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-66. 加一</title>
    <url>/2019/08/02/leetcode-66.%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</span><br><span class="line"></span><br><span class="line">最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</span><br><span class="line"></span><br><span class="line">你可以假设除了整数 0 之外，这个整数不会以零开头</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>普通情况肯定就不说了，末尾加一，但是肯定存在一种特殊情况，如果末位是9，那么末位就变成0，然后上一位进1，那就模拟一下，从最后一位开始进1，如果不是0那就说明这个数组已经加1完成了，就不用再加了，如果末位这个数进1之后成了0，那就表明上一位就要加1，那么就跑到上一位那里加1，到上一位同样也是这么做。如果就这样走出了循环，就说明这个数组里的值全都是9，这时只需要把数组的长度加一然后首位置变成1就OK了。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从末位开始加一，每一位加完之后都看看是不是需要进位，如果进位就跑到上一位来进行相同的处理，不进位就表名数组加一已经完成，直接返回结果就OK。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            a[i]++;</span><br><span class="line">            a[i]%=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里说明原数组里面的所有值都是9，这时候每一位都进位完了，只需要把数组长度加一然后把首位变成1就行了</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[a.length+<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(a,<span class="number">0</span>,res,<span class="number">1</span>,a.length);</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>有时候多想想for循环倒着用。</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-717. 1比特与2比特字符</title>
    <url>/2020/02/15/leetcode-682.%20%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你现在是棒球比赛记录员。</span><br><span class="line">给定一个字符串列表，每个字符串可以是以下四种类型之一：</span><br><span class="line">1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。</span><br><span class="line">2. &quot;+&quot;（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。</span><br><span class="line">3. &quot;D&quot;（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。</span><br><span class="line">4. &quot;C&quot;（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</span><br><span class="line"></span><br><span class="line">每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。</span><br><span class="line">你需要返回你在所有回合中得分的总和。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出: 30</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到2分。总和是：7。</span><br><span class="line">操作1：第2轮的数据无效。总和是：5。</span><br><span class="line">第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。</span><br><span class="line">第4轮：你可以得到5 + 10 = 15分。总数是：30。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出: 27</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到-2分。总数是：3。</span><br><span class="line">第3轮：你可以得到4分。总和是：7。</span><br><span class="line">操作1：第3轮的数据无效。总数是：3。</span><br><span class="line">第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。</span><br><span class="line">第5轮：你可以得到9分。总数是：8。</span><br><span class="line">第6轮：你可以得到-4 + 9 = 5分。总数是13。</span><br><span class="line">第7轮：你可以得到9 + 5 = 14分。总数是27。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>遇到字符就处理以前的数字，而且还是倒序，而且每次处理的都是最后面的数字，明显就是一个栈。遇到非数字的字母对栈顶处理就好了，然后再把处理好的数放到栈顶就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="comment">//D是对上一轮的数字乘2，上一轮的数字也就是栈顶</span></span><br><span class="line">            <span class="keyword">if</span> (s[i].equals(<span class="string">"D"</span>)) &#123;</span><br><span class="line">                res += stack.peek() * <span class="number">2</span>;</span><br><span class="line">                stack.push(stack.peek() * <span class="number">2</span>);</span><br><span class="line">            <span class="comment">//c是减去上一轮数字</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i].equals(<span class="string">"C"</span>)) &#123;</span><br><span class="line">                res -= stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">            <span class="comment">//加号同理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i].equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t1 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> t2 = stack.peek();</span><br><span class="line">                stack.push(t1);</span><br><span class="line">                stack.push(t1 + t2);</span><br><span class="line">                res = res + t1 + t2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//数字则正常放数</span></span><br><span class="line">                stack.push(Integer.valueOf(s[i]));</span><br><span class="line">                res += Integer.valueOf(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] s = &#123;<span class="string">"5"</span>, <span class="string">"2"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"+"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Solution().calPoints(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>遇到对最新的状态进行处理的时候可以用栈处理</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/baseball-game/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-661.图片平滑器</title>
    <url>/2019/07/30/leetcode-661.%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，</span><br><span class="line">平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[1,1,1],</span><br><span class="line"> [1,0,1],</span><br><span class="line"> [1,1,1]]</span><br><span class="line">输出:</span><br><span class="line">[[0, 0, 0],</span><br><span class="line"> [0, 0, 0],</span><br><span class="line"> [0, 0, 0]]</span><br><span class="line">解释:</span><br><span class="line">对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0</span><br><span class="line">对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0</span><br><span class="line">对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定矩阵中的整数范围为 [0, 255]。</span><br><span class="line">矩阵的长和宽的范围均为 [1, 150]。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>明显遍历a的每个点，然后在每个点进行一次计算然后赋值给新数组就OK了</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] imageSmoother(<span class="keyword">int</span>[][] a) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length][a[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//t记录每个数周围的所有数</span></span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//k记录一共计算了几次</span></span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = -<span class="number">1</span>; x&lt;=<span class="number">1</span>; x++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = -<span class="number">1</span>; y &lt;= <span class="number">1</span>; y++)&#123;</span><br><span class="line">                        <span class="comment">//新坐标</span></span><br><span class="line">                        <span class="keyword">int</span> ni = i+x;</span><br><span class="line">                        <span class="keyword">int</span> nj = j+y;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//判断新坐标是否在界内</span></span><br><span class="line">                        <span class="keyword">if</span> (ni&gt;=<span class="number">0</span> &amp;&amp; ni&lt;a.length &amp;&amp; nj&gt;=<span class="number">0</span> &amp;&amp; nj&lt;a[<span class="number">0</span>].length)&#123;</span><br><span class="line">                            t+=a[ni][nj];</span><br><span class="line">                            k++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                b[i][j] = t/k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/image-smoother/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/image-smoother/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-67. 二进制求和</title>
    <url>/2019/11/26/leetcode-67.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个二进制字符串，返回他们的和（用二进制表示）。</span><br><span class="line"></span><br><span class="line">输入为非空字符串且只包含数字 1 和 0。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>和两数相加的原理一样，用两个下标分别记录遍历到当前字符串的位置上的值，然后计算最后这两位算出的这一位的值和进位，然后拼接字符串就行了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, s1: str, s2: str)</span> -&gt; str:</span></span><br><span class="line">        c1 = len(s1) - <span class="number">1</span></span><br><span class="line">        c2 = len(s2) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.recurse_addBinary(s1, c1, s2, c2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算s1的c1位置上和s2的c2位置上的值并且加上extra</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_addBinary</span><span class="params">(self, s1: str, c1: int, s2: str, c2: int, extra: int)</span>:</span></span><br><span class="line">        <span class="comment"># 同两数相加那个题，为了确保最后一位，当c1、c2都遍历完，但是还有进位的情况，所以要特判一下</span></span><br><span class="line">        <span class="keyword">if</span> c1 &lt; <span class="number">0</span> <span class="keyword">and</span> c2 &lt; <span class="number">0</span> <span class="keyword">and</span> extra != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> str(extra)</span><br><span class="line">        <span class="comment"># 这就是当两个字符串都遍历完的情况没有特判的时候</span></span><br><span class="line">        <span class="keyword">if</span> c1 &lt; <span class="number">0</span> <span class="keyword">and</span> c2 &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># v1的值</span></span><br><span class="line">        v1 = <span class="number">0</span></span><br><span class="line">        <span class="comment"># v2的值</span></span><br><span class="line">        v2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取到v1的值并且c1指针前移一位</span></span><br><span class="line">        <span class="keyword">if</span> c1 &gt;= <span class="number">0</span>:</span><br><span class="line">            v1 = int(s1[c1])</span><br><span class="line">            c1 -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># c2同理</span></span><br><span class="line">        <span class="keyword">if</span> c2 &gt;= <span class="number">0</span>:</span><br><span class="line">            v2 = int(s2[c2])</span><br><span class="line">            c2 -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或得到位数的值和进位,sum是最后当前位的值，extra是进位的位数</span></span><br><span class="line">        sum = v1 + v2 + extra</span><br><span class="line">        extra = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum &gt;= <span class="number">2</span>:</span><br><span class="line">            extra = sum // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        t = sum // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">            t = <span class="number">1</span></span><br><span class="line">        sum = sum % (t * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意遍历s1和s2都是从前往后遍历的，所以进位从头进位的，也就是说当前位数是在后面的</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_addBinary(s1, c1, s2, c2, extra) + str(sum)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-binary/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-696. 计数二进制子串</title>
    <url>/2020/08/10/leetcode-696.%20%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，</span><br><span class="line">并且这些子字符串中的所有0和所有1都是组合在一起的。</span><br><span class="line"></span><br><span class="line">重复出现的子串要计算它们出现的次数。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>先统计连接的1和0分别是多少，然后知道相连接的0和1 的个数之后，并把结果放到数组中，答案要求的  子串、1和0都是各自相连的、且1和0的个数相同的个数就能统计出来的，因为数组相邻元素的最小值就是结果。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前记录的字符</span></span><br><span class="line">        <span class="keyword">char</span> cur;</span><br><span class="line">        <span class="comment">//当前记录的字符的个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; book;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//第一个元素做特判</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                cur = s[i];</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是之前记录的就计数器加一</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == cur) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="comment">//否则就重新记录数字，并把之前记录的结果放到数组里面</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                book.push_back(cnt);</span><br><span class="line">                cur = s[i];</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//最后一组数也放进来</span></span><br><span class="line">        book.push_back(cnt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出相邻元素的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; book.size(); i++) &#123;</span><br><span class="line">            ans += min(book[i], book[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>连在一起的元素可以用数组记录出现的次数。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-binary-substrings/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-13. 罗马数字转整数</title>
    <url>/2019/12/28/leetcode-69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现 int sqrt(int x) 函数。</span><br><span class="line"></span><br><span class="line">计算并返回 x 的平方根，其中 x 是非负整数。</span><br><span class="line"></span><br><span class="line">由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始自然是调库函数</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> t = Math.sqrt(x);</span><br><span class="line">        t = Math.floor(t);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>水题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-70. 爬楼梯</title>
    <url>/2019/11/07/leetcode-70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><br><span class="line"></span><br><span class="line">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line"></span><br><span class="line">注意：给定 n 是一个正整数。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显可以用暴力。走到n节台阶的走法数就是走到第n-1节的走法数加上走到第n-2节的走法数。因为可以从这两节上分别走一节和两节走到第n节。但是如果不加记忆化搜索的话，这个方法的复杂度是2^n，是指数型的，一定会超时。</li>
<li>记忆化搜索优化暴力：在搜索过程中一定会有得到第n节的走法数的值，所以每次得到值的时候，都放到map里面，然后每次在搜索前判断当前n是否已经算过了，如果已经算过就直接从map里面获取值。</li>
<li>dp也行，这里的状态转移方程就是当前n的结果等于n-1的结果加上n-2的结果。因为从n-1那里走一步可以到达n，从n-2那里走两步也可以到达n，而且这两者是相互不冲突的。所以n的结果可以看成两者的和。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.f(n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.f(n - <span class="number">1</span>) + self.f(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="暴力优化"><a href="#暴力优化" class="headerlink" title="暴力优化"></a>暴力优化</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 采用dic来存储遍历到的值</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> self.f(n, dic)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self, n, dic)</span>:</span></span><br><span class="line">        <span class="comment"># 先判断这个n的值有没有计算过，如果计算过就不再计算了</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> dic.keys():</span><br><span class="line">            <span class="keyword">return</span> dic[n]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 因为只需要到第0节就算可以了，遍历到小于0节的都可以不算</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到计算的结果</span></span><br><span class="line">        sum = self.f(n - <span class="number">1</span>, dic) + self.f(n - <span class="number">2</span>, dic)</span><br><span class="line">        <span class="comment"># 将拿到的结果放入map中</span></span><br><span class="line">        dic[n] = sum</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>

<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            dp.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意状态转移方</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>注意从n-1和n-2到n这两个部分是没有冲突的。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-7. 整数反转</title>
    <url>/2019/11/25/leetcode-7.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>先把数变成正数，如果数是负数就加一个标记，再把所有的数字放到队列里，然后对这个队列进行开头去0操作，然后再把队列里面的数百位乘百，十位乘十，个位乘1，然后如果原来时负数就把这个数变成负数，然后返回就行了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 0表负数，1表正数</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 标记数字是正数还是负数</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            x = abs(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里叫错名字了，应该是queue，不是栈的名字</span></span><br><span class="line">        stack = deque()</span><br><span class="line">        <span class="comment"># 把数都放到队列里面</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            stack.append(x % <span class="number">10</span>)</span><br><span class="line">            x = x // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行开头去0操作</span></span><br><span class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            stack.remove(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把数组里面的数都组合成一个数</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        l = len(stack)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, l):</span><br><span class="line">            t = stack.popleft()</span><br><span class="line">            res = res + t * pow(<span class="number">10</span>, l - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果反转后溢出了就返回0</span></span><br><span class="line">        <span class="keyword">if</span> res &gt;= <span class="number">-1</span> * (pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) <span class="keyword">and</span> res &lt;= pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>*res</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-701. 二叉搜索树中的插入操作</title>
    <url>/2019/11/24/leetcode-701.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</span><br><span class="line"></span><br><span class="line">注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       / \</span><br><span class="line">      2   7</span><br><span class="line">     / \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和 插入的值: 5</span><br><span class="line"></span><br><span class="line">你可以返回这个二叉搜索树:</span><br><span class="line"></span><br><span class="line">         4</span><br><span class="line">       /   \</span><br><span class="line">      2     7</span><br><span class="line">     / \   /</span><br><span class="line">    1   3 5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>递归插入就行啦。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse_insertToBst(root, val)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将值val递归插入到以cur为根节点的树里面</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_insertToBst</span><span class="params">(self, cur: TreeNode, val: int)</span>:</span></span><br><span class="line">        <span class="comment"># 这就是遍历到终点的时候</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为是搜索树，大右小左</span></span><br><span class="line">        <span class="keyword">if</span> val &gt; cur.val:</span><br><span class="line">            cur.right = self.recurse_insertToBst(cur.right, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> val &lt; cur.val:</span><br><span class="line">            cur.left = self.recurse_insertToBst(cur.left, val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为这个值已经插入到cur里面了，所以直接返回cur节点就行了</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>递归的每个情况都是互不影响的</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-717. 1比特与2比特字符</title>
    <url>/2020/02/12/leetcode-717.%201%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有两种特殊字符。第一种字符可以用一比特0来表示。</span><br><span class="line">第二种字符可以用两比特(10 或 11)来表示。</span><br><span class="line"></span><br><span class="line">现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。</span><br><span class="line">给定的字符串总是由0结束。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits = [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits = [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明白题意之后发现，其实只有三种字符，并且分别是10,11,0，而且还没有一个是另一个的前缀，这就很简单了。分情况讨论就行了，<ol>
<li>遍历数组每个元素，当当前元素和下一个元素都是1的时候，就是11的情况，这时候指针后移两位，</li>
<li>当当前指针的元素是0并且当前元素是最后一个元素的时候，就返回true</li>
<li>当当前元素是倒数第二个并且当前元素是1，并且最后一个元素是0的时候就返回false。</li>
</ol>
</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.length == <span class="number">1</span> &amp;&amp; a[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ) &#123;</span><br><span class="line">            <span class="comment">//如果当前是最后一个元素并且当前元素是0，就返回true</span></span><br><span class="line">            <span class="keyword">if</span> (i == a.length - <span class="number">1</span> &amp;&amp; a[i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前元素是1并且下一个元素是1，就是11情况，指针后移两位</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; a.length &amp;&amp; a[i] == <span class="number">1</span> &amp;&amp; a[i + <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前元素是倒数第二个并且还是1，并且最后一个元素是0，自然就是false</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> == a.length &amp;&amp; a[i] == <span class="number">1</span> &amp;&amp; a[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-79. 单词搜索</title>
    <url>/2020/09/13/leetcode-79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二维网格和一个单词，找出该单词是否存在于网格中。</span><br><span class="line"></span><br><span class="line">单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些</span><br><span class="line">水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = &quot;ABCCED&quot;, 返回 true</span><br><span class="line">给定 word = &quot;SEE&quot;, 返回 true</span><br><span class="line">给定 word = &quot;ABCB&quot;, 返回 false</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>dfs，对于每个点朝四个方向遍历，遍历过的加标记</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = board.length;</span><br><span class="line">        <span class="keyword">int</span> c = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    dfs(board, word, <span class="number">0</span>, i, j, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] borad, String word, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//如果字符串都匹配完成</span></span><br><span class="line">            <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">                ans = <span class="keyword">true</span>;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= r || j &lt; <span class="number">0</span> || j &gt;= c) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (borad[i][j] != word.charAt(index)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            borad[i][j] += <span class="number">256</span>;</span><br><span class="line">            dfs(borad, word, index + <span class="number">1</span>, i + <span class="number">1</span>, j, r, c);</span><br><span class="line">            dfs(borad, word, index + <span class="number">1</span>, i - <span class="number">1</span>, j, r, c);</span><br><span class="line">            dfs(borad, word, index + <span class="number">1</span>, i, j + <span class="number">1</span>, r, c);</span><br><span class="line">            dfs(borad, word, index + <span class="number">1</span>, i, j - <span class="number">1</span>, r, c);</span><br><span class="line">            borad[i][j] -= <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>遇到回溯问题之后，可以加一个大标记，如果记过已经产生了，所有的递归都不递归了</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-search/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-766.托普利茨矩阵</title>
    <url>/2019/07/26/leetcode-766.%20%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。</span><br><span class="line"></span><br><span class="line">给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">matrix = [</span><br><span class="line">  [1,2,3,4],</span><br><span class="line">  [5,1,2,3],</span><br><span class="line">  [9,5,1,2]</span><br><span class="line">]</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">在上述矩阵中, 其对角线为:</span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。</span><br><span class="line">各条对角线上的所有元素均相同, 因此答案是True。</span><br></pre></td></tr></table></figure>

<p>##示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,2],</span><br><span class="line">  [2,2]</span><br><span class="line">]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">对角线&quot;[1, 2]&quot;上的元素不同。</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matrix 是一个包含整数的二维数组。</span><br><span class="line">matrix 的行数和列数均在 [1, 20]范围内。</span><br><span class="line">matrix[i][j] 包含的整数在 [0, 99]范围内。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>题意就是看每条斜线上的值是不是都一样的，这就可以递归第一行和第一列的每一个点，然后在dfs中改变flag。</li>
<li>能用dfs解决的就不bb，dfs特性：1.边界判断、2.到达终点的操作、3.正常的操作，写完dfs然后剪枝。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//逐行dfs</span></span><br><span class="line">            dfs(i,<span class="number">0</span>,a[i][<span class="number">0</span>],a.length,a[<span class="number">0</span>].length,a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; a[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="comment">//逐列dfs</span></span><br><span class="line">            dfs(<span class="number">0</span>,j,a[<span class="number">0</span>][j],a.length,a[<span class="number">0</span>].length,a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> temp,<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前的坐标的边界判断</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=n || j&gt;=m)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//触发条件</span></span><br><span class="line">        <span class="keyword">if</span> (a[i][j] != temp)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//递归的剪枝，如果说找到不一样的了，下面的递归就不走了，省时间</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正常的递归</span></span><br><span class="line">        dfs(i+<span class="number">1</span>,j+<span class="number">1</span>,temp,n,m,a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/toeplitz-matrix/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-78. 子集</title>
    <url>/2019/11/22/leetcode-78.%20%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">往满二叉树方向想，遍历到每一个数字都可以选择要或者不要，然后在要或者不要</span><br><span class="line">的情况都进行递归，当遍历到的数字的数量达到全部数字的时候，就递归到了终点</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.recurse_subsets(nums, <span class="number">0</span>, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归到nums的索引为step的数字，并在这个位置选择加不加这个位置上的值</span></span><br><span class="line">    <span class="comment"># 并且再进行递归。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_subsets</span><span class="params">(self, nums: list, step: int, res: list, temp: list)</span>:</span></span><br><span class="line">        <span class="comment"># 当遍历了全部的数字时，就表明有了一个结果</span></span><br><span class="line">        <span class="keyword">if</span> step == len(nums):</span><br><span class="line">            tt = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(temp)):</span><br><span class="line">                tt.append(temp[i])</span><br><span class="line"></span><br><span class="line">            res.append(tt)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这一次递归递归的是没有索引为step的这个数字的时候</span></span><br><span class="line">        self.recurse_subsets(nums, step + <span class="number">1</span>, res, temp)</span><br><span class="line"></span><br><span class="line">        temp.append(nums[step])</span><br><span class="line">        <span class="comment"># 这一次就是有step这个数字去递归</span></span><br><span class="line">        self.recurse_subsets(nums, step + <span class="number">1</span>, res, temp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这一步很重要，因为每次遍历的情况都是不一样的情况，所以要对于下次的情况</span></span><br><span class="line">        <span class="comment"># 删除此次变化的更新，比如1，2，3这个例子，1到2，2可以选择有3或者没3，那么</span></span><br><span class="line">        <span class="comment"># 有3的情况递归完了，此时temp中还是有3的，那我再回到有2的情况的时候</span></span><br><span class="line">        <span class="comment"># 是不能有3的，所以要pop掉当前新增如的内容</span></span><br><span class="line">        temp.pop()</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>类似于全排列的那种递归貌似可以用step的方式，按格子来实现。</li>
<li>注意子集看来’AB’和’BA’是一样的，所以可以用格子来。</li>
<li>和N*X是不一样的，这种例题是leetcode-1079活字印刷</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-78. 子集</title>
    <url>/2019/11/22/leetcode-797.%20%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）</span><br><span class="line"></span><br><span class="line">二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了a→b你就不能从b→a）空就是没有下一个结点了。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [[1,2], [3], [3], []] </span><br><span class="line">输出: [[0,1,3],[0,2,3]] </span><br><span class="line">解释: 图是这样的:</span><br><span class="line">0---&gt;1</span><br><span class="line">|    |</span><br><span class="line">v    v</span><br><span class="line">2---&gt;3</span><br><span class="line">这有两条路: 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3.</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结点的数量会在范围 [2, 15] 内。</span><br><span class="line">你可以把路径以任意顺序输出，但在路径内的结点的顺序必须保证。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>类似于之前的用数组存储图，然后以数组存储图来进行DFS遍历。</li>
<li>这里只要处理好每次遍历新的情况的时候都消除旧情况的印象。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span><span class="params">(self, graph: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.curse_allPath([<span class="number">0</span>], res, graph, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># loc表示当前遍历到的数字，temp表示遍历到当前数字产生的中间结果</span></span><br><span class="line">    <span class="comment"># res表示最后的结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">curse_allPath</span><span class="params">(self, temp: list, res: list, graph: list, loc: int)</span>:</span></span><br><span class="line">        <span class="comment"># 因为题目要求的是从0到n-1的结果，当遍历到n-1的时候自然就是最终结果了</span></span><br><span class="line">        <span class="keyword">if</span> loc == len(graph) - <span class="number">1</span>:</span><br><span class="line">            tt = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(temp)):</span><br><span class="line">                tt.append(temp[i])</span><br><span class="line"></span><br><span class="line">            res.append(tt)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果不是最终结果就要进行递归遍历了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(graph[loc])):</span><br><span class="line">            <span class="comment"># 进行分情况递归的时候先更新temp</span></span><br><span class="line">            temp.append(graph[loc][i])</span><br><span class="line">            <span class="comment"># 更新后进行新情况的递归</span></span><br><span class="line">            self.curse_allPath(temp, res, graph, graph[loc][i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 这步很重要，每次都要消除对下次递归的影响，因为每次递归都是新情况，</span></span><br><span class="line">            <span class="comment"># 他们之间是互不影响的</span></span><br><span class="line">            temp.pop()</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>注意到每次递归都是新情况，互不影响的</li>
<li>无环图就是最理想的图，也是最简单的图</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/all-paths-from-source-to-target/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-8. 字符串转换整数 (atoi)</title>
    <url>/2020/04/03/leetcode-8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请你来实现一个 atoi 函数，使其能将字符串转换成整数。</span><br><span class="line"></span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</span><br><span class="line"></span><br><span class="line">如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</span><br><span class="line">假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</span><br><span class="line">该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</span><br><span class="line"></span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">本题中的空白字符只包括空格字符 &apos; &apos; 。</span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>

<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>首先用一个指针从头遍历，去除开头的空格，然后判断符号是正还是负，然后记录数字，记录之前判断是否越界就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//略过开头的空格</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.size() &amp;&amp; str[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i == str.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看是否是负号</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            negative = <span class="literal">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">//如果首位不是数字，那么这个字符串一定不合法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(str[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//要判断每一位都是数字</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.size() &amp;&amp; <span class="built_in">isdigit</span>(str[i])) &#123;、</span><br><span class="line">            <span class="comment">//拿到这一位的数字</span></span><br><span class="line">            <span class="keyword">int</span> digit = str[i] - <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; (INT_MAX - digit) / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// 本来应该是 ans * 10 + digit &gt; Integer.MAX_VALUE</span></span><br><span class="line">                <span class="comment">// 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。</span></span><br><span class="line">                <span class="keyword">return</span> negative ? INT_MIN : INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">10</span> + digit;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>判断一个数字是否越界：也就是说会在某一步 ans * 10 + digit &gt; Integer.MAX_VALUE。</li>
</ol>
<p>*10 和 +digit 都有可能越界，那么只要把这些都移到右边去就可以了。<br>ans &gt; (Integer.MAX_VALUE - digit) / 10 就是越界。这个是不论正负数都可以的，刚才自己试了下，确实不关闭正负数都可以的。</p>
<ol start="2">
<li>可以从开头用一个指针，来排除略过开头的空格。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-820. 单词的压缩编码</title>
    <url>/2020/03/28/leetcode-820.%20%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</span><br><span class="line"></span><br><span class="line">例如，如果这个列表是 [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]，我们就可以将其表示为 S = </span><br><span class="line">&quot;time#bell#&quot; 和 indexes = [0, 2, 5]。</span><br><span class="line"></span><br><span class="line">对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 &quot;#&quot; 结束</span><br><span class="line">，来恢复我们之前的单词列表。</span><br><span class="line"></span><br><span class="line">那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">输出: 10</span><br><span class="line">说明: S = &quot;time#bell#&quot; ， indexes = [0, 2, 5] 。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= words.length &lt;= 2000</span><br><span class="line">1 &lt;= words[i].length &lt;= 7</span><br><span class="line">每个单词都是小写字母 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的是set，用set存入所有单词的所有可能后缀，然后对剩下的set里面的每个字符串都进行计算长度然后分别+1。因为这么存，最后set剩余的都是不能被别人替代的后缀。这也是题目要求的结果</li>
<li>或者用字典树存储不重复的后缀，也就是构造一棵字典树，也就是将所有字符串倒着存入字典树，字典树里面的节点有一个变量是count，count用来标记当前这个节点是不是一个叶子节点，因为在字典树中每次赋值的时候，都先向下连接，也就是child[c-‘a’] = new Trie()，然后对当前这个节点进行count++，这么做的目的是，表明当前这个节点连接上了新节点，那么这个节点自然不是叶子节点了。然后在我倒叙插入字符串的时候，直接把所有结尾的字典树节点都放到map里面，然后最后对map进行遍历，看map中的节点是否count为0，为0才计算长度。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">set</span><span class="params">(words.begin(),words.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word: words)&#123;</span><br><span class="line">            <span class="comment">//把所有单词的后缀全部放到set里面</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;word.size(); k++)&#123;</span><br><span class="line">                <span class="comment">//和java的字符串截取一样</span></span><br><span class="line">                <span class="built_in">set</span>.erase(word.substr(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时set里面的字符串都是唯一后缀</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word:<span class="built_in">set</span>)&#123;</span><br><span class="line">            ans += word.size()+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    Trie *children[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//记录当前这个节点是否是叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            children[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie *<span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果不存在节点，就连接上</span></span><br><span class="line">        <span class="keyword">if</span> (children[c - <span class="string">'a'</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            <span class="comment">//同时当前节点count变成1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回连接后的节点</span></span><br><span class="line">        <span class="keyword">return</span> children[c - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span> </span>&#123;</span><br><span class="line">        Trie *root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Trie *, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word:words) &#123;</span><br><span class="line">            Trie *cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = word.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//对于每个字符串倒叙插入</span></span><br><span class="line">                cur = cur-&gt;get(word[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//此时的cur一定是每个字符串在字典树中最下面的位置</span></span><br><span class="line">            <span class="built_in">map</span>[cur] = t;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p:<span class="built_in">map</span>) &#123;</span><br><span class="line">            <span class="comment">//看这个字符串对应的节点是否是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是，就计算唯一字符串的长度</span></span><br><span class="line">                ans += words[p.second].size() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>牵扯到唯一，一般都可以用set。</li>
<li>遇到字符串别忘了字典树。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/short-encoding-of-words/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>字符串后缀</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-804. 唯一摩尔斯密码词</title>
    <url>/2020/01/02/leetcode-804.%20%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， </span><br><span class="line">比如: &quot;a&quot; 对应 &quot;.-&quot;, &quot;b&quot; 对应 &quot;-...&quot;, &quot;c&quot; 对应 &quot;-.-.&quot;, 等等。</span><br><span class="line"></span><br><span class="line">为了方便，所有26个英文字母对应摩尔斯密码表如下：</span><br><span class="line"></span><br><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,</span><br><span class="line">&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,</span><br><span class="line">&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br><span class="line"></span><br><span class="line">给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，&quot;cab&quot; 可以写成 </span><br><span class="line">&quot;-.-..--...&quot;，(即 &quot;-.-.&quot; + &quot;-...&quot; + &quot;.-&quot;字符串的结合)。我们将这样一个连接过程称作单词翻译。</span><br><span class="line"></span><br><span class="line">返回我们可以获得所有词不同单词翻译的数量。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">各单词翻译如下:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line">共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显用set，先产生出每个字符串对应的摩斯码，然后都放到set里面，然后返回set的容量就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提前准备好，而且a~z的索引是从0~25的，到后面调用的时候直接-97就行了</span></span><br><span class="line">        String[] s = &#123;<span class="string">".-"</span>, <span class="string">"-..."</span>, <span class="string">"-.-."</span>, <span class="string">"-.."</span>, <span class="string">"."</span>, <span class="string">"..-."</span>, <span class="string">"--."</span>, <span class="string">"...."</span>, <span class="string">".."</span>, <span class="string">".---"</span>, <span class="string">"-.-"</span>, <span class="string">".-.."</span>, <span class="string">"--"</span>,</span><br><span class="line">                <span class="string">"-."</span>, <span class="string">"---"</span>, <span class="string">".--."</span>, <span class="string">"--.-"</span>, <span class="string">".-."</span>, <span class="string">"..."</span>, <span class="string">"-"</span>, <span class="string">"..-"</span>, <span class="string">"...-"</span>, <span class="string">".--"</span>, <span class="string">"-..-"</span>, <span class="string">"-.--"</span>, <span class="string">"--.."</span>&#125;;</span><br><span class="line">        <span class="comment">//存储所有摩斯码的set</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历每个字符串</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">//转换成字符数组方便一点</span></span><br><span class="line">            <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            <span class="comment">//用一个中介的字符串</span></span><br><span class="line">            String temp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="comment">//根据每个字符串获得字符串对应的摩斯码</span></span><br><span class="line">                temp = temp + s[chars[i] - <span class="number">97</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//放入set中</span></span><br><span class="line">            set.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回set的容量，因为set有自动的去重</span></span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-morse-code-words/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-807. 保持城市天际线</title>
    <url>/2019/11/12/leetcode-807.%20%E4%BF%9D%E6%8C%81%E5%9F%8E%E5%B8%82%E5%A4%A9%E9%99%85%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。</span><br><span class="line"></span><br><span class="line">最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。</span><br><span class="line"></span><br><span class="line">建筑物高度可以增加的最大总和是多少？</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]</span><br><span class="line">输出： 35</span><br><span class="line">解释： </span><br><span class="line">The grid is:</span><br><span class="line">[ [3, 0, 8, 4], </span><br><span class="line">  [2, 4, 5, 7],</span><br><span class="line">  [9, 2, 6, 3],</span><br><span class="line">  [0, 3, 1, 0] ]</span><br><span class="line"></span><br><span class="line">从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]</span><br><span class="line">从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]</span><br><span class="line"></span><br><span class="line">在不影响天际线的情况下对建筑物进行增高后，新数组如下：</span><br><span class="line"></span><br><span class="line">gridNew = [ [8, 4, 8, 7],</span><br><span class="line">            [7, 4, 7, 7],</span><br><span class="line">            [9, 4, 8, 7],</span><br><span class="line">            [3, 3, 3, 3] ]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文字题，理解题意就能会做，提议大致是一个数组从上往下看能产生一个数组，这个一维数组就是每一列的最大值</span><br><span class="line">从左往右看也能获得一个数组，这个一维数组就是每一行的最大值，现在问你，在不影响这两个数组的值的情况下</span><br><span class="line">增大数组中每一个元素的值，最大能增多少值。</span><br><span class="line"></span><br><span class="line">每一个元素怎么变？每一个元素只和两个最大值有关，他所在的这一行的最大值和他所在的这一列的最大值，他只要不</span><br><span class="line">大于这两个最大值的最小值就可以了。(理解一下题意就懂了)。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, a: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 装有行最大值的数组</span></span><br><span class="line">        row = []</span><br><span class="line">        <span class="comment"># 装有列最大值的数组</span></span><br><span class="line">        col = []</span><br><span class="line">        rlen = len(a)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, rlen):</span><br><span class="line">            row.append(<span class="number">0</span>)</span><br><span class="line">        clen = len(a[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, clen):</span><br><span class="line">            col.append(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 给row数组赋值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, rlen):</span><br><span class="line">            temp = <span class="number">-100</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, clen):</span><br><span class="line">                temp = max(temp, a[i][j])</span><br><span class="line">                row[i] = temp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 给col数组赋值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, clen):</span><br><span class="line">            temp = <span class="number">-100</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, rlen):</span><br><span class="line">                temp = max(temp, a[i][j])</span><br><span class="line">                col[j] = temp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历每一个元素，看每一个元素都能变多少，然后把变得数值都存储起来。</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, rlen):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, clen):</span><br><span class="line">                temp = min(row[i], col[j])</span><br><span class="line">                sum = sum + temp - a[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-83. 删除排序链表中的重复元素</title>
    <url>/2019/10/17/leetcode-83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>因为是消除有序链表的重复元素，所以造一个新链表，而且新链表的末尾元素记录着最新的元素，所以遍历链表，每次都与新链表的末尾元素进行比较，如果不同，就往新链表末尾往后添加该不同的节点，同时新链表末尾指针向后移，如果相同，新链表不添加元素，直到旧链表元素遍历完毕之后，没有重复元素的新链表产生完毕。</li>
<li>第二种做法就是在原来的链表基础上进行修改，这里采用两个指针cur1和cur2，cur1指向的是最后一个不重复的元素，cur2用来遍历原来的链表。每次比较cur1和cur2指向的节点的值，如果不一样就让cur1的next指向cur2，这样就实现了去除相同的元素。但是这种方法会有一个问题，最后一个元素的相同元素去除不掉，比如链表中是[1,1,2,3,3,3,3]去重完之后是[1,2,3,3,3,3],因为如果到了后面的时候cur2和cur1的值一直是一样的，cur1后面的值是去不掉的。所以就需要一个last指针用于记录最后元素的值，再来一个cur3用来遍历到经过第一波去重后的链表的第一个值为last.val的节点上，遍历到这个节点再把这个节点的next置为None。就实现了全部的去重</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="造一个新链表"><a href="#造一个新链表" class="headerlink" title="造一个新链表"></a>造一个新链表</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head1: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 判断非空情况</span></span><br><span class="line">        <span class="keyword">if</span> head1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 造一个新链表</span></span><br><span class="line">        head2 = ListNode(head1.val)</span><br><span class="line">        <span class="comment"># cur2为新链表的尾指针</span></span><br><span class="line">        cur2 = head2</span><br><span class="line">        <span class="comment"># 用cur1指针遍历旧链表</span></span><br><span class="line">        cur1 = head1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始遍历旧链表</span></span><br><span class="line">        <span class="keyword">while</span> cur1 != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 若当前旧链表的值和新链表的末尾值不同</span></span><br><span class="line">            <span class="keyword">if</span> cur1.val != cur2.val:</span><br><span class="line">                <span class="comment"># 就往新链表之后添加新节点</span></span><br><span class="line">                cur2.next = ListNode(cur1.val)</span><br><span class="line">                <span class="comment"># 同时新链表尾指针后移</span></span><br><span class="line">                cur2 = cur2.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前旧链表的值和新链表的末尾值相同，就遍历下一个旧链表的节点</span></span><br><span class="line">            cur1 = cur1.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回新链表</span></span><br><span class="line">        <span class="keyword">return</span> head2</span><br></pre></td></tr></table></figure>

<h2 id="两次去重"><a href="#两次去重" class="headerlink" title="两次去重"></a>两次去重</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># cur1用来记录最后一个不重复的节点的指针</span></span><br><span class="line">        cur1 = head</span><br><span class="line">        <span class="comment"># cur2用来遍历全部的链表</span></span><br><span class="line">        cur2 = head.next</span><br><span class="line">        <span class="comment"># last用来记录整个链表的最后一个元素索引</span></span><br><span class="line">        last = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一波去重</span></span><br><span class="line">        <span class="keyword">while</span> cur2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果每次cur2遍历到节点的值不同与cur1的话，就让cur1的next域指向cur2，直接</span></span><br><span class="line">            <span class="comment"># 跨过中间的节点</span></span><br><span class="line">            <span class="keyword">if</span> cur2.val != cur1.val:</span><br><span class="line">                cur1.next = cur2</span><br><span class="line">                <span class="comment"># 更新cur1的指针域</span></span><br><span class="line">                cur1 = cur1.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录last指针</span></span><br><span class="line">            <span class="keyword">if</span> cur2.next == <span class="literal">None</span>:</span><br><span class="line">                last = cur2</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#更新cur2指针</span></span><br><span class="line">            cur2 = cur2.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行第二波去重</span></span><br><span class="line">        cur3 = head</span><br><span class="line">        <span class="keyword">while</span> cur3 != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 当碰到第一个原链表中的最后一个元素的值的时候，就把这个对应的节点的next置None</span></span><br><span class="line">            <span class="keyword">if</span> cur3.val == last.val:</span><br><span class="line">                cur3.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回两波去重的链表头指针</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>注意有序，这道题的第一种解法就是因为有序，才能用根据新链表的末尾元素来判断是否需要继续添加非重复的值。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>830. 较大分组的位置</title>
    <url>/2019/09/10/leetcode-830.%20%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。</span><br><span class="line"></span><br><span class="line">例如，在字符串 S = &quot;abbxxxxzyy&quot; 中，就含有 &quot;a&quot;, &quot;bb&quot;, &quot;xxxx&quot;, &quot;z&quot; 和 &quot;yy&quot; 这样的一些分组。</span><br><span class="line"></span><br><span class="line">我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。</span><br><span class="line"></span><br><span class="line">最终结果按照字典顺序输出。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abbxxxxzzy&quot;</span><br><span class="line">输出: [[3,6]]</span><br><span class="line">解释: &quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abc&quot;</span><br><span class="line">输出: []</span><br><span class="line">解释: &quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出: [[3,5],[6,9],[12,14]]</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= S.length &lt;= 1000</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>最开始的想法是从头往后遍历数组，根据每次遍历到的不同的字符来进行判断，然后根据判断的结果分不同情况进行处理，首先用c保留遍历到的字符的上一个字符，再用cnt表示累积到的相同的子串的长度，start表示当前cnt记录的字符串的开始的索引，end表示当前cnt记录的字符串的结束的索引，然后分情况讨论 <ol>
<li>如果当前的字符和c相同，cnt就加一，end往后移动一个位</li>
<li>若当前的字符和c不同且cnt的长度小于3，那么就把c更新为当前遍历到的字符，并且初始化cnt为1，初始化start和end的值为当前的索引i</li>
<li>若当前的字符和c不同缺cnt的长度大于等于3，那么就把start和end插入到结果的list中，再更新cnt，start和end，最后再更新c</li>
</ol>
</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="从头遍历，分情况讨论"><a href="#从头遍历，分情况讨论" class="headerlink" title="从头遍历，分情况讨论"></a>从头遍历，分情况讨论</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span><span class="params">(self, s: str)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># c记录上一个位置的上的字符</span></span><br><span class="line">        c = s[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># cnt记录长度</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="comment"># start记录子字符串的开始位置的索引</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># end记录子字符串的结束位置的索引</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="comment"># 当前字符和c相同时，end后移，cnt加一</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == c:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若不同的话并且子字符串的长度不够长</span></span><br><span class="line">                <span class="keyword">if</span> cnt &lt; <span class="number">3</span>:</span><br><span class="line">                    <span class="comment"># 更新全部的值</span></span><br><span class="line">                    c = s[i]</span><br><span class="line">                    cnt = <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">                    end = i</span><br><span class="line">                <span class="comment"># 若够长就记录下start和end，再更新全部值</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c = s[i]</span><br><span class="line">                    cnt = <span class="number">1</span></span><br><span class="line">                    res.append([start, end])</span><br><span class="line">                    start = i</span><br><span class="line">                    end = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> end-start&gt;=<span class="number">2</span>:</span><br><span class="line">            res.append([start, end])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/positions-of-large-groups/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/positions-of-large-groups/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-836. 矩形重叠</title>
    <url>/2020/03/18/leetcode-836.%20%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，</span><br><span class="line">(x2, y2) 是右上角的坐标。</span><br><span class="line"></span><br><span class="line">如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</span><br><span class="line"></span><br><span class="line">给出两个矩形，判断它们是否重叠并返回结果。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</span><br><span class="line">矩形中的所有坐标都处于 -10^9 和 10^9 之间。</span><br><span class="line">x 轴默认指向右，y 轴默认指向上。</span><br><span class="line">你可以仅考虑矩形是正放的情况。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>就是给四个点的坐标，每两个点的坐标代表一个矩阵的左上角和右下角。看看这个两个矩阵是否重叠。其实要判断重叠有点麻烦，判断不重叠其实是很容易的，只要把判断不重叠的情况去反就是判断重叠的情况了。</li>
<li>怎么判断不重叠呢？我们选中一个矩阵A，当另一个矩阵B在A的上、下、左、右面的时候(可以接触）就算不重叠，而判断B在A的上下左右的时候只需要根据两个点就能判断了。</li>
<li>比如A(x1,x1)(x2,y2)B(x3,y3)(x4,y4)，判断B在A的左面只需要x4&lt;=x1，判断B在A的上面只需要y3&gt;=y2，剩下的同理。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">isRectangleOverlap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;rec1, vector&lt;<span class="keyword">int</span>&gt; &amp;rec2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把所有不重叠的情况排除就是重叠的情况了</span></span><br><span class="line">        <span class="keyword">return</span> !(rec2[<span class="number">2</span>] &lt;= rec1[<span class="number">0</span>] || rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>] || rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>] || rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>有时候从反面想问题也是一个经常用的方法</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rectangle-overlap/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-832.翻转图像</title>
    <url>/2019/07/20/leetcode-832.%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。</span><br><span class="line">水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。</span><br><span class="line">反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</span><br></pre></td></tr></table></figure>



<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>0和1 的反转可以用加1对2取余来做，也可以用异或运算来做。</li>
<li>水平翻转可以用双指针，而且自己的双指针存在i==j的情况没有处理，记得处理</li>
<li>可以在翻转的时候顺带反转</li>
<li>用增强for比普通for快</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] a) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//增强for比普通for快</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] b : a) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = b.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//双指针</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="comment">//在双指针里面处理异或运算</span></span><br><span class="line">                b[l] = b[l] ^ <span class="number">1</span>;</span><br><span class="line">                b[r] = b[r] ^ <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> t = b[l];</span><br><span class="line">                b[l] = b[r];</span><br><span class="line">                b[r] = t;</span><br><span class="line"></span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当i==j的时候，也就是列数是奇数的时候</span></span><br><span class="line">            <span class="keyword">if</span> (b.length%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                b[l] = b[l]^<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>异或运算<ol>
<li>i^i=0</li>
<li>i^0=i</li>
</ol>
</li>
<li>异或运算交换两个变量的值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i^=j;</span><br><span class="line">j^=i;</span><br><span class="line">i^=j;</span><br><span class="line">比如i = 4,j=3;</span><br><span class="line">交换流程为：</span><br><span class="line">i^=j  -&gt;  i = 4^3</span><br><span class="line">j^=i  -&gt;  j = 3^4^3  -&gt; 0^4  -&gt;  4</span><br><span class="line">i^=j  -&gt;  i = 4^3^4  -&gt; 0^3  -&gt;  3、</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flipping-an-image/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-841. 钥匙和房间</title>
    <url>/2020/09/01/leetcode-841.%20%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，</span><br><span class="line">2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。</span><br><span class="line"></span><br><span class="line">在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。</span><br><span class="line"></span><br><span class="line">最初，除 0 号房间外的其余所有房间都被锁住。</span><br><span class="line"></span><br><span class="line">你可以自由地在房间之间来回走动。</span><br><span class="line"></span><br><span class="line">如果能进入每个房间返回 true，否则返回 false</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1],[2],[3],[]]</span><br><span class="line">输出: true</span><br><span class="line">解释:  </span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,3],[3,0,1],[2],[0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：我们不能进入 2 号房间。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>就是相当于图的dfs遍历，然后看dfs完事之后是否全部的节点都被访问过。    </li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//标记数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="comment">//记录走过的节点的个数</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;rooms, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">        nums[n] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历这个房间的钥匙</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t:rooms[n]) &#123;</span><br><span class="line">            <span class="comment">//如果没有走过才继续遍历</span></span><br><span class="line">            <span class="keyword">if</span> (nums[t] != <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(rooms, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rooms.size();</span><br><span class="line">        nums.resize(n);</span><br><span class="line">        dfs(rooms, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>vector可以先声明，然后后期再resize，重新定义大小  </li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/keys-and-rooms/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/keys-and-rooms/</a> </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-844. 比较含退格的字符串</title>
    <url>/2020/02/14/leetcode-844.%20%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，</span><br><span class="line">判断二者是否相等，并返回结果。 # 代表退格字符。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;a#c&quot;, T = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= S.length &lt;= 200</span><br><span class="line">1 &lt;= T.length &lt;= 200</span><br><span class="line">S 和 T 只含有小写字母以及字符 &apos;#&apos;。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>把遇到的字符串用栈存起来，遇到#就弹出一个字符，然后最后看两个栈是否一样就完事了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Character&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把两个字符串的所有内容都放到栈里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'#'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack1.isEmpty())</span><br><span class="line">                    stack1.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack1.push(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.charAt(i) == <span class="string">'#'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack2.isEmpty())</span><br><span class="line">                    stack2.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack2.push(t.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后比较栈是否相同</span></span><br><span class="line">        <span class="keyword">return</span> stack1.equals(stack2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>貌似很多内置的数据结构的equals都是重写了的咯。并且专门用来比较数据结构和那种数据结构是否内容相同</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/backspace-string-compare/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-867.转置矩阵</title>
    <url>/2019/07/24/leetcode-867.%20%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个矩阵 A， 返回 A 的转置矩阵。</span><br><span class="line"></span><br><span class="line">矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= A.length &lt;= 1000</span><br><span class="line">1 &lt;= A[0].length &lt;= 1000</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>从题中可以看出，一定是要新创建一个数组的。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] transpose(<span class="keyword">int</span>[][] a) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[a[<span class="number">0</span>].length][a.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                b[j][i] = a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/transpose-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/transpose-matrix/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-88.合并两个有序数组</title>
    <url>/2019/08/01/leetcode-88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>明显双指针分别指向两个数组，因为是有序的数组那就谁合适就把谁放到目标数组里面</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> m, <span class="keyword">int</span>[] b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先把a里面原来的内容放到别的数组里面</span></span><br><span class="line">        <span class="keyword">int</span>[] na = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="comment">//拷贝数组的新方法</span></span><br><span class="line">        System.arraycopy(a,<span class="number">0</span>,na,<span class="number">0</span>,m);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指向na</span></span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//指向b</span></span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m &amp;&amp; p2 &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (na[p1] &lt; b[p2])&#123;</span><br><span class="line">                a[cnt] = na[p1];</span><br><span class="line">                p1++;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                a[cnt] = b[p2];</span><br><span class="line">                p2++;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//经过从循环里出来的情况无非就是一个数组的值放完了而另一个数组的没有放完，这时候就要把剩余的数组都放进去。通过数组拷贝。</span></span><br><span class="line">        <span class="comment">//这里的p1刚好就是数组na开始拷贝的位置，从p1开始拷贝m-p1个，正好拷贝到索引为m-1的位置上。</span></span><br><span class="line">        <span class="keyword">if</span> (p1 &lt; m)&#123;</span><br><span class="line">            System.arraycopy(na,p1,a,cnt,m-p1);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.arraycopy(b,p2,a,cnt,n-p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>拷贝数组的方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.arraycopy(src,srcPos,des,desPos,len); </span><br><span class="line">//形参分别代表的是源数组src，源数组开始复制的位置srcPos，</span><br><span class="line">//目标数组des，目标数组开始位置desPos，从源数组开始赋值的位置scrPos开始的长度len</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-888.公平的糖果交换</title>
    <url>/2019/07/30/leetcode-888.%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。</span><br><span class="line"></span><br><span class="line">因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</span><br><span class="line"></span><br><span class="line">返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。</span><br><span class="line"></span><br><span class="line">如果有多个答案，你可以返回其中任何一个。保证答案存在</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1,1], B = [2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2], B = [2,3]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [2], B = [1,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure>

<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2,5], B = [2,4]</span><br><span class="line">输出：[5,4]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= A.length &lt;= 10000</span><br><span class="line">1 &lt;= B.length &lt;= 10000</span><br><span class="line">1 &lt;= A[i] &lt;= 100000</span><br><span class="line">1 &lt;= B[i] &lt;= 100000</span><br><span class="line">保证爱丽丝与鲍勃的糖果总量不同。</span><br><span class="line">答案肯定存在。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>注意只换一次</li>
<li>最开始想的是二重循环，枚举两个数组的每一个数，也就是说枚举当数组a换a[0]的时候，把数组b的b[0]…b[n-1]都试一遍，如果交换成功了那就OK，不成功就继续遍历</li>
<li>根据题解得出一个算术公式，设两个未知数x,y，x表示a数组去掉的，y表示b数组去掉的<img src="http://latex.codecogs.com/gif.latex?Sum_a+x-y=Sum_b-x+y" style="border:none;"></li>
<li>化简得<img src="http://latex.codecogs.com/gif.latex?x+\frac{Sum_a+Sum_b}{2}=y" style="border:none;"></li>
<li>然后枚举x找y就行啦。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="二重循环"><a href="#二重循环" class="headerlink" title="二重循环"></a>二重循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fairCandySwap(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> suma=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumb=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            suma+=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">            sumb+=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个数都遍历一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (suma-i+j==sumb-j+i)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算术规律"><a href="#算术规律" class="headerlink" title="算术规律"></a>算术规律</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fairCandySwap(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) &#123;</span><br><span class="line">        <span class="keyword">int</span> suma=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumb=<span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            suma+=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">            sumb+=i;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = (sumb-suma)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举x找y，找到就y就返回x和y</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(i+temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,i+temp&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fair-candy-swap/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>计算题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-876. 链表的中间结点</title>
    <url>/2020/03/23/leetcode-876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</span><br><span class="line"></span><br><span class="line">如果有两个中间结点，则返回第二个中间结点。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>既然要找到中间节点，那完全可以先遍历一遍链表，得到链表的长度len，然后发现len是奇数还是偶数，题目要求的链表的中间节点的索引都是len/2+1，然后从头再遍历len/2+1次就走到链表中间节点了。</li>
<li>或者用快慢指针也行，慢指针一次走一步，快指针一次走两步，当快指针是空指针或者快指针的next是空指针的时候就返回慢指针。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="获取长度len然后走len-2-1次"><a href="#获取长度len然后走len-2-1次" class="headerlink" title="获取长度len然后走len/2+1次"></a>获取长度len然后走len/2+1次</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">middleNode</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="comment">//获取长度</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算出要走的次数</span></span><br><span class="line">        <span class="keyword">int</span> times = len / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        ListNode *res = head;</span><br><span class="line">        <span class="comment">//走len/2+1次就行了</span></span><br><span class="line">        <span class="keyword">while</span> (res) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == times)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            res = res-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">middleNode</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *low = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (low) &#123;</span><br><span class="line">            <span class="comment">//如果fast是空或者fast的next是空就说明fast到底了，那么此时low的位置</span></span><br><span class="line">            <span class="comment">//就是链表中点</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> low;</span><br><span class="line">            &#125;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码可以简化一下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">middleNode</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *low = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="comment">//当fast或者fast-&gt;next有一个为空的时候，low的位置就是中点</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>只要给出链表的头结点，其实就是相当于给出了链表的长度，这是一个很常用的条件。</li>
<li>链表快慢指针求中点很常见</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-892. 三维形体的表面积</title>
    <url>/2020/03/25/leetcode-892.%20%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。</span><br><span class="line"></span><br><span class="line">每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。</span><br><span class="line"></span><br><span class="line">请你返回最终形体的表面积。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>

<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= N &lt;= 50</span><br><span class="line">0 &lt;= grid[i][j] &lt;= 50</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>直接分析每一个位置上提供的表面积，从而把每个位置上的表面积都加起来就是整个的表面积，</li>
<li>假如grid[i][j]=v，v表示这个地方的有v块小正方体竖着摞起来，那么就可以发现，如果v大于0，那么这个v个正方体给整体的表面积首先提供了上底和下底这两个面，</li>
<li>然后对于v个正方体的4侧面的来看，比如从上面那个侧面看，v的这个上面的那个侧面提供的表面积就是v减去上面那个相邻的x个正方体的高度的差和0的最大值，也就是 max(0,grid[i][j]-grid[i-1][j])，这很好理解，如果上面那个侧面比当前的高度高，那么这v个正方体对于上面那个侧面提供的表面积就是0，否则如果低的话，提供的就是正方体-上面那个侧面的高度。然后把剩余3个侧面提供给整体的表面积加起来。</li>
<li>以此，对于每一摞的正方体都这样计算，就能得到最终的表面积。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.size();</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="comment">//如果有这一摞有正方体</span></span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//那就至少提供了上下两个底面</span></span><br><span class="line">                    res += <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//对于4个侧面</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="comment">//先拿到侧面的索引</span></span><br><span class="line">                        <span class="keyword">int</span> nr = i + dr[k];</span><br><span class="line">                        <span class="keyword">int</span> nc = j + dc[k];</span><br><span class="line">                        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//如果不越界</span></span><br><span class="line">                        <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nr &lt; rows &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nc &lt; cols)</span><br><span class="line">                            temp = grid[nr][nc];</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//得到当前这个v个正方体对于当前k所代表的这个侧面计算</span></span><br><span class="line">                        <span class="comment">//提供给这个侧面的表面积</span></span><br><span class="line">                        res += max(<span class="number">0</span>, grid[i][j] - temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//方向数组</span></span><br><span class="line">    <span class="keyword">int</span> dr[<span class="number">4</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dc[<span class="number">4</span>]&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surface-area-of-3d-shapes/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-897. 递增顺序查找树</title>
    <url>/2020/09/07/leetcode-897.%20%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line"></span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">    3    6</span><br><span class="line">   / \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> /        / \ </span><br><span class="line">1        7   9</span><br><span class="line"></span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">      \</span><br><span class="line">       4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">          \</span><br><span class="line">           6</span><br><span class="line">            \</span><br><span class="line">             7</span><br><span class="line">              \</span><br><span class="line">               8</span><br><span class="line">                \</span><br><span class="line">                 9</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>中序遍历给定的树，对于新树只需要记录一个pre指针就行了，每次给pre的right连接，然后更新pre的位置就行。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode ans = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//模拟中序遍历</span></span><br><span class="line">            dfs(cur.left);</span><br><span class="line">            <span class="comment">//对节点的处理</span></span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = <span class="keyword">new</span> TreeNode(cur.val);</span><br><span class="line">                ans = pre;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right = <span class="keyword">new</span> TreeNode(cur.val);</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟中序遍历</span></span><br><span class="line">            dfs(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/increasing-order-search-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树的遍历</tag>
        <tag>ky</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-896.单调数列</title>
    <url>/2019/07/31/leetcode-896.%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果数组是单调递增或单调递减的，那么它是单调的。</span><br><span class="line"></span><br><span class="line">如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。</span><br><span class="line"></span><br><span class="line">当给定的数组 A 是单调数组时返回 true，否则返回 false。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[6,5,4,4]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,3,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,4,5]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= A.length &lt;= 50000</span><br><span class="line">-100000 &lt;= A[i] &lt;= 100000</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>最开始的想法是，如果数组长度小于3那就一定是单调的，如果长度大于3那就根据前3位来判断是递增还是递减，然后根据判断的结果去判断后面的数，但是这种想法有个问题就是如果前三位是不具有单调性的，比如1，1，1这种是判断不出来的，同样的如果根据前4位判断整个数组的单调性的时候当前4位还是不具有单调性的时候也是判断不准确的，所以说根据前几位来判断整个数组的单调性的方法是不成立的。</li>
<li>数组不是递增就是递减，那就分别判断一下，先判断一下是不是递增，在判断一下是不是递减。如果满足单调性的话就返回true。如果既不是单调递增也不是单调递减那自然不是单调数组咯</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="都判断一下"><a href="#都判断一下" class="headerlink" title="都判断一下"></a>都判断一下</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isincre(a) || isdecre(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否递增</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isincre</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//这里的取反一定要取号，&gt;=是递增的情况，那么&lt;就是取反的情况</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否递减</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isdecre</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/monotonic-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/monotonic-array/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-905.按奇偶排序数组</title>
    <url>/2019/07/23/leetcode-905.%20%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</span><br><span class="line"></span><br><span class="line">你可以返回满足此条件的任何数组作为答案。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：[2,4,3,1]</span><br><span class="line">输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= A.length &lt;= 5000</span><br><span class="line">0 &lt;= A[i] &lt;= 5000</span><br></pre></td></tr></table></figure>

<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>很明显用双指针很快，既然要求左面全是偶数，右面全是奇数，且顺序没有要求，那就从左找奇数，从右找偶数，当都找到之后交换，当指针相遇时，就交换完了。</li>
</ul>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = a.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//i从左找第一个奇数</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//j从右找第一个偶数</span></span><br><span class="line">            <span class="keyword">if</span> (a[j]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当双方都就位的时候交换</span></span><br><span class="line">            <span class="keyword">int</span> t = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = t;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>没啥知识点</li>
</ul>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-array-by-parity/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1108. IP 地址无效化</title>
    <url>/2020/01/02/leetcode-908.%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%20I/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 A，对于每个整数 A[i]，我们可以选择任意 x 满足 -K &lt;= x &lt;= K，并将 x 加到 A[i] 中。</span><br><span class="line"></span><br><span class="line">在此过程之后，我们得到一些数组 B。</span><br><span class="line"></span><br><span class="line">返回 B 的最大值和 B 的最小值之间可能存在的最小差值。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1], K = 0</span><br><span class="line">输出：0</span><br><span class="line">解释：B = [1]</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [0,10], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B = [2,8]</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [0,10], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B = [2,8]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= A.length &lt;= 10000</span><br><span class="line">0 &lt;= A[i] &lt;= 10000</span><br><span class="line">0 &lt;= K &lt;= 10000</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>找规律，题目意思就是让你给数组里面每个值随意加(加或者不加)-k~k的数，来求一个新数组的最小的最大值和最小值之差。</li>
<li>分析以后可以知道，假设A是原数组，B是新数组，则max(A)和min(A)是确定的，而且res = max(B)-min(B)求出来的，那么max(B)得求最小，min(B)得求最大才能求得res最小，而max(B)最小就是max(A)-k，min(B)最大是min(A)+k，因为max(A)和min(A)是固定的，所以res的值也就知道了。就是res = max(A)-k-(min(A)+k) = max(A)-min(A)-2k。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            min = Math.min(min, i);</span><br><span class="line">            max = Math.max(max, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, max - min - <span class="number">2</span>*k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/smallest-range-i/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-range-i/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数学题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-912. 排序数组</title>
    <url>/2020/03/31/leetcode-912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个整数数组 nums，请你将该数组升序排列。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 50000</span><br><span class="line">-50000 &lt;= nums[i] &lt;= 50000</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>手写快排</li>
<li>归并排序</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        quick_sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            q = partition(nums, l, r);</span><br><span class="line">            quick_sort(nums, l, q - <span class="number">1</span>);</span><br><span class="line">            quick_sort(nums, q + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, t, x;</span><br><span class="line">        x = nums[r];</span><br><span class="line">        i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n1[<span class="number">50000</span> + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> n2[<span class="number">50000</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            sort(nums, l, mid);</span><br><span class="line">            sort(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">            merger(nums, l, r, mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) &#123;</span><br><span class="line">            n1[t++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        n1[t] = <span class="number">0x7fffffff</span>;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            n2[t++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        n2[t] = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n1[i] &lt;= n2[j]) &#123;</span><br><span class="line">                nums[k] = n1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = n2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:nums) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            nums[i] = <span class="built_in">queue</span>.top();</span><br><span class="line">            <span class="built_in">queue</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt;= nums[index])</span><br><span class="line">                    index = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(nums, index, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt;= v) &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j + <span class="number">1</span>] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-an-array/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-92. 反转链表 II</title>
    <url>/2019/10/24/leetcode-92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/bu-bu-chai-jie-ru-he-di-gui-di-fan-zhuan-lian-biao/</span><br><span class="line">这个题解讲的很详细。</span><br><span class="line"></span><br><span class="line">在做这道题的时候如果直到如何反转前n个元素的话就很简单了。</span><br><span class="line">反转前n个元素的时候也是用递归的话思路就和反转全部链表的思路很像，同样的上面的题解都有。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 因为这里遇到了遍历，所以为了处理方便，添加一个虚拟头节点</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        cur = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到m的前驱节点的时候进行前n-m+1个元素的链表反转</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; n:</span><br><span class="line">            <span class="comment"># 注意这个if一定是要写在数值更新的前面的</span></span><br><span class="line">            <span class="keyword">if</span> index == m - <span class="number">1</span>:</span><br><span class="line">                cur.next = self.recurse_revresePre(cur.next,  n-m+ <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 向后递归</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回虚拟头节点的下一个节点，注意虚拟头节点的下一个</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    successer = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse_revresePre</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="comment"># 当要反转的链表只有一个的时候，就保存下这个节点的后继，确保可以在全部反转完之后可以连接到后面的链表</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            self.successer = head.next</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 思想同反转全部链表</span></span><br><span class="line">        last = self.recurse_revresePre(head.next, n - <span class="number">1</span>)</span><br><span class="line">        head.next.next = head</span><br><span class="line">        head.next = self.successer</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在涉及到链表的遍历的时候，最好给链表添加一个虚拟头节点，这样遍历的时候就不会存在特殊性</span><br><span class="line">反转链表的递归写法的思想对于练习递归特别好。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-918. 环形子数组的最大和</title>
    <url>/2020/02/17/leetcode-918.%20%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。</span><br><span class="line"></span><br><span class="line">在此处，环形数组意味着数组的末端将会与开头相连呈环状。</span><br><span class="line">（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，而当 i &gt;= 0 时 C[i+A.length] = C[i]）</span><br><span class="line"></span><br><span class="line">此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。</span><br><span class="line">（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length）</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,-2,3,-2]</span><br><span class="line">输出：3</span><br><span class="line">解释：从子数组 [3] 得到最大和 3</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,-3,5]</span><br><span class="line">输出：10</span><br><span class="line">解释：从子数组 [5,5] 得到最大和 5 + 5 = 10</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,-1,2,-1]</span><br><span class="line">输出：4</span><br><span class="line">解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,-2,2,-3]</span><br><span class="line">输出：3</span><br><span class="line">解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</span><br></pre></td></tr></table></figure>

<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-2,-3,-1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：从子数组 [-1] 得到最大和 -1</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的是暴力解法，以每个数组的每个数字作为开头，然后以这个开头寻找所有的数组的和(包括环形数组)，从中获取最大值。但是超时。</li>
<li>kadene算法不会</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//因为只环一圈，所以用flag标记一圈</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//当到了第二圈</span></span><br><span class="line">                <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                    <span class="comment">//并且超过第二圈的索引又超过了i</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt;= i)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//temp记录中间产生的和</span></span><br><span class="line">                temp += a[j];</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; ans)</span><br><span class="line">                    ans = temp;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="comment">//不能让j越界</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= a.length) &#123;</span><br><span class="line">                    j %= a.length;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-sum-circular-subarray/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-914. 卡牌分组</title>
    <url>/2020/03/26/leetcode-914.%20%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一副牌，每张牌上都写着一个整数。</span><br><span class="line"></span><br><span class="line">此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</span><br><span class="line"></span><br><span class="line">每组都有 X 张牌。</span><br><span class="line">组内所有的牌上都写着相同的整数。</span><br><span class="line">仅当你可选的 X &gt;= 2 时返回 true。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure>

<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= deck.length &lt;= 10000</span><br><span class="line">0 &lt;= deck[i] &lt; 10000</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>总的来说就是给你一个哈希表，然后对于这个哈希表，这个哈希表里面存储的是，key这个数出现了value次，然后让你判断能否存在一个x，然后把这么多个数分成x份，并且每份里面的所有数都相同，所以自然一个很简单的做法就是枚举所有的x，看看哈希表里的所有value是不是都能整除x，如果能整除x就说明整个哈希表可以分成x份数。</li>
<li>当然，上面的做法其实就是找过map中所有value的最大公约数，那么我们其实就可以用gcd这个方法来找到所有value的最大公约数。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力枚举x"><a href="#暴力枚举x" class="headerlink" title="暴力枚举x"></a>暴力枚举x</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="comment">//哈希表计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:deck)</span><br><span class="line">            <span class="built_in">map</span>[i]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//枚举所有的x</span></span><br><span class="line">        <span class="keyword">while</span> (x &lt; <span class="number">10003</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> p:<span class="built_in">map</span>) &#123;</span><br><span class="line">                 <span class="comment">//对于map的每个value看看能不能都整除x</span></span><br><span class="line">                <span class="keyword">if</span> (p.second % x != <span class="number">0</span>)</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果发现都能整除，就表明可以分配x份</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:deck)</span><br><span class="line">            <span class="built_in">map</span>[i]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到所有的value的最大公约数</span></span><br><span class="line">        <span class="keyword">int</span> g = <span class="built_in">map</span>.begin()-&gt;second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p:<span class="built_in">map</span>) &#123;</span><br><span class="line">            g = gcd(g, p.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个g其实就是能分的组，看能不能分成大于1个组就好了</span></span><br><span class="line">        <span class="keyword">return</span> g &gt;= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大公约数方法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !x ? y : gcd(y % x, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>当题目说到或者把问题的点归结于是否存在一个数，然后这个数让整个算法达到一个题目要求的结果的时候，就可以尝试暴力枚举一发。</li>
<li>比如有n个数，这n个数的最大公约数可以先a0,a1求最大公约数res1, 然后res1和a2取最大公约数res2，然后可以res2和a3取最大公约数。而且这其中的ai，是可以取任意顺序的。</li>
<li>gcd求最大公约数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !x ? y : gcd(y % x, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-922.按奇偶排序数组II</title>
    <url>/2019/07/25/leetcode-922.%20%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</span><br><span class="line"></span><br><span class="line">对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</span><br><span class="line"></span><br><span class="line">你可以返回任何满足上述条件的数组作为答案。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,2,5,7]</span><br><span class="line">输出：[4,5,2,7]</span><br><span class="line">解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 &lt;= A.length &lt;= 20000</span><br><span class="line">A.length % 2 == 0</span><br><span class="line">0 &lt;= A[i] &lt;= 1000</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>说白了就是把一个一半是奇数一半是偶数的数组整成数组索引为奇数的地方的值是奇数，偶数索引位置的值是偶数，仔细想想，如果一个偶数的位置不对，那么必定有一个奇数的位置不对，所以就可以从这个角度来想。</li>
<li>从奇数的第一个位置开始找偶数，从偶数的第一个位置找奇数，都找到后交换位置就OK拉。</li>
<li>当然也能新创建个数组，遍历原数组，奇数放到奇数位，偶数放到偶数位。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="comment">//设置左右标</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当标都还在数组里面时</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;a.length-<span class="number">1</span> &amp;&amp; j&lt;a.length) &#123;</span><br><span class="line">            <span class="comment">//通过i找到第一个奇数</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过j找到第一个偶数</span></span><br><span class="line">            <span class="keyword">if</span> (a[j]%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                j+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当双方都找到的时候就交换</span></span><br><span class="line">            <span class="keyword">int</span> t = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = t;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">            j+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>没啥知识点</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-array-by-parity-ii/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-94. 二叉树的中序遍历</title>
    <url>/2019/10/05/leetcode-94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，返回它的中序 遍历</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>中序遍历可以递归写，也可以迭代写。</li>
<li>递归的写法不再赘述，很简单</li>
<li>迭代的写法话呢，首先得明白前序遍历二叉树的非递归写法，前序的非递归就是每次处理栈顶的元素，将栈顶元素的值先打印，然后再把栈顶节点的右孩子入栈，再入栈栈顶节点的左孩子。这样就十分真实的模拟了系统栈在递归时候的做法，递归的做法本质就是依赖了系统栈，而非递归的写法其实就是模拟系统栈调用递归遍历二叉树的一个过程。明白这点之后，中序非递归遍历二叉树就十分简单了，处理栈顶元素的过程就变成了：现将栈顶元素(以下简称cur)的右孩子入栈，再将打印cur的值的操作入栈，再将cur的左孩子入栈。（这里中序的非递归和前序的非递归的区别就在于前序的非递归是不需要把cur的操作入栈的，因为前序每次都是先处理cur的值的，处理完之后直接就进行右孩子、左孩子的入栈了，所以说前序的非递归是不需要把操作入栈的）。那么问题来了，怎么把操作入栈的，在java中我的想法是再封装一层对象t，把节点和操作封装到一起，比如t中操作a就是处理节点的值，t中的操作b就是处理节点的左右孩子。那么在python中就很方便了，因为python中的list是可以放不同类型的值的，所以我这里采用一个字典来标记cur是否是需要操作节点的值，如果cur不是dict类型，那么就需要把操作入栈，如果cur是dict类型，就需要操作cur中的值。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 若根节点本身就是空自然就是直接返回空集合</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则就是通过一个中序遍历来</span></span><br><span class="line">        self.inOrder(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中序遍历根节点是cur的一棵以cur为根节点的树，注意此处是以cur节点来进行递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, cur: TreeNode, res: list)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 中序遍历，先遍历左子树</span></span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">            self.inOrder(cur.left, res)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左子树遍历完然后遍历节点</span></span><br><span class="line">        res.append(cur.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 再然后遍历右子树</span></span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">            self.inOrder(cur.right, res)</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 如果是空集合，自然就遍历不到任何值</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 声明一个栈</span></span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        stack.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 模拟系统栈调用递归中序遍历二叉树的过程</span></span><br><span class="line">        <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 每次拿到栈顶元素</span></span><br><span class="line">            cur = stack.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果cur是dict类型，也就是说这是个需要操作节点的值的标记，因为</span></span><br><span class="line">            <span class="comment"># 这个标记，所以要处理节点的值，根据题意就是把节点的值放到集合返回</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(cur, dict):</span><br><span class="line">                res.append(cur[<span class="string">'val'</span>])</span><br><span class="line">            <span class="comment"># 那么很自然的，既然这里没有需要操作节点的值的标记，那就是正常的模拟递归了</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 先把cur的右孩子入栈，别忘了栈使先进后出</span></span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(cur.right)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 这里把对节点需要操作的标记用字典来实现</span></span><br><span class="line">                stack.append(&#123;<span class="string">'val'</span>: cur.val&#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 同理将cur的左孩子入栈</span></span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    stack.append(cur.left)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当栈为空时，系统栈模拟递归完成</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>迭代可以通过模拟系统栈的调用来完成一个递归的过程。</li>
<li>知道前序的非递归写法就会中序和后序的非递归写法。</li>
<li>中序和后序的非递归写法就是多一个把对节点的值的操作入栈的步骤。</li>
<li>前序的非递归写法就是：先操作栈顶元素的值，再入栈栈顶元素的右孩子，在入栈栈顶元素的左孩子。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-950. 按递增顺序显示卡牌</title>
    <url>/2019/11/15/leetcode-950.%20%E6%8C%89%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%98%BE%E7%A4%BA%E5%8D%A1%E7%89%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。</span><br><span class="line"></span><br><span class="line">最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。</span><br><span class="line"></span><br><span class="line">现在，重复执行以下步骤，直到显示所有卡牌为止：</span><br><span class="line"></span><br><span class="line">从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。</span><br><span class="line">如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。</span><br><span class="line">如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。</span><br><span class="line">返回能以递增顺序显示卡牌的牌组顺序。</span><br><span class="line"></span><br><span class="line">答案中的第一张牌被认为处于牌堆顶部。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[17,13,11,2,3,5,7]</span><br><span class="line">输出：[2,13,3,11,5,17,7]</span><br><span class="line">解释：</span><br><span class="line">我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。</span><br><span class="line">重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。</span><br><span class="line">我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。</span><br><span class="line">我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。</span><br><span class="line">我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。</span><br><span class="line">我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。</span><br><span class="line">我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。</span><br><span class="line">我们展示 13，然后将 17 移到底部。牌组现在是 [17]。</span><br><span class="line">我们显示 17。</span><br><span class="line">由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">看到根据一个指定条件来生成对应的数组就有做法了，首先根据题意，每次抽出数组最</span><br><span class="line">左面的数，然后把下一个数放到数组末尾，如此循环，直到数组为空，并且每次要保证</span><br><span class="line">抽出的数是递增序列。</span><br><span class="line"></span><br><span class="line">那么又不是排序，把数随便放能解决的，所以只能找规律了，那么规律的突破点就在递增，</span><br><span class="line">把一个数放到末尾，这两个点上。所以可以想到，我们可以按照这两个规律一步一步的生</span><br><span class="line">成一个符合题意的数组。</span><br><span class="line"></span><br><span class="line">再然后，每次要给结果数组res添加新数的时候，都先把res的最右面的数移动到res的最</span><br><span class="line">左面(这步的做法就是把原数组的排第二的数放到末尾的反过来的做法)，再给res的最左面</span><br><span class="line">添加上原数组的当前的最大值，然后原数组remove掉最大值。这样直到原数组为空的时候，</span><br><span class="line">res数组也就产生完毕了。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deckRevealedIncreasing</span><span class="params">(self, deck)</span>:</span></span><br><span class="line">        <span class="comment"># 结果数组</span></span><br><span class="line">        res = deque()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当原数组为空的时候，res数组就产生完毕了</span></span><br><span class="line">        <span class="keyword">while</span> len(deck) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 当res数组为空的时候，res数组是不需要把最右面的</span></span><br><span class="line">            <span class="comment"># 数放到最左面的</span></span><br><span class="line">            <span class="keyword">if</span> len(res) != <span class="number">0</span>:</span><br><span class="line">                t = res.pop()</span><br><span class="line">                res.appendleft(t)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 拿到原数组的最大值然后放到res数组的最左面，模拟第一步</span></span><br><span class="line">            temp = max(deck)</span><br><span class="line">            res.appendleft(temp)</span><br><span class="line">            deck.remove(temp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/reveal-cards-in-increasing-order/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reveal-cards-in-increasing-order/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-945. 使数组唯一的最小增量</title>
    <url>/2020/03/22/leetcode-945.%20%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</span><br><span class="line"></span><br><span class="line">返回使 A 中的每个值都是唯一的最少操作次数。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：经过一次 move 操作，数组将变为 [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,2,1,2,1,7]</span><br><span class="line">输出：6</span><br><span class="line">解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。</span><br><span class="line">可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>首先先到的是排序思路，既然让每个a[i]不同于其他的a[i]，那就把所有的数排序，然后让每个a[i]都比a[i-1]大1，这样后面的数就不会大于前面的数，如果遇到a[i]&lt;=a[i-1]的情况，那么a[i]要变的就是a[i-1]-a[i]+1的数。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="comment">//记录要变化的数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从第二个数开始遍历每一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果遇到当前数小于前面的数</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//nums[i]进行变化，并且res记录变化的数</span></span><br><span class="line">                res += nums[i - <span class="number">1</span>] - nums[i] + <span class="number">1</span>;</span><br><span class="line">                nums[i] += nums[i - <span class="number">1</span>] - nums[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-946. 验证栈序列</title>
    <url>/2019/10/17/leetcode-946.%20%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 pushed 和 popped 两个序列，只有当它们可能是在最初空栈上进</span><br><span class="line">行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;= pushed.length == popped.length &lt;= 1000</span><br><span class="line">0 &lt;= pushed[i], popped[i] &lt; 1000</span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题意说白了就是给你两个数组，数组a和数组b。数组a代表的就是要放入顺序放入栈中的一组数，这组数要先按顺序随意入栈，再按照栈的规则随意出栈，出栈之后不能再入栈。按照出栈的顺序把这些数放到一个数组中，看能不能组成一个b数组。</li>
<li>参照官方题解，也就是用一个栈来模拟，每次按照顺序入栈a数组的内容，入栈之后都要判断当前栈顶元素是否和b的首部元素是否相同，如果一样就出栈一下，然后继续比较栈顶元素和b的首部的下一个元素，如果一样再进行相同的操作，直到两者不同或者栈为空。这个操作是要发生在每次入栈的时候的，因为每次入栈都更新了新的栈顶元素，更新了之后就有可能和b的首部元素相同，不同就算了，如果相同就得栈出栈、b后移，这里用一个指针j来记录栈的首部元素。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果两个数组的长度不同就不用考虑模拟栈了</span></span><br><span class="line">        <span class="keyword">if</span> (a.length != b.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//j是标志b的首部元素的指针</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> temp : a) &#123;</span><br><span class="line">            <span class="comment">//对于每个a元素都入栈一下</span></span><br><span class="line">            s.push(temp);</span><br><span class="line">            <span class="comment">//因为栈顶元素发生了更新，所以要判断栈顶元素和b首部元素是否相同</span></span><br><span class="line">            <span class="comment">//!s.isEmpty()为了防止空指针</span></span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; j &lt; len &amp;&amp; s.peek().equals(b[j])) &#123;</span><br><span class="line">                <span class="comment">//若相同，更新b的首部元素</span></span><br><span class="line">                j++;</span><br><span class="line">                <span class="comment">//更新栈顶元素</span></span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果a通过栈可以产生b数组，那么指针一定到b数组的末尾指针的下一个</span></span><br><span class="line">        <span class="keyword">return</span> j==len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>很有用的一道题</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-stack-sequences/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-965. 单值二叉树</title>
    <url>/2019/10/02/leetcode-965.%20%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</span><br><span class="line"></span><br><span class="line">只有给定的树是单值二叉树时，才返回 true；否则返回 false。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,1,1,null,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,5,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定树的节点数范围是 [1, 100]。</span><br><span class="line">每个节点的值都是整数，范围为 [0, 99] 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显可以用dfs做，dfs形参是当前节点cur，根节点的值v，在每个dfs的函数里判断当前节点的值是否和v一样，不一样直接返回false，否则就得判断这个节点的左右节点的dfs的返回值都是true。</li>
<li>也可以用bfs做，再遍历每一个节点的时候直接判断节点的值是不是等于根节点的值，如果不一样，直接返回False，遍历完所有的节点之后就是返回True。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="python的dfs"><a href="#python的dfs" class="headerlink" title="python的dfs"></a>python的dfs</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        v = root.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.recurse(root, v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(self, cur, v)</span>:</span></span><br><span class="line">        <span class="comment"># 若当前节点为空，则返回True，题目规定</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若当前节点的值不等于v，那么直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> cur.val != v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为这里涉及到了整棵树的整体性，所以不能把左右子树分开判断，因此要一起判断</span></span><br><span class="line">        <span class="keyword">return</span> self.recurse(cur.left, v) <span class="keyword">and</span> self.recurse(cur.right, v)</span><br></pre></td></tr></table></figure>

<h2 id="python的bfs"><a href="#python的bfs" class="headerlink" title="python的bfs"></a>python的bfs</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里需要collections包下的deque类</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        q = deque()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        q.append(root)</span><br><span class="line">        v = root.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (len(q) != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(q)):</span><br><span class="line">                cur = q.popleft()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 在遍历每个节点的时候判断节点的值是否是根节点的值</span></span><br><span class="line">                <span class="keyword">if</span> cur.val != v:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 然后就直接正常的bfs就行</span></span><br><span class="line">                <span class="keyword">if</span> cur.left!=<span class="literal">None</span>:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.right!=<span class="literal">None</span>:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>在涉及到整棵树的性质的时候，dfs左右子树的时候就可以并起来。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/univalued-binary-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-977.有序数组的平方</title>
    <url>/2019/07/23/leetcode-977.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= A.length &lt;= 10000</span><br><span class="line">-10000 &lt;= A[i] &lt;= 10000</span><br><span class="line">A 已按非递减顺序排序。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>题目要的结果是一个非递减数组，可以按照这个顺序倒着放值，注意这个结果的顺序性，正是因为结果是非递减，就可以设置一种规则来放置</li>
<li>多考虑双指针，以及双指针的终止条件。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cnt是新数组的下标</span></span><br><span class="line">        <span class="keyword">int</span> cnt = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> ti = a[i]*a[i];</span><br><span class="line">            <span class="keyword">int</span> tj = a[j]*a[j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把较大的放在倒着放</span></span><br><span class="line">            <span class="keyword">if</span> (ti &gt;= tj)&#123;</span><br><span class="line">                b[cnt] = ti;</span><br><span class="line">                cnt--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                b[cnt] = tj;</span><br><span class="line">                cnt--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>没啥知识点</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/squares-of-a-sorted-array/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-985.查询后的偶数和</title>
    <url>/2019/07/27/leetcode-985.%20%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E5%81%B6%E6%95%B0%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出一个整数数组 A 和一个查询数组 queries。</span><br><span class="line"></span><br><span class="line">对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，</span><br><span class="line">我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。</span><br><span class="line"></span><br><span class="line">（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）</span><br><span class="line"></span><br><span class="line">返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">输出：[8,6,2,4]</span><br><span class="line">解释：</span><br><span class="line">开始时，数组为 [1,2,3,4]。</span><br><span class="line">将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。</span><br><span class="line">将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。</span><br><span class="line">将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。</span><br><span class="line">将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= A.length &lt;= 10000</span><br><span class="line">-10000 &lt;= A[i] &lt;= 10000</span><br><span class="line">1 &lt;= queries.length &lt;= 10000</span><br><span class="line">-10000 &lt;= queries[i][0] &lt;= 10000</span><br><span class="line">0 &lt;= queries[i][1] &lt; A.length</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>很简单，把一个数组每次经过指定变化，然后就每次变化后的数组中的偶数和，明显就是可以在变更后直接根据哪里变了更改全部偶数的和，不用每次改完之后重新遍历一遍数组求偶数和。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sumEvenAfterQueries(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[queries.length];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先计算数组中的全部偶数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在每次变更的时候不去重新遍历一遍数组，省去了一个O(n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> val = queries[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果要改变的数是偶数的话就先减了</span></span><br><span class="line">            <span class="keyword">if</span> (a[index]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                sum-=a[index];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//正常变更</span></span><br><span class="line">            a[index]+=val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//变更后如果是偶数就加上</span></span><br><span class="line">            <span class="keyword">if</span> (a[index]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=a[index];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sum-of-even-numbers-after-queries/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-even-numbers-after-queries/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-99. 恢复二叉搜索树</title>
    <url>/2020/08/08/leetcode-99.%20%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉搜索树中的两个节点被错误地交换。</span><br><span class="line"></span><br><span class="line">请在不改变其结构的情况下，恢复这棵树。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>就是找到中序遍历里面发生逆序的地方，如果BST两个节点发生交换，那么这个BST的中序遍历就会产生两个逆序或者一个逆序，两个逆序是当不相邻的节点交换是，一个逆序是相邻的节点交换，所以我们找到这个两个点，然后再进行一次中序遍历，然后过程中去交换两个节点的值</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先把中序遍历结果放到数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        f(root, nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后再找逆序的地方</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>, y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//如果找到逆序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                y = nums[i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//当第一次找到逆序的时候，就把x，y都保留(一组逆序的情况)</span></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">                    x = nums[i];</span><br><span class="line">                    <span class="comment">//当再找到一个逆序的时候，只更新y（两组逆序的情况，保留</span></span><br><span class="line">                    <span class="comment">//第一个逆序的左面，第二个逆序的右面）</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后在这个树中进行交换就完事了</span></span><br><span class="line">        swap(root, <span class="number">2</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把中序遍历的值放到数组里面</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(TreeNode *cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            f(cur-&gt;left, nums);</span><br><span class="line">            nums.push_back(cur-&gt;val);</span><br><span class="line">            f(cur-&gt;right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode *cur, <span class="keyword">int</span> count, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            swap(cur-&gt;left, count, x, y);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == x || cur-&gt;val == y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                    cur-&gt;val = cur-&gt;val == x ? y : x;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(cur-&gt;right, count, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>官方题解写得好         </li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/recover-binary-search-tree/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-989. 数组形式的整数加法</title>
    <url>/2020/02/14/leetcode-989.%20%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。</span><br><span class="line">例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。</span><br><span class="line"></span><br><span class="line">给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2,0,0], K = 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 = 1234</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [2,7,4], K = 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 = 455</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [2,1,5], K = 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 = 1021</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1</span><br><span class="line">输出：[1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">解释：9999999999 + 1 = 10000000000</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>其实完全可以看成模拟字符串的相加，i,j充当从后往前的指针，i，j都是当前加到某一位的指针，在i,j都大于等于0时，指向的还是同一位。当i和j都小于0的时候循环结束，如果i，j有一个小于0，但是另一个还大于等于0 的时候，为0的指针的值用0代替(而且用三目运算符比较好)。</li>
<li>每次相加的时候统计进位，和加完这个数剩下的数。最后循环结束的时候，要特判一下此时进位是不是1，如果是记得再给结果的首位加1。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(k);</span><br><span class="line">        <span class="keyword">int</span> i = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为加完是倒序的，所以先用一个另外的list存起来</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟进位</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = i &gt;= <span class="number">0</span> ? a[i] : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> m = j &gt;= <span class="number">0</span> ? s.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = n + m + carry;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            res1.add(temp % <span class="number">10</span>);</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特判进位是不是1</span></span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">            res1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = res1.size() - <span class="number">1</span>; z &gt;= <span class="number">0</span>; z--) &#123;</span><br><span class="line">            res2.add(res1.get(z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>字符串的相加是一个很好的题。这种做法特别好。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-to-array-form-of-integer/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-999.车的可用捕获量</title>
    <url>/2019/07/24/leetcode-999.%20%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。</span><br><span class="line">它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</span><br><span class="line"></span><br><span class="line">车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），</span><br><span class="line">然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。</span><br><span class="line">另外，车不能与其他友方（白色）象进入同一个方格。</span><br><span class="line"></span><br><span class="line">返回车能够在一次移动中捕获到的卒的数量。</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">       [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">       [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],</span><br><span class="line">       [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">       [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">       [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">       [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">       [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">在本例中，车能够捕获所有的卒。</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入 :   [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">        [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">        [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">        [&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">        [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">        [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">        [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">        [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">      [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">      [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">      [&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],</span><br><span class="line">      [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">      [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">      [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">      [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释： </span><br><span class="line">车可以捕获位置 b5，d6 和 f5 的卒。</span><br></pre></td></tr></table></figure>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>就是在R的4个方向找p,一个方向最多找一个，碰到B停下，模拟四个方向就好了。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = a.length;</span><br><span class="line">        <span class="keyword">int</span> col = a[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ki = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> kj = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]==<span class="string">'R'</span>)&#123;</span><br><span class="line">                    ki = i;</span><br><span class="line">                    kj = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=ki-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][kj]==<span class="string">'B'</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i][kj] == <span class="string">'p'</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=ki+<span class="number">1</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][kj]==<span class="string">'B'</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i][kj] == <span class="string">'p'</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=kj-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[ki][j]==<span class="string">'B'</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[ki][j] == <span class="string">'p'</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=kj+<span class="number">1</span>; j&lt;col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[ki][j]==<span class="string">'B'</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[ki][j] == <span class="string">'p'</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li>水题</li>
</ul>
<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/available-captures-for-rook/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-util 把数组变成二叉树</title>
    <url>/2019/10/16/leetcode-util.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E9%80%A0%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">q = deque()</span><br><span class="line"><span class="comment"># e就是数组总共要放的全部的值(包括value和None)的个数</span></span><br><span class="line">e = len(l)</span><br><span class="line"><span class="comment"># s表示存放数组的个数</span></span><br><span class="line">s = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">root = TreeNode(l[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 用队列存放最先放值得节点</span></span><br><span class="line">q.append(root)</span><br><span class="line"><span class="keyword">while</span> s != e:</span><br><span class="line">    <span class="comment"># 每次队列首都是要存放数组值，val或者None</span></span><br><span class="line">    cur = q.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 首先往左子树放值</span></span><br><span class="line">    <span class="keyword">if</span> l[s] != <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 左子树应存放得值不是None时，就放值，并且往队列中放cur</span></span><br><span class="line">        cur.left = TreeNode(l[s])</span><br><span class="line">        q.append(cur.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果数组中对应得值时None，那么就往数组对应得地方放None。</span></span><br><span class="line">        cur.left = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># s</span></span><br><span class="line">    s += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 因为循环的原因，每放一个值之后都判断一下数组中的内容是否全部放完，以防越界</span></span><br><span class="line">    <span class="keyword">if</span> s == e:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 右子树同左子树</span></span><br><span class="line">    <span class="keyword">if</span> l[s] != <span class="literal">None</span>:</span><br><span class="line">        cur.right = TreeNode(l[s])</span><br><span class="line">        q.append(cur.right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur.right = <span class="literal">None</span></span><br><span class="line">    s += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s == e:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>用s记录已经存放的个数，e表示数组的长度，也是存放的全部元素的个数。每往树中放一个元素后，s就加一，直到s和e相等的时候，就表明全部的元素放完了。每次处理队列首的元素，取出队列首的元素cur之后，首先把数组的值放到cur的左子树(索引s对应的地方)，再把数组的值放到cur的右子树，在把数组的值放到树中的过程的时候，如果放到树中的值不是null的话就把节点放到队列中。因为每次要放的值都是最新的节点下面。</p>
<h1 id="刚开始递归得写法"><a href="#刚开始递归得写法" class="headerlink" title="刚开始递归得写法"></a>刚开始递归得写法</h1><p>一开始想法是：如果数组按照二叉树的索引给值的话，就可以用递归的形式来造一棵树。（原理同把一个数组转换成一个二叉堆）。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(self, cur, l, index)</span>:</span></span><br></pre></td></tr></table></figure>

<p>递归的操作内容就是：把l[index]的值赋给cur节点里面，每次递归返回构造完之后的cur的引用值。不过递归要做好最后一层的处理，也就是递归到底的处理，如果递归到底不做最后一层的判断的话，就返回的null节点，这样就会比应该造成的树多一层，所以递归到底的情况就是最后一层，那么递归到底的做法自然就很简单了，就是返回值为l[index]的TreeNode节点。那么如果不是递归到底的情况，就是以同样的方法构造cur的左子树，cur的右子树，然后返回cur节点。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRoot</span><span class="params">(self)</span>:</span></span><br><span class="line">        root = TreeNode(l[<span class="number">0</span>])</span><br><span class="line">        root = self.recurse(root,l,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(self, cur, l, index)</span>:</span></span><br><span class="line">        <span class="comment"># 左最后一层的特判，如果是最后一层就直接返回节点</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= len(l)//<span class="number">2</span> <span class="keyword">and</span> index&lt;len(l):</span><br><span class="line">            <span class="keyword">if</span> l[index]!=<span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> TreeNode(l[index])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 给当前节点赋值</span></span><br><span class="line">        <span class="keyword">if</span> l[index]!=<span class="literal">None</span>:</span><br><span class="line">            cur = TreeNode(l[index])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 给左子树赋值</span></span><br><span class="line">        <span class="keyword">if</span> index*<span class="number">2</span>+<span class="number">1</span>&lt;len(l):</span><br><span class="line">            cur.left = self.recurse(cur.left,l,index*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 给右子树赋值</span></span><br><span class="line">        <span class="keyword">if</span> index*<span class="number">2</span>+<span class="number">2</span>&lt;len(l):</span><br><span class="line">            cur.right = self.recurse(cur.right,l,index*<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回当前cur节点的引用值</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode- LCP 1. 猜数字</title>
    <url>/2019/11/07/leetcode-LCP%201.%20%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</span><br><span class="line">输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess = [1,2,3], answer = [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：小A 每次都猜对了。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess = [2,2,3], answer = [3,2,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：小A 只猜对了第二次。</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guess的长度 = 3</span><br><span class="line">answer的长度 = 3</span><br><span class="line">guess的元素取值为 &#123;1, 2, 3&#125; 之一。</span><br><span class="line">answer的元素取值为 &#123;1, 2, 3&#125; 之一。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>leetcode最简单的一道题咯，看两个数组中有几个值一样</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">(self, a: List[int], b: List[int])</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a)):</span><br><span class="line">            <span class="keyword">if</span> a[i] == b[i]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/guess-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/guess-numbers/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-LCP 06. 拿硬币</title>
    <url>/2020/07/15/leetcode-LCP%2006.%20%E6%8B%BF%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以</span><br><span class="line">选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,2,1]</span><br><span class="line"></span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 </span><br><span class="line">1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,2,1]</span><br><span class="line"></span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 </span><br><span class="line">1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一堆一堆的拿，偶数个数拿的次数就是个数除以2，奇数个数就是除以2加一。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v:coins) &#123;</span><br><span class="line">            <span class="comment">//直接计算次数</span></span><br><span class="line">            res += v % <span class="number">2</span> == <span class="number">0</span> ? v / <span class="number">2</span> : v / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/na-ying-bi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/na-ying-bi/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 54. 二叉搜索树的第k大节点</title>
    <url>/2020/09/07/leetcode-%E5%89%91%E6%8C%87%20Offer%2054.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一棵二叉搜索树，请找出其中第k大的节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>可以倒序中序遍历，也就是访问下来是从大到小的，也就是从第一大访问到最后一大，每次访问节点的时候可以计数，然后当到第K个节点的时候直接返回结果就OK。中序遍历可以用非递归优化。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                <span class="comment">//倒序中序，先看右节点</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                <span class="comment">//每次访问节点的时候计数器加一</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">//当到了第K个节点的时候直接返回结果就行</span></span><br><span class="line">                <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cur.val;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题 04.01. 节点间通路</title>
    <url>/2020/09/09/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98%2004.01.%20%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4</span><br><span class="line">输出 true</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>bfs层序遍历就可以判断两个节点是否有通路，不过注意先把图转换成邻接表，然后尽心bfs层序遍历。把访问过的节点加访问标记。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(book, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//构造邻接表,集合数组，就很神奇</span></span><br><span class="line">        List&lt;Integer&gt;[] adj = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="comment">//给每个数组中的集合元素赋初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="comment">//把每个边的起始点和终点拿出来</span></span><br><span class="line">            <span class="keyword">int</span> l = graph[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r = graph[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//以邻接表的方式存储</span></span><br><span class="line">            adj[l].add(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从start开始bfs</span></span><br><span class="line">        queue.add(start);</span><br><span class="line">        book[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">//每次拿到新点</span></span><br><span class="line">                Integer remove = queue.remove();</span><br><span class="line">                <span class="comment">//如果是终点自然就说明有通路</span></span><br><span class="line">                <span class="keyword">if</span> (remove == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//remove点作为起点，从邻接表里面找remove点</span></span><br><span class="line">                <span class="comment">//相连的终点</span></span><br><span class="line">                <span class="keyword">for</span> (Integer j : adj[remove]) &#123;</span><br><span class="line">                    <span class="comment">//终点必须没有走过</span></span><br><span class="line">                    <span class="keyword">if</span> (book[j] != <span class="number">1</span>) &#123;</span><br><span class="line">                        book[j] = <span class="number">1</span>;</span><br><span class="line">                        queue.add(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>集合数组，数组里面的元素都是集合，这种情况记得给集合开辟空间</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/route-between-nodes-lcci/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题 16.11. 跳水板</title>
    <url>/2020/07/08/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98%2016.11.%20%E8%B7%B3%E6%B0%B4%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，</span><br><span class="line">长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</span><br><span class="line"></span><br><span class="line">返回的长度需要从小到大排列。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter = 1</span><br><span class="line">longer = 2</span><br><span class="line">k = 3</span><br><span class="line">输出： &#123;3,4,5,6&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>自然是可以用递归的，于是首先递归K次，每次递归选择不同的数字，最后结果统计去重。但是超时。</li>
<li>然后想到，既然是两个数字里面，选k次，那无非就是每个数字出现的次数分别是0到K，另一个数字是K到0，也就是这么多个结果里面，无非就是选a或者选b，那就选a的次数逐渐增加，选b的次数逐渐减少，一定能枚举出来所有的数字组合。甚至都不需要排序，因为假如a是小的数，b是大的数，a的次数逐渐增加，b的次数逐渐减少，结果一定是从小到大的。</li>
<li>第二个方法还需要一个去重，因为插入的顺序是从小到大插入的，所以每次插入结果的时候，都与上一个结果进行比较就行，不需要全盘搜索。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">divingBoard</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dfs(a, b, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">        sort(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> count, <span class="keyword">int</span> k, <span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果递归到k层的时候</span></span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            <span class="comment">//查看保存结果的集合里面有没有这个数，没有就加进去</span></span><br><span class="line">            <span class="keyword">if</span> (find(res.begin(), res.end(), temp + a) == res.end()) &#123;</span><br><span class="line">                res.push_back(temp + a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find(res.begin(), res.end(), temp + b) == res.end()) &#123;</span><br><span class="line">                res.push_back(temp + a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改temp，继续递归</span></span><br><span class="line">        dfs(a, b, count + <span class="number">1</span>, k, temp + a);</span><br><span class="line">        dfs(a, b, count + <span class="number">1</span>, k, temp + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="枚举-超时"><a href="#枚举-超时" class="headerlink" title="枚举(超时)"></a>枚举(超时)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">divingBoard</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//i是b出现的次数，k-i就是a出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i * b + a * (k - i);</span><br><span class="line">            <span class="comment">//看集合里面有没有这个数，如果没有再插入</span></span><br><span class="line">            <span class="keyword">if</span> (find(res.begin(), res.end(), temp) == res.end()) &#123;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="枚举（记录上一个插入的数）"><a href="#枚举（记录上一个插入的数）" class="headerlink" title="枚举（记录上一个插入的数）"></a>枚举（记录上一个插入的数）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">divingBoard</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//先给pre赋值一个奇怪的值</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = i * b + a * (k - i);</span><br><span class="line">                <span class="comment">//如果要插入的值不是上一次出现的</span></span><br><span class="line">                <span class="keyword">if</span> (temp != pre) &#123;</span><br><span class="line">                    <span class="comment">//就插入</span></span><br><span class="line">                    res.push_back(temp);</span><br><span class="line">                    <span class="comment">//并且更新pre值</span></span><br><span class="line">                    pre = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果第一个，可以直接更新pre</span></span><br><span class="line">                <span class="keyword">int</span> temp = i * b + a * (k - i);</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                pre = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/diving-board-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diving-board-lcci/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 04.03. 特定深度节点链表</title>
    <url>/2020/09/07/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98%2004.03.%20%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若</span><br><span class="line">一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,null,7,8]</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       /  \ </span><br><span class="line">      2    3</span><br><span class="line">     / \    \ </span><br><span class="line">    4   5    7</span><br><span class="line">   /</span><br><span class="line">  8</span><br><span class="line"></span><br><span class="line">输出：[[1],[2,3],[4,5,7],[8]]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>层序遍历，给每一层的节点创建链表，插入到结果集中、</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] listOfDepth(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ListNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">//记录深度</span></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> times = queue.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="comment">//head是头指针</span></span><br><span class="line">            ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//pre是尾指针</span></span><br><span class="line">            ListNode head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">                TreeNode temp = queue.remove();</span><br><span class="line">                <span class="comment">//链表为空时</span></span><br><span class="line">                <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pre = <span class="keyword">new</span> ListNode(temp.val);</span><br><span class="line">                    head = pre;</span><br><span class="line">                <span class="comment">//链表有节点时直接插入到链表尾部</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.next = <span class="keyword">new</span> ListNode(temp.val);</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//插入下一层的节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把这一层的链表插入到结果集里面</span></span><br><span class="line">            ans.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换结果</span></span><br><span class="line">        ListNode[] aans = <span class="keyword">new</span> ListNode[depth];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">            aans[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/list-of-depth-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/list-of-depth-lcci/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题 08.02. 迷路的机器人</title>
    <url>/2020/02/17/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98%2008.02.%20%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。</span><br><span class="line">机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。</span><br><span class="line">设计一种算法，寻找机器人从左上角移动到右下角的路径。</span><br><span class="line"></span><br><span class="line">网格中的障碍物和空位置分别用 1 和 0 来表示。</span><br><span class="line"></span><br><span class="line">返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]</span><br><span class="line">解释: </span><br><span class="line">输入中标粗的位置即为输出表示的路径，即</span><br><span class="line">0行0列（左上角） -&gt; 0行1列 -&gt; 0行2列 -&gt; 1行2列 -&gt; 2行2列（右下角）</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>常规的dfs，每次递归的时候加标记数组，采用中间的temp集合，并且坐标判断是否越界，当坐标为右下角的时候记录结果就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] book;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathWithObstacles(<span class="keyword">int</span>[][] a) &#123;</span><br><span class="line">        book = <span class="keyword">new</span> <span class="keyword">boolean</span>[a.length][a[<span class="number">0</span>].length];</span><br><span class="line">        <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">int</span> x = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = a[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        dfs(a, <span class="number">0</span>, <span class="number">0</span>, x, y);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经找到终点</span></span><br><span class="line">        <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= a.length || i &lt; <span class="number">0</span> || j &gt;= a[<span class="number">0</span>].length || j &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i][j]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == x &amp;&amp; j == y) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            temp.add(i);</span><br><span class="line">            temp.add(j);</span><br><span class="line">            res.add(temp);</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走过</span></span><br><span class="line">        <span class="keyword">if</span> (book[i][j])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        book[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        temp.add(i);</span><br><span class="line">        temp.add(j);</span><br><span class="line">        <span class="comment">//算上这个点去dfs</span></span><br><span class="line">        res.add(temp);</span><br><span class="line">        dfs(a, i, j + <span class="number">1</span>, x, y);</span><br><span class="line">        <span class="comment">//因为要剪枝，所以这里加一个特判，防止删除掉结果里的坐标</span></span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">        res.add(temp);</span><br><span class="line">        <span class="comment">//因为要剪枝，所以这里加一个特判，防止删除掉结果里的坐标</span></span><br><span class="line">        dfs(a, i + <span class="number">1</span>, j, x, y);</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//为了递归下一个点，要把这个点去除掉。</span></span><br><span class="line">        res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>越界判断要在前面。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/robot-in-a-grid-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/robot-in-a-grid-lcci/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题 17.13. 恢复空格</title>
    <url>/2020/07/09/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98%2017.13.%20%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写</span><br><span class="line">。像句子&quot;I reset the computer. It still didn’t boot!&quot;已经变成了&quot;</span><br><span class="line">iresetthecomputeritstilldidntboot&quot;。在处理标点符号和大小写之前，你得</span><br><span class="line">先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词</span><br><span class="line">典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符</span><br><span class="line">最少，返回未识别的字符数。</span><br><span class="line"></span><br><span class="line">注意：本题相对原题稍作改动，只需返回未识别的字符数</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">dictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]</span><br><span class="line">sentence = &quot;jesslookedjustliketimherbrother&quot;</span><br><span class="line">输出： 7</span><br><span class="line">解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/re-space-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>dp的思路用的是<a href="https://leetcode-cn.com/problems/re-space-lcci/solution/shou-hua-tu-jie-dp-si-lu-by-hyj8-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/re-space-lcci/solution/shou-hua-tu-jie-dp-si-lu-by-hyj8-2/</a></li>
<li>字典树的优化用的是官方题解<a href="https://leetcode-cn.com/problems/re-space-lcci/solution/hui-fu-kong-ge-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/re-space-lcci/solution/hui-fu-kong-ge-by-leetcode-solution/</a></li>
<li>从字符串数组中寻找一个字符串用字典树，最好。      </li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="倒序字典树，dp"><a href="#倒序字典树，dp" class="headerlink" title="倒序字典树，dp"></a>倒序字典树，dp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    node *next[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">bool</span> isWord) : isWord(isWord) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">respace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;dic, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        node *root = <span class="keyword">new</span> node(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> str:dic) &#123;</span><br><span class="line">            insert(root, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>, inf)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            node *cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s[j] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;next[t] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;next[t]-&gt;isWord) &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;next[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *root, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        node *cur = root;</span><br><span class="line">        <span class="keyword">int</span> len = str.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="comment">//如果没有找到这个字符</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next[c] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur-&gt;next[c] = <span class="keyword">new</span> node(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;isWord) &#123;</span><br><span class="line">            cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>字典树<br>节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    node *next[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">bool</span> isWord) : isWord(isWord) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>插入字符串和查询字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *root, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        node *cur = root;</span><br><span class="line">        <span class="keyword">int</span> len = str.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str[i];</span><br><span class="line">            <span class="comment">//如果没有找到这个字符</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next.find(c) == cur-&gt;next.end()) &#123;</span><br><span class="line">                cur-&gt;next[c] = <span class="keyword">new</span> node(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;isWord) &#123;</span><br><span class="line">            cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(node *root, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        node *cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str[i];</span><br><span class="line">            <span class="comment">//如果字典树里面没有找到这个节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next.find(c) == cur-&gt;next.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;isWord;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题 17.16. 按摩师</title>
    <url>/2020/03/24/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98%2017.16.%20%E6%8C%89%E6%91%A9%E5%B8%88/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。</span><br><span class="line">在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约</span><br><span class="line">请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</span><br><span class="line"></span><br><span class="line">注意：本题相对原题稍作改动</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和</span><br><span class="line"> 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一种很棒的方法，在做动态规划之前先考虑递归，比如说我这个递归函数的作用就是获得从第start个房子开始偷的最大值，那么在函数体中，一定是要么偷这个房子，要么不偷这个房子，那如果偷这个第start个房子的话，那么之后就是dfs(start+2)+nums[i]这么走，如果不偷这个第start个房子呢，那一定是dfs(start+1)这么走。返回一个最大值就好了。</li>
<li>递归完了之后，就知道状态转移怎么写了，我们知道对于每个start，他有两种选择，一种是选择dfs(start+2)+nums[start]，或者是选择dfs(start+1)，那么就可以推算出来，对于每个 dp[i]的值，一定是从dp[i-2]+nums[i]，或者是dp[i-1]里面选一个大的。所以状态转移方程就是dp[i]=max(dp[i+2]+nums[i],dp[i+1])。所以我们队dp数组进行倒序赋值。</li>
<li>然后又发现每次递归的时候其实都是看的是临近的几个状态，所以临近的几个状态不用一个数组，用几个变量互相更迭就可以了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归-没有剪枝，超时"><a href="#递归-没有剪枝，超时" class="headerlink" title="递归(没有剪枝，超时)"></a>递归(没有剪枝，超时)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//返回从第start个房子开始偷的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于这个房子有两种选择，要么偷，要么不偷</span></span><br><span class="line">        <span class="comment">//前者是偷这个第start房子，后者是不偷这第start个房子</span></span><br><span class="line">        <span class="keyword">return</span> max(dfs(nums, start + <span class="number">2</span>) + nums[start], dfs(nums, start + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="使用标记数组进行剪枝"><a href="#使用标记数组进行剪枝" class="headerlink" title="使用标记数组进行剪枝"></a>使用标记数组进行剪枝</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">//标记数组剪枝</span></span><br><span class="line">        <span class="keyword">int</span> book[<span class="number">20000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(book, <span class="number">-1</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> *book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明走过</span></span><br><span class="line">        <span class="keyword">if</span> (book[start] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> book[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = max(dfs(nums, start + <span class="number">2</span>, book) + nums[start], dfs(nums, start + <span class="number">1</span>, book));</span><br><span class="line">        book[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="模仿递归，倒序动态规划"><a href="#模仿递归，倒序动态规划" class="headerlink" title="模仿递归，倒序动态规划"></a>模仿递归，倒序动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">20000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">//可以发现这里和递归的规则一模一样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i] = max(dp[i + <span class="number">2</span>] + nums[i], dp[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="消除一个dp空间"><a href="#消除一个dp空间" class="headerlink" title="消除一个dp空间"></a>消除一个dp空间</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把a[i]和a[i+1]和a[i+2]缩减到3个变量</span></span><br><span class="line">        <span class="comment">//v1是a[i+1]</span></span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//v2是a[i+2]</span></span><br><span class="line">        <span class="keyword">int</span> v2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//res是a[n]</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> t1 = v1;</span><br><span class="line">            <span class="keyword">int</span> t2 = v2;</span><br><span class="line">            res = max(t1, t2 + nums[i]);</span><br><span class="line">            v2 = v1;</span><br><span class="line">            v1 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>做动态规划，考虑状态之后，递归，然后可以递归加标记数组进行剪枝，也可以直接根据递归的规律写和递归一样的顺序的动态规划，然后考虑能不能对动态规划进行空间优化</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-masseuse-lcci/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题12. 矩阵中的路径</title>
    <url>/2020/03/23/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9812.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</span><br><span class="line">路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。</span><br><span class="line">如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的</span><br><span class="line">3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</span><br><span class="line"></span><br><span class="line">[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],</span><br><span class="line">[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],</span><br><span class="line">[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]</span><br><span class="line"></span><br><span class="line">但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第</span><br><span class="line">一行第二个格子之后，路径不能再次进入这个格子。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],</span><br><span class="line">[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line"></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= board.length &lt;= 200</span><br><span class="line">1 &lt;= board[i].length &lt;= 200</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>寻路问题，这种寻路问题尽量不要使用全局变量，然后dfs返回值是void，并且dfs内部就让他朝4个方向进行dfs，因为这种方法，是每次对一个点进行dfs，</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="全局变量dfs-错误"><a href="#全局变量dfs-错误" class="headerlink" title="全局变量dfs(错误)"></a>全局变量dfs(错误)</h2><p>这种方法最大的问题是，如果在dfs中走错了方向，比如说某次dfs的时候先向下是正确的，但是加入这里选择了向左，这就得不到正确答案了，因为从一个位置到另一个位置，只有一个起点，那么你在从这个起点开始dfs之后，一旦在路上选错了方向，那么你不管在dfs中再怎么走，都得不到正确答案。</p>
<p>错误的根本原因是，你标记走没有走过是用一个二维数组来标记的，每次重新选择起点之后刷新标记数组，那么这种是做不到在dfs内对于错误的递归方向进行修正的。因为dfs中不管怎么样一定有正确方向和错误方向，如果采用这种标记方式，那么正确方向的dfs是会受错误方向的dfs影响的。因为错误方向已经走过的地方，正确方向是不能再走的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = board.size();</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="comment">//每次对一个点进行dfs，并且判断走没走过是用一个标记数组</span></span><br><span class="line">                <span class="comment">//来实现的。</span></span><br><span class="line">                <span class="built_in">memset</span>(book, <span class="literal">false</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">                dfs(board, word, i, j, <span class="number">0</span>, rows, cols);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> book[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> index, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.size()) &#123;</span><br><span class="line">            res = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果越界</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= rows || y &lt; <span class="number">0</span> || y &gt;= cols)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果走过</span></span><br><span class="line">        <span class="keyword">if</span> (book[x][y])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果没有走到正确的字符</span></span><br><span class="line">        <span class="keyword">if</span> (word[index] != board[x][y])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        book[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//朝4个方向dfs</span></span><br><span class="line">        dfs(board, word, x + <span class="number">1</span>, y, index + <span class="number">1</span>, rows, cols);</span><br><span class="line">        dfs(board, word, x - <span class="number">1</span>, y, index + <span class="number">1</span>, rows, cols);</span><br><span class="line">        dfs(board, word, x, y + <span class="number">1</span>, index + <span class="number">1</span>, rows, cols);</span><br><span class="line">        dfs(board, word, x, y - <span class="number">1</span>, index + <span class="number">1</span>, rows, cols);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="修改走过的路径"><a href="#修改走过的路径" class="headerlink" title="修改走过的路径"></a>修改走过的路径</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = board.size();</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i, j, <span class="number">0</span>, rows, cols))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> index, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= rows || y &lt; <span class="number">0</span> || y &gt;= cols || board[x][y] != word[index])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == word.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//通过重新赋值board里面值，比如把值换成'/'，</span></span><br><span class="line">        <span class="keyword">char</span> temp = board[x][y];</span><br><span class="line">        board[x][y] = <span class="string">'/'</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = dfs(board, word, x + <span class="number">1</span>, y, index + <span class="number">1</span>, rows, cols) ||</span><br><span class="line">                   dfs(board, word, x - <span class="number">1</span>, y, index + <span class="number">1</span>, rows, cols) ||</span><br><span class="line">                   dfs(board, word, x, y + <span class="number">1</span>, index + <span class="number">1</span>, rows, cols) ||</span><br><span class="line">                   dfs(board, word, x, y - <span class="number">1</span>, index + <span class="number">1</span>, rows, cols);</span><br><span class="line">        <span class="comment">//然后每次走过一次之后，重新把值给变回去,这样不仅达到标记的作用，并且</span></span><br><span class="line">        <span class="comment">//还能避免错误方向，也就是说就算这种dfs走到了错误方向，那么对于正确方向来说，</span></span><br><span class="line">        <span class="comment">//正确方向的dfs是不受错误方向的dfs干扰的。</span></span><br><span class="line">        board[x][y] = temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>在寻路问题里面，最好使用在递归中标记走过的路，并且在每个递归的所有方向走过之后，再把这个走过的路变回去，这样不让这个方向的dfs的寻路影响到其他方向的dfs。</li>
<li>递归问题中，尽量不要使用全局变量来标记递归某个点是否走过(除过必须要标记的，比如斐波那锲序列这种递归剪枝)，尽量在递归中使用某种方法(比如把这个点变成一个特殊值)对这个点进行标记，然后变换之后进行递归之后再把这个点变成原来的样子，这么做的目的是为了不影响其他点的递归或者这个点的另外的递归。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>dfs</tag>
        <tag>寻路问题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题13. 机器人的运动范围</title>
    <url>/2020/04/08/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9813.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机</span><br><span class="line">器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动</span><br><span class="line">一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k</span><br><span class="line">的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+</span><br><span class="line">5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该</span><br><span class="line">机器人能够到达多少个格子？</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>bfs每次对4个点进行访问。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//标记数组</span></span><br><span class="line">    <span class="keyword">int</span> book[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">    <span class="comment">//方向数组</span></span><br><span class="line">    <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//给标记数组赋值</span></span><br><span class="line">        <span class="built_in">memset</span>(book, <span class="number">0</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">//插入起点</span></span><br><span class="line">        q.push(make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> x = p.first;</span><br><span class="line">            <span class="keyword">int</span> y = p.second;</span><br><span class="line">            <span class="comment">//越界</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//说明走过</span></span><br><span class="line">            <span class="keyword">if</span> (book[x][y] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果这个点不能走</span></span><br><span class="line">            <span class="keyword">if</span> (!is_move(x, y, k))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//标记当前位置</span></span><br><span class="line">            book[x][y] = <span class="number">1</span>;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="comment">//对四个方向进行bfs</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dr[i];</span><br><span class="line">                <span class="keyword">int</span> ny = y + dc[i];</span><br><span class="line">                q.push(make_pair(nx, ny));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前位置能不能走</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_move</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            t = t + i % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            t = t + j % <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t &lt;= k ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>常规bfs</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题22. 链表中倒数第k个节点</title>
    <url>/2020/03/16/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9822.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题</span><br><span class="line">从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，</span><br><span class="line">从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>倒数第k个节点就是正数第x个节点，先跑一遍链表知道链表的长度len，然后用len减去k就是x，然后从头遍历x次，就是倒数第K个节点</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> times = len - k;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (i != times) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题26. 树的子结构</title>
    <url>/2020/03/26/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9826.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span><br><span class="line"></span><br><span class="line">B是A的子结构， 即 A中有出现和B相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 B：</span><br><span class="line"></span><br><span class="line">   4 </span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>因为第二棵树是第一棵树的子树嘛，所以可以先序遍历树a，当找到和b相同的节点的时候，就对此时的a节点和b节点进行一次具有相同的根的是不是包含的一次判断。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode *A, TreeNode *B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        dfs(A, B);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历a</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *cur, TreeNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当找到和b相同的节点的时候吗，此时对a和b进行一次验证，</span></span><br><span class="line">        <span class="comment">//看b是不是以此时的a的节点为根的一棵a的子树的子树c，</span></span><br><span class="line">        <span class="comment">//要明白b可能和c相同，也可能是c的子树，只不过c和b具有相同的根</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == b-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ans) &#123;</span><br><span class="line">                ans = verify(cur, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(cur-&gt;left, b);</span><br><span class="line">        dfs(cur-&gt;right, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verify</span><span class="params">(TreeNode *root1, TreeNode *root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec_verify(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归验证</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rec_verify</span><span class="params">(TreeNode *cur1, TreeNode *cur2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里很巧妙，因为b可能和c相同，也可能是c的子树，所以这里不能对cur1和cur2做</span></span><br><span class="line">        <span class="comment">//同时判断，因为做同时判断那是对于判定b和c是否完全相同来做的，这里只要cur2是空</span></span><br><span class="line">        <span class="comment">//就返回true，因为b可能是c的子树，</span></span><br><span class="line">        <span class="keyword">if</span> (cur2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cur1是空，那么自然两棵树不一样，b既不可能是c的子树，可不可能和c相同</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果两者节点不一样，那更不可能了</span></span><br><span class="line">        <span class="keyword">if</span> (cur1-&gt;val != cur2-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前节点判断完了，还要递归判断子树呢</span></span><br><span class="line">        <span class="keyword">return</span> rec_verify(cur1-&gt;left, cur2-&gt;left) &amp;&amp; rec_verify(cur1-&gt;right, cur2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>遇到相同根，判断树b是不是树c的子树的时候，要对遍历时中间节点cur1和cur2要分开判断，不能一起判断，因为一起判断无法判断b是c的子树的情况，只能判断b和c是否完全一样的状态。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题42. 连续子数组的最大和</title>
    <url>/2020/03/23/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9842.%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个</span><br><span class="line">整数组成一个子数组。求所有子数组的和的最大值。</span><br><span class="line"></span><br><span class="line">要求时间复杂度为O(n)。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>动态规划做，dp[i]表示以nums[i]结尾的子数组的最大值，那么dp[i+1]和dp[i]的关系，如果dp[i]是正的，dp[i+1]就是dp[i]+nums[i]，如果dp[i]是负的，那么dp[i+1]就是nums[i]。</li>
<li>或者二重循环拿到所有的子数组，分别求和，然后记录最大值就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]代表以nums[i]结尾的所有的子数组的最大值。</span></span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">100000</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(dp[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二重循环-超时"><a href="#二重循环-超时" class="headerlink" title="二重循环(超时)"></a>二重循环(超时)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">            res = max(sum, res);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                res = max(sum, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归找自然状态"><a href="#递归找自然状态" class="headerlink" title="递归找自然状态"></a>递归找自然状态</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用map做剪枝</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        dfs(nums, nums.size() - <span class="number">1</span>, <span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> max(ans, nums[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示以索引end为结尾的最大子数组和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> end, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;<span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果发现之前计算过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.find(end) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>[end];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = nums[end];</span><br><span class="line">        <span class="comment">//计算dfs(end)的时候，先计算dfs(end-1)是不是正的</span></span><br><span class="line">        <span class="keyword">int</span> temp = dfs(nums, end - <span class="number">1</span>, <span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">//如果是</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//dfs(end)就是dfs(end-1)+nums[end]</span></span><br><span class="line">            res += temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录一下最大值</span></span><br><span class="line">        ans = max(res, ans);</span><br><span class="line">        <span class="comment">//将走过的地方保存起来</span></span><br><span class="line">        <span class="built_in">map</span>[end] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="找到递归规律之后，消除dp一维状态"><a href="#找到递归规律之后，消除dp一维状态" class="headerlink" title="找到递归规律之后，消除dp一维状态"></a>找到递归规律之后，消除dp一维状态</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = pre;</span><br><span class="line">            <span class="keyword">int</span> res = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += temp;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, res);</span><br><span class="line">            pre = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题55 - I. 二叉树的深度</title>
    <url>/2020/03/19/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9855%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（</span><br><span class="line">含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>递归，每个节点的深度是这个节点的左孩子深度和右孩子的深度的最大值加一。最后拿到根节点的深度就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode *cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为cur是指针，所以用指针访问必须是 -&gt;</span></span><br><span class="line">        <span class="keyword">int</span> left = getDepth(cur-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(cur-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题27. 二叉树的镜像</title>
    <url>/2020/02/17/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9827.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span><br><span class="line"></span><br><span class="line">例如输入：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">镜像输出：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>递归的时候交换cur节点的左右孩子就行了</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode t = cur.left;</span><br><span class="line">        cur.left = cur.right;</span><br><span class="line">        cur.right = t;</span><br><span class="line"></span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-409. 最长回文串</title>
    <url>/2020/03/20/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9840.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、</span><br><span class="line">2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;= k &lt;= arr.length &lt;= 10000</span><br><span class="line">0 &lt;= arr[i] &lt;= 10000</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>首先可以用最大堆，最大堆存k个数，然后遍历数组，然后数组里面的数如果大于堆顶的数，就将堆顶弹出，压入数组新元素。代码很简单就不解释了。</li>
<li>直接排序，然后找前K个元素。</li>
<li>partition操作。因为索引是从0到arr.size()-1，所以要寻找前K个数，只需要将partition的返回值是K的时候就完成了。但是这里要注意因为patition的返回值是0~arr.size()-1，当K大于等于arr.size()的时候需要特判。当K==0的时候也需要特判。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; k) &#123;</span><br><span class="line">            q.push(arr[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = k; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; q.top()) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == arr.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = arr.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分一直寻找partition的返回值，直到返回值等于k</span></span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, l, r);</span><br><span class="line">        <span class="keyword">while</span> (index != k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; k) &#123;</span><br><span class="line">                l = index + <span class="number">1</span>;</span><br><span class="line">                index = partition(arr, l, r);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; k) &#123;</span><br><span class="line">                r = index - <span class="number">1</span>;</span><br><span class="line">                index = partition(arr, l, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//patition操作</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, i, j, t;</span><br><span class="line">        x = a[r];</span><br><span class="line">        i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t = a[i + <span class="number">1</span>];</span><br><span class="line">        a[i + <span class="number">1</span>] = a[r];</span><br><span class="line">        a[r] = t;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>快排</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题59 - I. 滑动窗口的最大值</title>
    <url>/2019/07/25/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9859%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>首先用一个双端队列窗口，每次滑动的时候计算最大值。</li>
<li>采用剑指offer的思路，用双端队列存储索引。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="每次计算滑动窗口的最大值"><a href="#每次计算滑动窗口的最大值" class="headerlink" title="每次计算滑动窗口的最大值"></a>每次计算滑动窗口的最大值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            q.push_back(nums[i]);</span><br><span class="line">        res.push_back(getMax(q));</span><br><span class="line">        <span class="comment">//每次计算每个窗口的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            q.pop_front();</span><br><span class="line">            q.push_back(nums[i]);</span><br><span class="line">            res.push_back(getMax(q));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//计算这个窗口的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; res) &#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="存储索引"><a href="#存储索引" class="headerlink" title="存储索引"></a>存储索引</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//每次把窗口中比新数小的全都排除</span></span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[i] &gt; nums[q.back()])</span><br><span class="line">                q.pop_back();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//排出后加入新的数的索引</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//每次队首元素就是这个窗口最大值的索引</span></span><br><span class="line">            res.push_back(nums[q.front()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次把窗口中比新数小的全都排除</span></span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[i] &gt; nums[q.back()])</span><br><span class="line">                q.pop_back();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次把"过期的索引排除"，因为开头的索引可能不是这个窗口范围内的索引</span></span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; q.front() &lt;= i - k)</span><br><span class="line">                q.pop_front();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//放入新的索引</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次i处理的都是[i-k,i-1]这个范围的窗口，所以最后少一次</span></span><br><span class="line">        res.push_back(nums[q.front()]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>用双端队列存索引就很神奇，根据不同的规则从后面和前面拿出不合适的索引。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题62. 圆圈中最后剩下的数字</title>
    <url>/2020/03/30/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9862.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第</span><br><span class="line">m个数字。求出这个圆圈里剩下的最后一个数字。</span><br><span class="line"></span><br><span class="line">例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个</span><br><span class="line">数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= n &lt;= 10^5</span><br><span class="line">1 &lt;= m &lt;= 10^6</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的是用队列，然后模拟一下每次从队列里面拿出当前队里第m个元素，直到最后队列只剩下一个元素的时候，就是结果了，但是超时(牛客不超时)</li>
<li>然后就是约瑟夫环，数学定理，我只会个公式，假设最后一个安全的元素在最后一趟的坐标是x(最后一趟x一定等于0)，然后倒数第二层的安全元素就是 x = (x+m)%i ，m是间隔的人数，i就是x的上一轮的总个数。、</li>
<li>第二种方法的题解：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/，这个题解能解释上一个问题这个公式的原因。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/，这个题解能解释上一个问题这个公式的原因。</a></li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="队列-超时"><a href="#队列-超时" class="headerlink" title="队列(超时)"></a>队列(超时)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">1</span> || n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == m - <span class="number">1</span>) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                cnt = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.push(q.front());</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>约瑟夫环</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-456. 132模式</title>
    <url>/2020/02/12/leetocde-456.%20132%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak </span><br><span class="line">被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，</span><br><span class="line">验证这个序列中是否含有132模式的子序列。</span><br><span class="line"></span><br><span class="line">注意：n 的值小于15000。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">解释: 序列中不存在132模式的子序列。</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 1, 4, 2]</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 序列中有 1 个132模式的子序列： [1, 4, 2].</span><br></pre></td></tr></table></figure>

<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1, 3, 2, 0]</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>其实说白了看数组里面是否存在 i &lt; j &lt; k，并且a[i] &lt; a[k] &lt; a[j]，那么按照索引的关系，可以寻找a[j]以前的所有最小值，也就是根据确定每一个a[j]的a[i]的最小值，这个用一个辅助栈就行，这个栈的作用就是保存从数组头到每个a[j]的最小值，而且最小值都放在栈顶。然后遍历j，从j后面寻找k，看看是否存在这么一个k，如果存在就返回true。</li>
<li>刚开始的做法自然是暴力，遍历每一个[i]，然后找第一个比a[i]大的数a[j]，然后从a[j]后面找介于a[i]和a[j]之间的a[k]。这是一个O(n^3)，自然超时。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//辅助栈用来保存到数组每一位的时候此时的最小值</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || i &lt; stack.peek()) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为j从倒数第二个元素开始，所以栈这里也是从栈顶的下一个开始</span></span><br><span class="line">        stack.pop();</span><br><span class="line">        <span class="comment">//遍历每一个j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a.length - <span class="number">2</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//从j后面去寻找是否存在这么一个k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; a.length; k++) &#123;</span><br><span class="line">                <span class="comment">//使得a[i]&lt;a[k]&lt;a[j]，因为栈顶是此时最小的元素,所以可以直接拿栈顶当a[i]</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt; stack.peek() &amp;&amp; a[j] &gt; a[k] &amp;&amp; a[k] &gt; stack.peek())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈此时也要发生变化</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>i &lt; j &lt; k，并且a[i] &lt; a[k] &lt; a[j]，分析后就能知道如果a[i]足够小，a[k]是好找的，而a[i]能用辅助栈得到，所以思路可行。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/132-pattern/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/132-pattern/</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-125. 验证回文串</title>
    <url>/2019/11/28/leetcode125.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span><br><span class="line"></span><br><span class="line">说明：本题中，我们将空字符串定义为有效的回文串。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>回文串，明显双指针，先把字符串都变成大写，而且题目要求字符串只看数字和字符就行了，所以根据ASCII码来过滤掉字母、数字之外的内容就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 双指针</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(s) - <span class="number">1</span></span><br><span class="line">        s = s.upper()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="comment"># 根据ASCII码过滤掉不符合题意的字符</span></span><br><span class="line">            <span class="keyword">if</span> ord(s[i]) &lt; <span class="number">48</span> <span class="keyword">or</span> (ord(s[i]) &gt; <span class="number">57</span> <span class="keyword">and</span> ord(s[i]) &lt; <span class="number">65</span>) <span class="keyword">or</span> ord(s[i]) &gt; <span class="number">90</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> ord(s[j]) &lt; <span class="number">48</span> <span class="keyword">or</span> (ord(s[j]) &gt; <span class="number">57</span> <span class="keyword">and</span> ord(s[j]) &lt; <span class="number">65</span>) <span class="keyword">or</span> ord(s[j]) &gt; <span class="number">90</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 直接判断就行</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title>nk1到n中1出现的次数</title>
    <url>/2020/01/30/nk1%E5%88%B0n%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给每个数算一下<span class="number">1</span>的个数就行了。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res += check(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">                res++;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk不用加减乘除做加法</title>
    <url>/2020/02/11/nk%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>可以用位运算，可以先算每位相加，这个步骤就是num1^num2，然后统计进位(num1&amp;num2)&lt;&lt;1，然后再把num1^num2 ^((num1&amp;num2)&lt;&lt;1)，就相当于把各位相加的结果再加上进位的结果就是相加的结果。然鹅这一步可能还有进位的可能，所以直到每次统计进位都是0的时候才能停止循环。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//temp临时变量记录num1和num2各位不进位的运算</span></span><br><span class="line">            <span class="comment">//其实也是各位的运算(不进位)这一步的结果和计算进位的结果相加</span></span><br><span class="line">            temp = num1 ^ num2;</span><br><span class="line">            <span class="comment">//统计进位</span></span><br><span class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//记录中间值</span></span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk两个链表的第一个公共节点</title>
    <url>/2020/01/31/nk%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两个链表，找出它们的第一个公共结点。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>O(m*n)的思路，遍历链表1的每一个节点，去寻找链表2的每一个节点，找到相同的就返回地址值就行。</li>
<li>仔细想，如果两个链表有公共节点，那么两个链表末尾一定有一部分是相同的(相同地址)，然后其实可以从后同时遍历两个数组，找到两个链表最后一个相同的节点。这里就可以用两个辅助栈，分别模拟两个链表末尾处的节点。找到两个栈的最后相同的栈顶元素就行了。</li>
<li>仔细发现两个链表的规律，假设两个链表一个长l1，另一个长度为l2，假设l1-l2==m，公共长度是n，然后可以发现这两个链表剩余部分相同，我们这里称为x，那么  l1 = m+x+n ，l2 = x+n，而且从n开始就是两个链表的公共部分，所以只需要让两个指针同时指向两个链表的x开头部分，同时开始向后遍历就行了。而这需要让l1先走m个位置。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode cur1 = pHead1;</span><br><span class="line">        ListNode cur2 = pHead2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode cur3 = cur2;</span><br><span class="line">            <span class="keyword">while</span> (cur3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == cur3)</span><br><span class="line">                    <span class="keyword">return</span> cur1;</span><br><span class="line"></span><br><span class="line">                cur3 = cur3.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode cur1 = pHead1;</span><br><span class="line">        ListNode cur2 = pHead2;</span><br><span class="line"></span><br><span class="line">        Stack&lt;ListNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(cur1);</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack2.push(cur2);</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到两个栈的最后相同的栈顶元素</span></span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123;</span><br><span class="line">            ListNode pop1 = stack1.pop();</span><br><span class="line">            ListNode pop2 = stack2.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop1 == pop2)&#123;</span><br><span class="line">                res = pop1;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="先让cur1指针向后移动m个位置"><a href="#先让cur1指针向后移动m个位置" class="headerlink" title="先让cur1指针向后移动m个位置"></a>先让cur1指针向后移动m个位置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode cur1 = pHead1;</span><br><span class="line">        ListNode cur2 = pHead2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算l1和l2的长度</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l1++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l2++;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        cur1 = pHead1;</span><br><span class="line">        cur2 = pHead2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出m</span></span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = l1 - l2;</span><br><span class="line">            <span class="comment">//加入l1大，cur1先后移m个位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里就相当于到了两个链表的x区域了</span></span><br><span class="line">            <span class="comment">//在这里两个指针就可以同时移动了</span></span><br><span class="line">            <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == cur2) &#123;</span><br><span class="line">                    res = cur1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当第二个链表长的时候同理</span></span><br><span class="line">            <span class="keyword">int</span> t = l2 - l1;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur1 == cur2) &#123;</span><br><span class="line">                    res = cur1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>栈和链表配合能达到倒序遍历链表的效果。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk丑数</title>
    <url>/2020/02/11/nk%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把只包含质因子2、3和5的数称作丑数（Ugly Number）。</span><br><span class="line">例如6、8都是丑数，但14不是，因为它包含质因子7。 </span><br><span class="line">习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>根据丑数的定义，判断一个数是不是丑数，只需要看它的质因子是不是只有2，3，5。所以暴力方法是从1一直遍历到res，res是第index个丑数，检查一个数是不是丑数就对这个数一直除2，一直除3，一直除5，看最后结果是不是1就行了。</li>
<li>其实也很容易有一个表达式，假设h是丑数，h= 2^x * 3^y * 5^z，自然就很明了，一个丑数是可以从另一个丑数不断地乘2或者乘3或者乘5得到的。所以我们可以根据丑数来生成丑数。这里采用最小堆来记录产生的丑数，每次取出堆顶元素。就是最小的丑数。注意用堆有几个问题，因为java实现的堆是可以存储重复元素的，所以记得插入的时候特判一下，如果堆里面已经有这个丑数了，丑数就不用插入了，而且因为乘2乘3乘5可能会有越界的问题，所以插入的时候记得要确保插入的是正数。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="暴力-超时"><a href="#暴力-超时" class="headerlink" title="暴力(超时)"></a>暴力(超时)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t != index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check(res)) &#123;</span><br><span class="line">                t++;</span><br><span class="line">                <span class="keyword">if</span> (t == index)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查n是不是丑数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对这个数一直除2</span></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//一直除3</span></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//一直除5</span></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果最后除下来n是1，</span></span><br><span class="line">        <span class="comment">//就说明这个数只有2，3，5做质因子，自然就是丑数。</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成的丑数放到最小堆"><a href="#生成的丑数放到最小堆" class="headerlink" title="生成的丑数放到最小堆"></a>生成的丑数放到最小堆</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1 &lt; o2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//堆初始化放一个1</span></span><br><span class="line">        heap.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t != index) &#123;</span><br><span class="line">            res = heap.remove();</span><br><span class="line">            t++;</span><br><span class="line">            <span class="comment">//插入的时候要确保不会重复和插入的是正数，不然符是直接就到了</span></span><br><span class="line">            <span class="comment">//堆顶了。</span></span><br><span class="line">            <span class="keyword">if</span> (!heap.contains(res * <span class="number">2</span>) &amp;&amp; res * <span class="number">2</span> &gt; <span class="number">0</span>)</span><br><span class="line">                heap.add(res * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (!heap.contains(res * <span class="number">3</span>) &amp;&amp; res * <span class="number">3</span> &gt; <span class="number">0</span>)</span><br><span class="line">                heap.add(res * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (!heap.contains(res * <span class="number">5</span>) &amp;&amp; res * <span class="number">5</span> &gt; <span class="number">0</span>)</span><br><span class="line">                heap.add(res * <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span> (t == index)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>如果一个数的因子只有2,3,5，那么这个数一定是 h = 2^x * 3^y * 5^z，数学问题😂。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&amp;tqId=11186&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&amp;tqId=11186&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二叉搜索树和双向链表</title>
    <url>/2020/02/06/nk%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</span><br><span class="line">要求不能创建任何新的结点，只能调整树中结点指针的指向。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>递归过程，中序遍历每次遍历到节点操作的时候，这时候cur的左指针指向谁就不重要了，因为已经遍历过了，到cur的时候cur的右子树是不能变的，所以可以从cur的左孩子入手，记录一个生成的链表的最后一个节点的指针，每次遍历到cur的时候，只需要让cur.left = lastNode; 然后让lastNode.right = cur，就实现了链表的最后一个节点和中序遍历到cur节点的双向连接。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="中序遍历并且记录链表最后一个节点"><a href="#中序遍历并且记录链表最后一个节点" class="headerlink" title="中序遍历并且记录链表最后一个节点"></a>中序遍历并且记录链表最后一个节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表最后一个节点的指针，一开始是null</span></span><br><span class="line">    TreeNode lastNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">//因为已经拿到链表的最后一个节点的指针</span></span><br><span class="line">        TreeNode cur = lastNode;</span><br><span class="line">        <span class="comment">//cur指向最后一个节点，然后遍历回去就行，遍历到第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.left != <span class="keyword">null</span>)</span><br><span class="line">            cur = cur.left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="comment">//中序遍历到cur节点，让cur节点的左孩子指向链表最后一个节点</span></span><br><span class="line">        cur.left = lastNode;</span><br><span class="line">        <span class="keyword">if</span> (lastNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastNode.right = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastNode = cur;</span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>中序遍历遍历到某个cur节点的时候，cur的左子树指向哪里这时候就可以改了，cur的右子树不能变。这道题就是因为cur的左子树可以改变然后从左子树连接链表。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二叉树中和为某一值的路径</title>
    <url>/2020/01/20/nk%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自然用递归是最好写的，用sum记录到遍历到当前节点得到的路经总和，用temp记录走过的</span><br><span class="line">节点，当sum+cur.val==target并且cur是叶子节点的时候就说明这是一条符合题意的路径。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//走递归函数res集合就有值了。</span></span><br><span class="line">        f(root, <span class="number">0</span>, target, temp, res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为题目要路径长度从大到小排序，所以这里来个冒泡排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res.size() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.get(j).size() &lt; res.get(j + <span class="number">1</span>).size()) &#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; t = res.get(j);</span><br><span class="line">                    res.set(j, res.get(j + <span class="number">1</span>));</span><br><span class="line">                    res.set(j + <span class="number">1</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(TreeNode cur, <span class="keyword">int</span> sum, <span class="keyword">int</span> target, ArrayList&lt;Integer&gt; temp, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果路径和正确并且cur是一个叶子节点就记录路径总和</span></span><br><span class="line">        <span class="keyword">if</span> (sum + cur.val == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里别忘了新开辟内存</span></span><br><span class="line">                ArrayList&lt;Integer&gt; tt = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">                    tt.add(temp.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                tt.add(cur.val);</span><br><span class="line">                res.add(tt);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum + cur.val &gt; target)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里先记录访问到cur节点</span></span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        f(cur.left, sum + cur.val, target, temp, res);</span><br><span class="line">        f(cur.right, sum + cur.val, target, temp, res);</span><br><span class="line">        <span class="comment">//因为递归互相不影响，所以再给cur收回去</span></span><br><span class="line">        <span class="comment">//这样能模拟所有路径</span></span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二叉树的深度</title>
    <url>/2020/01/30/nk%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递归分别求左右孩子深度l和r，然后求出l和r的最大值就OK，然后最大值</span><br><span class="line">的+1就是当前的层数。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec_TreeDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rec_TreeDepth</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = rec_TreeDepth(cur.left);</span><br><span class="line">        <span class="keyword">int</span> r = rec_TreeDepth(cur.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二叉树的第k个节点</title>
    <url>/2020/01/30/nk%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BST，第K个节点，明显可以通过中序遍历找到第K个节点，找到之后记录就行了，然后</span><br><span class="line">为了剪枝可以加一个标记，也就是找到第K个节点之后进行一次标记，之后就不再进行</span><br><span class="line">中序遍历了。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//结果指针</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inOrder(pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常的中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode cur, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记，如果已经找到第K个数，就不用标记了</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            inOrder(cur.left, k);</span><br><span class="line">            <span class="comment">//如果找到了第K个数，就记录，并且标记</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">                res = cur;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计数器自增</span></span><br><span class="line">            cnt++;</span><br><span class="line">            inOrder(cur.right, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>BST一定不能忘了遍历，因为BST自身的性质。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二叉树的后序遍历检索</title>
    <url>/2020/01/19/nk%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">明显的找规律的题，因为后序遍历的关系，先遍历左孩子，再遍历右孩子，最后遍历根节点</span><br><span class="line">那么可以发现，从得到的后序遍历里面的数组里，对于每棵树，最后一个节点都是根节点，</span><br><span class="line">那么在最后一个节点前面的所有节点在不缺少左右孩子的时候，必然有一部分是左孩子，</span><br><span class="line">有一部分是右孩子，同样的在这两个区间里面(左孩子们和右孩子们的区间)也是一样的构造</span><br><span class="line">(最后一个是根节点，也分左右孩子区间)。</span><br><span class="line"></span><br><span class="line">上面是后序遍历正确的时候，那么不正确的时候就是右孩子出现在了左孩子的前面，也就是</span><br><span class="line">在数组根节点前先出现了比根节点大的值，然后又出现了比根节点小的值。这样的遍历结果</span><br><span class="line">就是错误的。</span><br><span class="line"></span><br><span class="line">因为有三种情况嘛，</span><br><span class="line">1.根节点前既有左孩子区间也有右孩子区间，大致是： 左、右、根</span><br><span class="line">2.根节点前只有左孩子，大致是：左、根</span><br><span class="line">3.根节点前只有右孩子，大致是：右、根</span><br><span class="line">所以分情况讨论就行了</span><br><span class="line"></span><br><span class="line">三种情况都要讨论：有没有出现比数组末尾元素小的元素出现在比数组末尾元素大的元素后面</span><br><span class="line">然后分3种情况递归。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> f(num, <span class="number">0</span>, num.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历到根节点的时候，自然是正确的后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先记录当前区间内根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> t = num[r];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//寻找有没有大于t的数出现在小于t的前面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt; t) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &lt; t &amp;&amp; flag)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &lt; t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找第一个比t大的元素</span></span><br><span class="line">        <span class="keyword">int</span> index = r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &gt; t) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分3种情况进行递归</span></span><br><span class="line">        <span class="comment">//没有左孩子的时候</span></span><br><span class="line">        <span class="keyword">if</span> (index == l) &#123;</span><br><span class="line">            <span class="comment">//像左孩子进行递归</span></span><br><span class="line">            <span class="keyword">return</span> f(num, l, r - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//当没有右孩子的时候</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == r - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//向右孩子递归</span></span><br><span class="line">            <span class="keyword">return</span> f(num, l, r - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//既有左孩子又有右孩子的时候</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//两个区间都要递归</span></span><br><span class="line">            <span class="keyword">return</span> f(num, l, index - <span class="number">1</span>) &amp;&amp; f(num, index, r - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>找规律</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二叉树的下一个节点</title>
    <url>/2020/02/07/nk%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一</span><br><span class="line">个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包</span><br><span class="line">含指向父结点的指针。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显是分析情况的题，这道题有3个情况。假设给的节点是node</li>
<li>第一种情况，node有右子树，那么按照中序遍历的算法，node的下一个节点自然是node的右子树里面最左面的节点。</li>
<li>第二种情况，node没有右子树，是node的父节点的左孩子，那么同理按照中序遍历的算法，node的下一个节点就是node的父节点。</li>
<li>第三种情况，node没有右子树，是node的父节点的右孩子，那么就得一直向上迭代，假设迭代的每个节点是cur，那么当cur是cur的父节点的左孩子的时候，就可以返回cur的父节点作为node的下一个节点了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="分三种情况"><a href="#分三种情况" class="headerlink" title="分三种情况"></a>分三种情况</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果存在右子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMin(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看看是否有父节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看node是否是父节点的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (node == node.next.left) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果node是父节点的右子树，就向上走到第一个是父节点的左孩子的节点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.next != <span class="keyword">null</span> &amp;&amp; node == node.next.right) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当cur是cur的父节点的左孩子的时候，就返回cur的父节点就行了</span></span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到以cur为根节点的最左面的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeLinkNode <span class="title">findMin</span><span class="params">(TreeLinkNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findMin(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二叉树的镜像</title>
    <url>/2020/01/18/nk%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">           8</span><br><span class="line">          /  \</span><br><span class="line">         6   10</span><br><span class="line">        / \  / \</span><br><span class="line">        5  7 9 11</span><br><span class="line">    镜像二叉树</span><br><span class="line">           8</span><br><span class="line">         /  \</span><br><span class="line">        10   6</span><br><span class="line">        / \  / \</span><br><span class="line">       11 9 7  5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        f(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode t = cur.left;</span><br><span class="line">        cur.left = cur.right;</span><br><span class="line">        cur.right = t;</span><br><span class="line">        f(cur.left);</span><br><span class="line">        f(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>记得值传递和地址传递的区别。</li>
<li>这道题不能造新树，因为这道题的返回值是void，所以必须在传入的地址值上进行操作，不能root=新地址值，因为原来的地址值没有变。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二进制中1的个数</title>
    <url>/2020/01/19/nk%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A7%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">二进制的题一定都要用位运算，不然一定很麻烦而且还容易错</span><br><span class="line"></span><br><span class="line">因为要统计二进制中<span class="number">1</span>的个数，而且位运算种n&amp;<span class="number">1</span>能达到n的最后一位数，所以</span><br><span class="line">每次让n&amp;<span class="number">1</span>完事之后看结果是不是<span class="number">1</span>，然后再右移n就OK了。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; m) == <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk从上到下打印二叉树</title>
    <url>/2020/01/19/nk%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从上往下打印出二叉树的每个节点，同层节点从左至右打印。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">就是bfs一颗树，没啥说的。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                TreeNode temp = queue.remove();</span><br><span class="line">                res.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk删除链表中的重复节点</title>
    <url>/2020/02/05/nk%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复</span><br><span class="line">的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处</span><br><span class="line">理后为 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>说白了就是吧一个链表里面有重复值的元素全部删除，而不是删除重复的元素，题意要求的是全部的删除。那么很自然的想到可以用两个指针，一个pre，一个cur，pre是cur的前驱，正常情况下，pre和cur都后移，如果cur发现cur的后面节点和cur有一样的值，cur就后移，直到移动到最后一个和cur相等的元素上，比如2-3-3-3-3，一开是pre指向的是2，cur指向的是第一个3，然后cur发现cur当前和cur的下一个相同，然后cur就后移，如此最后移动到最后一个3上，此时把pre.next = cur.next,这样就达到了删除全部重复节点的需求。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//因为pre是cur的前驱指针，初始值pre是虚拟头结点</span></span><br><span class="line">        dummy.next = pHead;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">//cur是正经的头结点</span></span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果cur发现cur的后面和cur的值一样</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == cur.val) &#123;</span><br><span class="line">                <span class="comment">//cur就一直后移到最后一个相同的元素上</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == cur.val) &#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//然后让pre和cur的下一个相连</span></span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                <span class="comment">//cur更新位置</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则正常情况下两个指针都向后迭代</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为是通过pre操作的，所以要返回pre最开始的位置</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk二叉树的镜像</title>
    <url>/2020/01/19/nk%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为要O(1)拿到栈的最小值，所以不能用一个变量存储，因为有可能弹出的数据</span><br><span class="line">就是最小值，如果弹出的是最小值那么就得重新找最小值，所以得需要一个数据结</span><br><span class="line">构用来存储栈的每个状态的最小值。所以这里用一个辅助栈来存储最小值数据栈的</span><br><span class="line">每个状态的最小值。</span><br><span class="line"></span><br><span class="line">每次数据栈存储值的时候都和辅助栈的栈顶元素比一个大小，谁小就入栈辅助栈。</span><br><span class="line"></span><br><span class="line">这个思路很巧妙，用辅助站存储了数据栈的每个状态的最小值。每次只需要O(1)的时间</span><br><span class="line">复杂度就拿到了数据栈当前状态的最小值。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量别忘了赋初始值</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数据栈正常赋值</span></span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="comment">//辅助栈每次都入栈辅助栈的栈顶元素和新元素的最小值。</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty() || node &lt; stack2.peek()) &#123;</span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack2.push(stack2.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为辅助栈存放的是数据栈的每个状态的最小值，所以</span></span><br><span class="line">    <span class="comment">//数据栈怎么变化辅助栈跟着变化就OK了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk变态跳台阶</title>
    <url>/2020/01/20/nk%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按照普通跳台阶的思路，f(n)=f(n-1)+f(n-2)+...+f(1)+1，最后加1是可以直接跳n节达到第n节台阶。而且第n节台阶可以从n-1节跳1节，从第n-2节上2节。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从第二节开始，都可以从1~n-1跳上来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                a[i] += a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为也能直接跳n级，所以加一种</span></span><br><span class="line">            a[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>能状态转移的就不要递归了，就不用考虑那么多边界情况了，知道递归怎么剪枝就行了。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk合并两个排序链表</title>
    <url>/2020/02/05/nk%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要</span><br><span class="line">合成后的链表满足单调不减规则。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>造一个新链表，两个指针分别遍历两个链表，哪个指针指向的节点的值小哪个指针就新造一份，然后这个指针后移。直到有一个链表遍历完毕，然后把另一条链表剩下的部分拼接到新造的链表的尾部就好了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="造新链表"><a href="#造新链表" class="headerlink" title="造新链表"></a>造新链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//来一个虚拟头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur1 = list1;</span><br><span class="line">        ListNode cur2 = list2;</span><br><span class="line">        ListNode cur3 = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历两个链表</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//谁小就新造谁的值</span></span><br><span class="line">            <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123;</span><br><span class="line">                cur3.next = <span class="keyword">new</span> ListNode(cur1.val);</span><br><span class="line">                <span class="comment">//拼接新链表</span></span><br><span class="line">                cur3 = cur3.next;</span><br><span class="line">                <span class="comment">//造指针后移</span></span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            <span class="comment">//同理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur3.next = <span class="keyword">new</span> ListNode(cur2.val);</span><br><span class="line">                cur3 = cur3.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看哪个链表还有剩余部分，剩下的直接拼接到新链表后面就行了</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur3.next = cur2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur3.next = cur1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk和为S的两个数字</title>
    <url>/2020/02/03/nk%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排好序的数组的两数之和</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>可以用两层for的方法做两数之和</li>
<li>因为是排序数组，所以可以双指针寻找两个值。i从前往后，j从后往前，根据两者的和的大小和sum的比价来判断指针的移动。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="两层for"><a href="#两层for" class="headerlink" title="两层for"></a>两层for</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length &lt; <span class="number">2</span> || sum &lt; a[<span class="number">0</span>] + a[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] + a[j] == sum) &#123;</span><br><span class="line">                    res.add(a[i]);</span><br><span class="line">                    res.add(a[j]);</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length &lt; <span class="number">2</span> || sum &lt; a[<span class="number">0</span>] + a[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据两者的和和sum的比较来判断指针的移动</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] + a[j] &gt; sum) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] + a[j] &lt; sum) &#123;<span class="number">0</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(a[i]);</span><br><span class="line">                res.add(a[j]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>有序很多时候可以用双指针</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk和为S的连续正序列</title>
    <url>/2020/02/06/nk%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上</span><br><span class="line">就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续</span><br><span class="line">的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数</span><br><span class="line">和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的</span><br><span class="line">找出所有和为S的连续正数序列? Good Luck!</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>两层循环拿到所有序列，然后分别统计和，如果和够了就放到最后的集合里面。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="两层循环"><a href="#两层循环" class="headerlink" title="两层循环"></a>两层循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两层循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            <span class="comment">//以i开头的所有集合</span></span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//以i开头的和</span></span><br><span class="line">            <span class="keyword">int</span> tsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= sum; j++) &#123;</span><br><span class="line">                <span class="comment">//当和是sum的时候，就返回值就OK了。</span></span><br><span class="line">                tsum += j;</span><br><span class="line">                temp.add(j);</span><br><span class="line">                <span class="keyword">if</span> (tsum == sum) &#123;</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                    <span class="comment">//因为结果具有唯一性，所以拿到一个结果时，直接找下一个开头就行了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk圆圈中最后剩下的数字</title>
    <url>/2020/02/09/nk%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。</span><br><span class="line">HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:</span><br><span class="line">首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小</span><br><span class="line">朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱</span><br><span class="line">中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1</span><br><span class="line">报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客</span><br><span class="line">名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会</span><br><span class="line">得到这份礼品呢？(注：小朋友的编号是从0到n-1)</span><br><span class="line"></span><br><span class="line">如果没有小朋友，请返回-1</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>完全可以用一个队列模拟孩子们的报数过程，每次新到一个孩子的时候，孩子先报数，看看自己报的数是不是m-1，如果是就把自己从队列中删除，如果不是就把自己放到队尾，然后直到队列只有一个元素的时候就相当于模拟完了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="队列模拟"><a href="#队列模拟" class="headerlink" title="队列模拟"></a>队列模拟</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">1</span> || n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            q1.add(i);</span><br><span class="line">        <span class="keyword">int</span> cnt = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q1.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == m - <span class="number">1</span>) &#123;</span><br><span class="line">                q1.remove();</span><br><span class="line">                cnt = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q1.add(q1.remove());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q1.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk字符流中第一个出现的字符</title>
    <url>/2020/02/07/nk%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流</span><br><span class="line">中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流</span><br><span class="line">中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>用map记录出现的字符次数，用list保存输入进来的字符。插入字符的时候往map里面增加字符出现次数，并且往list尾部添加字符。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk对称的二叉树</title>
    <url>/2020/01/19/nk%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里就出现了不是共性问题，每个子树都是镜像对称的不一定整颗树就是镜像对称的</span><br><span class="line"></span><br><span class="line">所以这里从树的遍历找突破口。如果一个树是镜像的，那么这棵树的遍历下来一定是</span><br><span class="line">相反的，比如一个树的前序遍历是1，2，3，4，5，那么这个树的镜像的相同遍历方</span><br><span class="line">式下来的就是5,4,3,2,1。</span><br><span class="line"></span><br><span class="line">所以这里以前序遍历举例，用两个节点同时遍历树，一个先遍历左孩子，一个先遍历</span><br><span class="line">右孩子。如果是镜像的话，那么这两种遍历方式拿到的节点的值是一样的(根一样的</span><br><span class="line">情况下)。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(TreeNode cur1, TreeNode cur2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//都是空自然是镜像的</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="keyword">null</span> &amp;&amp; cur2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果都不是空，但是有一个是空，自然不一样</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="keyword">null</span> || cur2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//值不一样也是</span></span><br><span class="line">        <span class="keyword">if</span> (cur1.val != cur2.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(cur1.left, cur2.right) &amp;&amp; f(cur1.right, cur2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直观一点的遍历"><a href="#直观一点的遍历" class="headerlink" title="直观一点的遍历"></a>直观一点的遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        f(pRoot, pRoot);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(TreeNode cur1, TreeNode cur2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="keyword">null</span> &amp;&amp; cur2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="keyword">null</span> || cur2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模仿前序遍历的做法</span></span><br><span class="line">        <span class="keyword">if</span> (cur1.val != cur2.val)</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        f(cur1.left, cur2.right);</span><br><span class="line">        f(cur1.right, cur2.left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找不见共性问题就找树的遍历</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk复杂链表的赋值</title>
    <url>/2020/02/11/nk%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点</span><br><span class="line">，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</span><br><span class="line">（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>直接造一个新链表，对于新链表的每个节点的值都和原来的链表一模一样的。造完新链表之后，再给新链表的每个节点的random域造对应着原来链表节点里面的random域的值的新节点。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode dummy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">        RandomListNode cur2 = dummy;</span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="comment">//造新节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur2.next = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给每个节点的random域造新值</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        cur2 = dummy.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>)</span><br><span class="line">                cur2.random = <span class="keyword">new</span> RandomListNode(cur.random.label);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur2.random = <span class="keyword">null</span>;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk字符串的全排列</title>
    <url>/2020/01/31/nk%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符</span><br><span class="line">串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</span><br><span class="line"></span><br><span class="line">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>全排列有回溯的，也有book标记的。</li>
<li>这道题因为要字典序，而且也可能有重复字符串，所以这里用TreeSet存储所有递归得到的全排列的字符串，最后把TreeSet里面的内容放到ArrayList里面就行。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="回溯加标记"><a href="#回溯加标记" class="headerlink" title="回溯加标记"></a>回溯加标记</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="comment">//因为这道题有重复字符，所以要进行去重，这里使用HashSet去重</span></span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        f(set, flag, chs, <span class="number">0</span>, s);</span><br><span class="line">        res.addAll(set);</span><br><span class="line">        <span class="comment">//字典序，用工具类排序</span></span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常的回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(HashSet&lt;String&gt; res, <span class="keyword">boolean</span>[] flag, <span class="keyword">char</span>[] chs, <span class="keyword">int</span> step, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (step == s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(chs));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">                flag[i] = <span class="keyword">true</span>;</span><br><span class="line">                chs[step] = s.charAt(i);</span><br><span class="line">                f(res, flag, chs, step + <span class="number">1</span>, s);</span><br><span class="line">                flag[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="每个字符轮流做第一位"><a href="#每个字符轮流做第一位" class="headerlink" title="每个字符轮流做第一位"></a>每个字符轮流做第一位</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        TreeSet&lt;String&gt; tmp = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        f(res, <span class="number">0</span>, chs);</span><br><span class="line">        res.addAll(tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(ArrayList&lt;String&gt; tmp, <span class="keyword">int</span> begin, <span class="keyword">char</span>[] chs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == chs.length - <span class="number">1</span>) &#123;</span><br><span class="line">            tmp.add(<span class="keyword">new</span> String(chs));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; chs.length; i++) &#123;</span><br><span class="line">                swap(chs, begin, i);</span><br><span class="line">                f(tmp, begin + <span class="number">1</span>, chs);</span><br><span class="line">                swap(chs, begin, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t = chs[i];</span><br><span class="line">        chs[i] = chs[j];</span><br><span class="line">        chs[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>轮流做第一位的全排列是一个很好的递归例子，逐个枚举第i个字符。</li>
<li>递归逐渐缩小子问题，轮流做第一位，在第一位确定的时候轮流做第二位，问题逐渐缩小。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk平衡二叉树</title>
    <url>/2020/02/01/nk%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>因为平衡二叉树的定义是所有节点都是平衡的，所以只需要判断以每个节点为根节点的树是不是平衡二叉树就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归判断以cur为根的节点是不是一颗平衡二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = getDepth(cur.left);</span><br><span class="line">        <span class="keyword">int</span> r = getDepth(cur.right);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(l - r) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(cur.left) &amp;&amp; f(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = getDepth(cur.left);</span><br><span class="line">        <span class="keyword">int</span> r = getDepth(cur.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk左旋转字符串</title>
    <url>/2020/02/09/nk%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，</span><br><span class="line">就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你</span><br><span class="line">把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输</span><br><span class="line">出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>注意n有可能大于字符串s的长度，首先对n%=s.length()，确保n在s.length()的范围，然后拼接字符串就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        n %= s.length();</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i&lt;s.length(); i++)</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk扑克牌顺子</title>
    <url>/2020/02/09/nk%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个</span><br><span class="line">小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气</span><br><span class="line">,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A</span><br><span class="line">,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他</span><br><span class="line">想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。</span><br><span class="line">上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。</span><br><span class="line">LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉</span><br><span class="line">我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。</span><br><span class="line">为了方便起见,你可以认为大小王是0。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>用0可以代替任何数，所以给数组排序之后对于数组进行一个所有数之间的间隔的计算，如果间隔大于1就计算，最后统计0的个数和间隔的个数谁大就行了。也就是看0能不能代替间隔里面的数。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="统计间隔"><a href="#统计间隔" class="headerlink" title="统计间隔"></a>统计间隔</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//0的个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//间隔的数目</span></span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果出现对子，一定不是顺子</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//统计所有数的间隔</span></span><br><span class="line">            gap += a[i + <span class="number">1</span>] - a[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后看0的个数够不够抵消间隔</span></span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= gap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk序列二叉树</title>
    <url>/2020/02/04/nk%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现两个函数，分别用来序列化和反序列化二叉树</span><br><span class="line"></span><br><span class="line">二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字</span><br><span class="line">符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中</span><br><span class="line">序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列</span><br><span class="line">化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</span><br><span class="line"></span><br><span class="line">二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>序列化嘛，那就前序遍历一棵树，节点之间用逗号隔开，如果前序遍历遇到空节点就用#代替，最后生成的字符串就是序列化为之后的结果</li>
<li>反序列化就是递归生成一棵树的过程。模拟前序遍历的顺序，从生成的字符串里面挨个读取节点，读到#就返回空节点，读到值就返回带值的节点。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        preOrder(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历生成二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode cur, StringBuffer sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"#,"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(cur.val);</span><br><span class="line">        sb.append(<span class="string">","</span>);</span><br><span class="line">        preOrder(cur.left, sb);</span><br><span class="line">        preOrder(cur.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.equals(<span class="string">""</span>) || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String[] s = str.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> rec(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照前序遍历的过程读取字符串，然后生成二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">rec</span><span class="params">(String[] s)</span> </span>&#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (!s[index].equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">            TreeNode cur = <span class="keyword">new</span> TreeNode(Integer.valueOf(s[index]));</span><br><span class="line">            cur.left = rec(s);</span><br><span class="line">            cur.right = rec(s);</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk把字符串转换成整数</title>
    <url>/2020/02/10/nk%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。</span><br><span class="line"> 数值为0或者字符串不是一个合法的数值则返回0</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>不合法的字符串返回0，那么要注意到不合法的字符串可能是null字符串，内容全是” “这种空格字符的字符串，还有的是数字中间出现一个字母这种，还有越整形的范围的(这道题的数字范围是在整形的范围的)。</li>
<li>为了确保放值整形越界，我们用一个long类型来存储中间的值，如果在最后结果的产生过程中越了整形的范围，直接返回0(越界，不符合题意，返回0)，然后循环遍历字符串一个数一个数的进行拼接就完事了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="逐个遍历字符串"><a href="#逐个遍历字符串" class="headerlink" title="逐个遍历字符串"></a>逐个遍历字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对于空白字符串的特判</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.equals(sb.toString())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为在拼接过程中可能会越界，所以中间用long类型存储中间值</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//逐个遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; str.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; str.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                res *= -<span class="number">1</span>;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对于字符串中的非法字符进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &lt; <span class="string">'0'</span> || str.charAt(i) &gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//拼接字符串</span></span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="comment">//正数的拼接</span></span><br><span class="line">                res = res * <span class="number">10</span> + Integer.parseInt(str.charAt(i) + <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//负数的拼接</span></span><br><span class="line">                res = res * <span class="number">10</span> - Integer.parseInt(str.charAt(i) + <span class="string">""</span>);</span><br><span class="line">            <span class="comment">//在造数的过程中如果越界，就返回0</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;tqId=11202&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;tqId=11202&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk把数组拍成最小的数</title>
    <url>/2020/01/31/nk%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8B%8D%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接</span><br><span class="line">出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这三</span><br><span class="line">个数字能排成的最小数字为321323。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>其实就是看数组怎么排能得到的字符串最小，首先可以全排列求所有可能的字符串，然后找一个最小的就行了。</li>
<li>然后可以排序，具体使用哪个排序都行，这里使用快排。假设两个数a和b，那么字符拼接ab和ba产生两个字符串，哪个小，那么那个字符就排序在前面，可以根据这个排序规则进行排序。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录最小的字符串</span></span><br><span class="line">    <span class="keyword">private</span> String min = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        String[] nums = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = String.valueOf(numbers[i]);</span><br><span class="line">            <span class="comment">//自然是设置最大值</span></span><br><span class="line">            min += <span class="string">"9"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//枚举第一个数字拿到全排列</span></span><br><span class="line">        f(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String[] num, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == num.length - <span class="number">1</span>) &#123;</span><br><span class="line">            String tmp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (String s : num) &#123;</span><br><span class="line">                tmp += s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp.compareTo(min) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                min = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; num.length; i++) &#123;</span><br><span class="line">                swap(num, begin, i);</span><br><span class="line">                f(num, begin + <span class="number">1</span>);</span><br><span class="line">                swap(num, begin, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] num, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        String t = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>用的快排的板子，然后根据题意自定义优先级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        String temp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            temp += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            q = partition(nums, l, r);</span><br><span class="line">            quickSort(nums, l, q - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, q + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, i, j, t;</span><br><span class="line">        x = nums[r];</span><br><span class="line">        i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = l; j &lt; r; j++) &#123;</span><br><span class="line">            String t1 = <span class="string">""</span> + nums[j] + x;</span><br><span class="line">            String t2 = <span class="string">""</span> + x + nums[j];</span><br><span class="line">            <span class="keyword">if</span> (t1.compareTo(t2) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                t = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = nums[i + <span class="number">1</span>];</span><br><span class="line">        nums[i + <span class="number">1</span>] = nums[r];</span><br><span class="line">        nums[r] = t;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk排序数组中数字出现的次数</title>
    <url>/2020/02/02/nk%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">统计一个数字在排序数组中出现的次数。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>因为排序，只需要遍历到比K大的数就不用再遍历了。所以直接计数就好了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &gt; k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == k)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk按照之字形打印二叉树</title>
    <url>/2020/02/10/nk%E6%8C%89%E7%85%A7%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，</span><br><span class="line">第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>双端队列，用flag标记这一行应该是从左往右还是从右往左，如果是从左往右，就从队列左端进行bfs，然后对于每一个弹出队列的节点先把左孩子放到队列尾部，再把右孩子放到队列尾部。如果是从右往左，就对队列右端进行bfs，对于每一个弹出的节点先把右孩子放到队列首部，再把左孩子放到队列首部。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        <span class="comment">//true表示从左到右，false表示从右到左</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> t = queue.size();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                    <span class="comment">//如果是从左到右，每次从队首拿元素</span></span><br><span class="line">                    TreeNode node = queue.removeFirst();</span><br><span class="line">                    <span class="comment">//先放左孩子</span></span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                        queue.addLast(node.left);</span><br><span class="line">                    <span class="comment">//再放右孩子</span></span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                        queue.addLast(node.right);</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是从右往左，就和从左往右的处理过程相反</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                    TreeNode node = queue.removeLast();</span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                        queue.addFirst(node.right);</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                        queue.addFirst(node.left);</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>双端队列两端都可以可以对两端进行入队和出队。如果向对队列的尾部进行操作的话，不妨使用双端队列，Deque。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk数据流的中位数</title>
    <url>/2020/02/10/nk%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，</span><br><span class="line">那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读</span><br><span class="line">出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br><span class="line">我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始自然是最暴力的做法，用一个集合存储所有的元素，每插入一个元素之后直接排序，每次获取中位数的时候直接从集合中获取就好了。</li>
<li>其实中位数的获取方法可以用partition来获得，二分寻找partition的返回值，直到partition的返回值是数组中间，如果数组是奇数，就二分一次，就是直到partition的返回值是数组的中间array.length/2，如果数组长度是偶数，那就这样的过程执行两次，一次是array.length/2和array.length/2-1。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="集合存储所有的数，每次插入排序"><a href="#集合存储所有的数，每次插入排序" class="headerlink" title="集合存储所有的数，每次插入排序"></a>集合存储所有的数，每次插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次插入数据都排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        array.add(num);</span><br><span class="line">        Collections.sort(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//奇数个数</span></span><br><span class="line">        <span class="keyword">if</span> (array.size() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) array.get(array.size() / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> t1 = array.get(array.size() / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">double</span> t2 = array.get(array.size() / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) ((t1 + t2) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="partition寻找中位数"><a href="#partition寻找中位数" class="headerlink" title="partition寻找中位数"></a>partition寻找中位数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        array.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//奇数长度的时候</span></span><br><span class="line">        <span class="keyword">if</span> (array.size() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//二分寻找中位数</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = array.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//注意数组的中位数是数组长度除以2</span></span><br><span class="line">            <span class="keyword">int</span> mid = array.size() / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> index = partition(array, i, j);</span><br><span class="line">            <span class="keyword">while</span> (mid != index) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid &gt; index) &#123;</span><br><span class="line">                    index = partition(array, index + <span class="number">1</span>, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index = partition(array, i, index - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) array.get(index);</span><br><span class="line">        <span class="comment">//数组长度是偶数的时候    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (array.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">double</span>) <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> t1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">double</span> t2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//第一次先寻找中位数索引是数组长度除以2</span></span><br><span class="line">            <span class="keyword">int</span> j = array.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = array.size() / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> index = partition(array, i, j);</span><br><span class="line">            <span class="keyword">while</span> (mid != index) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid &gt; index) &#123;</span><br><span class="line">                    index = partition(array, index + <span class="number">1</span>, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index = partition(array, i, index - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            t2 = array.get(index);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//第二次寻找</span></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            j = array.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//此时的中位数是数组长度除以二再减一</span></span><br><span class="line">            mid = array.size() / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            index = partition(array, i, j);</span><br><span class="line">            <span class="keyword">while</span> (mid != index) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid &gt; index) &#123;</span><br><span class="line">                    index = partition(array, index + <span class="number">1</span>, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index = partition(array, i, index - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            t1 = array.get(index);</span><br><span class="line">            <span class="keyword">return</span> (t1 + t2) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//partition返回值，把 l&lt;=x&lt;=r的范围排序好</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, i, j, t;</span><br><span class="line">        x = array.get(r);</span><br><span class="line">        i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = l; j &lt; r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array.get(j) &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(array, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = array.get(i);</span><br><span class="line">        array.set(i, array.get(j));</span><br><span class="line">        array.set(j, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>明确好，数组中位数的索引，<ol>
<li>当数组长度是奇数的时候，index = a.length/2</li>
<li>当时偶数的时候,index1 = a.length/2，index2 = a.length/2-1</li>
</ol>
</li>
<li>partition的参数是 l &lt;= x &lt;= r，是一个卡的很明确的区间</li>
<li>partition函数可以用来获得数组的中位数。不管数组长度是奇数还是偶数。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk数值的整数次方</title>
    <url>/2020/02/05/nk%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个double类型的浮点数base和int类型的整数exponent。</span><br><span class="line">求base的exponent次方。</span><br><span class="line"></span><br><span class="line">保证base和exponent不同时为0</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>这道题的难点其实就是在于把所有情况都考虑进去，比如指数大于0，小于0，等于0的时候。指数小于0的时候需要返回其的指数次方的倒数，而且还要考虑底数是不是0，因为1/0报错。所以考虑所有情况就ok了。</li>
<li>但是一想，a的b次幂。这不就是快速幂嘛。所以和上面一样，考虑所有情况之后直接快速幂解决问题就行。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="考虑所有情况"><a href="#考虑所有情况" class="headerlink" title="考虑所有情况"></a>考虑所有情况</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span> || a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//true表示b是正数</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">            sum *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? sum : <span class="number">1.0</span> / sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span> || a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//true表示b是正数</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//快速幂</span></span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//在b的二进制上为1的位进行sum的乘积。</span></span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                sum *= a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//a因为b的右移成为a的二进制次方</span></span><br><span class="line">            a *= a;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? sum : <span class="number">1.0</span> / sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>看到a的b次方就应该想到快速幂</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>nk数组中出现次数超过一半的数字</title>
    <url>/2020/02/01/nk%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例</span><br><span class="line">如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数字2在数组</span><br><span class="line">中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>打擂，采用人海战术寻找结果，遇到相同的数字计数器就加一，不同的就减一，如果计数器为0，重新计数。因为这道题的关系，最后验证一下结果。</li>
<li>另一个基于partition，因为排序后超过结果一定是中位数，所以通过二分partition的返回值，当返回值是数组中中位数的索引的时候就可以确定那个数了，就是partition返回值的索引对应的值。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="打擂"><a href="#打擂" class="headerlink" title="打擂"></a>打擂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                t = a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遇到一样的计数器加一</span></span><br><span class="line">                <span class="keyword">if</span> (a[i] == t) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不一样的计数器减一</span></span><br><span class="line">                    cnt--;</span><br><span class="line">                    <span class="comment">//如果计数器为0，就重新计数一个数</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                        t = a[i];</span><br><span class="line">                        cnt = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后验证一下</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == t) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; a.length / <span class="number">2</span> ? t : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> index = partition(a, l, r);</span><br><span class="line">        <span class="comment">//二分寻找partition的返回值</span></span><br><span class="line">        <span class="keyword">while</span> (mid != index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt; index) &#123;</span><br><span class="line">                <span class="comment">//左右分割</span></span><br><span class="line">                l = index + <span class="number">1</span>;</span><br><span class="line">                index = partition(a, l, r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = index - <span class="number">1</span>;</span><br><span class="line">                index = partition(a, l, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后做个验证</span></span><br><span class="line">        <span class="keyword">int</span> res = a[index];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == i) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; a.length / <span class="number">2</span> ? res : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, i, j;</span><br><span class="line">        x = a[r];</span><br><span class="line">        i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = l; j &lt; r; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk数组中重复的数字</title>
    <url>/2020/02/09/nk%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个长度为n的数组里的所有数字都在0到n-1的范围内。 </span><br><span class="line">数组中某些数字是重复的，但不知道有几个数字是重复的。</span><br><span class="line">也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 </span><br><span class="line">例如，如果输入长度为7的数组&#123;2,3,1,0,2,5,3&#125;，那么对应的输出是第一个重复的数字2。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>题目说了所有数字都在0到n-1的范围内，但是不一定真的是从0开始排的，也有可能全是1，所以用位运算的方法就行不通。</li>
<li>然后直接排序，遍历数组，看数组当前元素和当前元素的下一个元素是否一样，如果一样就找到第一个重复的值了。</li>
<li>也能用set做，直接一遍遍历，每次把遍历到的数都放到set，在放之前看set有没有这个数，如果有就说明重复了。</li>
<li>既然题目提到了数组里面的所有的数范围都是在0到n-1的，而数组长度是n，所以可以从数组的索引入手。其实可以进行一下伪排序，就是把</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (duplication == <span class="keyword">null</span> || duplication.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        Arrays.sort(a);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = a[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(i)) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用数组进行标记"><a href="#用数组进行标记" class="headerlink" title="用数组进行标记"></a>用数组进行标记</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            book[i]++;</span><br><span class="line">            <span class="keyword">if</span> (book[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="伪排序"><a href="#伪排序" class="headerlink" title="伪排序"></a>伪排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次都归为a[i]，确保a[i]==i。</span></span><br><span class="line">            <span class="keyword">while</span> (a[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == a[a[i]]) &#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = a[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是重复的话，为了确保a[i]==i</span></span><br><span class="line">                    <span class="comment">//就得不断变化a[i]的值，而为了变化a[i]</span></span><br><span class="line">                    <span class="comment">//就让a[i]和a[a[i]]交换。</span></span><br><span class="line">                    <span class="keyword">int</span> t = a[i];</span><br><span class="line">                    a[i] = a[t];</span><br><span class="line">                    a[t] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>注意题目的数据范围，如果是0到n-1这种一般都是从索引入手，不过这只需要在面试的时候注意，平常刷题emmmm。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk数组中的逆序对</title>
    <url>/2020/01/31/nk%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组</span><br><span class="line">成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对</span><br><span class="line">1000000007取模的结果输出。 即输出P%1000000007</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>用归并排序求逆序对。对于归并排序，采用分治的方法，在merger操作的时候进行逆序对的统计。只要发生后半段的数a[j]比前半段的数小a[i]的时候，那么说明此时前半段那个数到前半段末尾的所有的数都比后半段的那个数大a[j] &lt; a[i…mid]。那么对于j的逆序数就是mid-i+1，如此每次只要发生a[j] &lt; a[i]的时候都进行一波统计逆序数，因为是递归的操作，所有区间的逆序数都会被记录，所以当归并排序结束的时候，逆序对也就全部记录完了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录两个值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] n1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200006</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] n2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200006</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左半段</span></span><br><span class="line">            sort(nums, l, mid);</span><br><span class="line">            <span class="comment">//右半段</span></span><br><span class="line">            sort(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merger(nums, l, r, mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>, l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) &#123;</span><br><span class="line">            n1[t++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        n1[t] = Integer.MAX_VALUE;</span><br><span class="line">        l1 = t;</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            n2[t++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        n2[t] = Integer.MAX_VALUE;</span><br><span class="line">        l2 = t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="comment">//发生n2[j]&lt;n1[i]的时候，就记录逆序对</span></span><br><span class="line">            <span class="keyword">if</span> (n1[i] &lt;= n2[j]) &#123;</span><br><span class="line">                nums[k] = n1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = n2[j++];</span><br><span class="line">                ans += l1 - i;</span><br><span class="line">                ans %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk数组中只出现一次的数字</title>
    <url>/2020/02/08/nk%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个整型数组里除了两个数字之外，其他的数字都出现了两次。</span><br><span class="line">请写程序找出这两个只出现一次的数字。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始用map存数字和数字出现的次数，正常想法。</li>
<li>假设结果为t1和t2，按照剑指offer书上的，先用sum异或数组里面全部的值，因为异或运算的特性，最后的sum里面的值是t1^t2的值，然后因为t1和t2一定不等，所以t1^t2一定不是0，所以在sum中从右向左寻找第一个是1的位，设这个位是从右往左第n位，然后我们可以根据第n位是不是1对整个数组进行分成两组，然后对于这两组进行分别求异或，那么这两组的结果分别就是t1和t2啦。</li>
<li>为什么要对于所有数字看第n位是不是1来进行分类呢？因为相同的数，第n位一定是相同的，对于t1和t2来说，他俩的第n位一定不一样，而对于剩下的对儿来说，第n位一定都是相同的，所以第n位是1的会在一组，0的会在另一组。所以可以把整个数组分成两个子数组，这两个子数组</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="map存储出现的次数"><a href="#map存储出现的次数" class="headerlink" title="map存储出现的次数"></a>map存储出现的次数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(i)) &#123;</span><br><span class="line">                map.put(i, map.get(i) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(i, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(integer) == <span class="number">1</span> &amp;&amp; flag) &#123;</span><br><span class="line">                num1[<span class="number">0</span>] = integer;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.get(integer) == <span class="number">1</span>) &#123;</span><br><span class="line">                num2[<span class="number">0</span>] = integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>   

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>n^n = 0</li>
<li>n^0 = n;</li>
<li>n1^n2^n1 = n1^n1^n2 = n2       </li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&amp;tqId=11193&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&amp;tqId=11193&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk旋转数组中最小的数</title>
    <url>/2020/01/30/nk%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span><br><span class="line">输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</span><br><span class="line">例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。</span><br><span class="line">NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">旋转数组其实就是把数组前面的某几个元素放到数组末尾。</span><br><span class="line"></span><br><span class="line">因为是旋转数组，一开始的想法是从数组末尾开始向前寻找，直到找到</span><br><span class="line">a[i-1]&gt;a[i]，的这个i的位置。这个位置就是最小值。</span><br><span class="line">但是这个最坏情况下是O(n)，也就是旋转个数很小的话，相当于是个O(n)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有一个是二分寻找，两个指针l和r，l在前半段的范围，r在后半段的范围</span><br><span class="line">每次找l和r的mid，如果a[mid]&gt;=a[l]，那么l=mid，如果a[mid]&lt;=a[r]，</span><br><span class="line">r=mid，如果r-l==1，那么r所在的位置就是最小值。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="寻找a-i-1-gt-a-i"><a href="#寻找a-i-1-gt-a-i" class="headerlink" title="寻找a[i-1]&gt;a[i]"></a>寻找a[i-1]&gt;a[i]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[l] &lt; a[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) &#123;</span><br><span class="line">                res = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分寻找a-i"><a href="#二分寻找a-i" class="headerlink" title="二分寻找a[i]"></a>二分寻找a[i]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a[l] &gt;= a[r]) &#123;</span><br><span class="line">            <span class="comment">//r指向的是后面的区间,l指向的是前面的区间</span></span><br><span class="line">            <span class="comment">//当r-l==1的时候r就是最小的索引</span></span><br><span class="line">            <span class="keyword">if</span> (r-l == <span class="number">1</span>) &#123;</span><br><span class="line">                index = r;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//这是特殊情况，当数组中元素不是递增的时候</span></span><br><span class="line">            <span class="comment">//就得线性查找</span></span><br><span class="line">            <span class="keyword">if</span> (a[l] == a[mid] &amp;&amp; a[r] == a[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> find(l, r, a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里二分，因为是两个递增的序列，所以可以直接根据</span></span><br><span class="line">            <span class="comment">//mid的位置判断二分之后选择的区间</span></span><br><span class="line">            <span class="keyword">if</span> (a[l] &lt;= a[mid]) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[r] &gt;= a[mid]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特殊情况时，线性查找</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            min = Math.min(min, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>当优化O(n)的时候，排除动态规划的时候可以选择二分。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk最大连续子数组和</title>
    <url>/2020/01/30/nk%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给一个数组，求最大连续子数组和</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6,-3,-2,7,-15,1,2,2</span><br><span class="line"></span><br><span class="line">答案是8。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>明显dp，dp[i]表示以a[i]为末尾元素的所有子数组们的最大值，这个子数组的最大的和，如果dp[i-1]&gt;=0，dp[i] = a[i]+dp[i-1]，如果dp[i-1]&lt;0，dp[i] = a[i].</li>
<li>所有的dp[i]求出来之后，就相当于有了以数组中每个元素结尾的连续的子数组的最大值，找出所有dp[i]的最大值就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = a[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>


<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk菲波那切数列序列</title>
    <url>/2020/01/16/nk%E6%96%90%E6%B3%A2%E9%82%A3%E9%94%B2%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>斐波那锲序列leetcode里面做过了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line">        <span class="keyword">return</span> f(n,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[n] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[n];</span><br><span class="line"></span><br><span class="line">        nums[n] = f(n - <span class="number">1</span>, nums) + f(n - <span class="number">2</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> nums[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk最小的k个数</title>
    <url>/2020/01/20/nk%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">经典题了。</span><br><span class="line">本质是N个数中最小(大)的K个数，明显用堆可以做。用一个最大堆存放K个数，每次</span><br><span class="line">遇到新数，新数都和堆顶元素进行比较，如果新数小于堆顶元素(其实就是堆里面最大</span><br><span class="line">的元素)，堆顶元素就替换成新数(堆此时会把新的最大元素放到堆顶，不一定是新数)，</span><br><span class="line">因为这样做会不断让堆顶元素变小，遍历过所有元素之后，堆里面的元素就是K个最小</span><br><span class="line">元素了。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//因为java默认是最小堆，所以要使用最大堆，重新定义一下优先级就行了</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//谁大谁的优先级小</span></span><br><span class="line">                <span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//不符合题意的直接返回空集合</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || k &gt; nums.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            heap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//新元素如果比堆顶元素小，就出队</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; heap.peek()) &#123;</span><br><span class="line">                heap.remove();</span><br><span class="line">                <span class="comment">//然后给堆添加新元素</span></span><br><span class="line">                heap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())</span><br><span class="line">            res.add(heap.remove());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk机器人的运动范围</title>
    <url>/2020/02/01/nk%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一</span><br><span class="line">次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的</span><br><span class="line">数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），</span><br><span class="line">因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19</span><br><span class="line">。请问该机器人能够达到多少个格子？</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">明显递归走格子。走过的地方加标记。每次递归的时候判断范围就行。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">//标记数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] book;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span> || cols == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        book = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, rows, cols, threshold);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断坐标合法</span></span><br><span class="line">        <span class="keyword">if</span> (!check(i, j, k))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//判断是否走过</span></span><br><span class="line">        <span class="keyword">if</span> (book[i][j] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常的递归就行</span></span><br><span class="line">        res++;</span><br><span class="line">        book[i][j] = <span class="number">1</span>;</span><br><span class="line">        dfs(i + <span class="number">1</span>, j, rows, cols, k);</span><br><span class="line">        dfs(i - <span class="number">1</span>, j, rows, cols, k);</span><br><span class="line">        dfs(i, j + <span class="number">1</span>, rows, cols, k);</span><br><span class="line">        dfs(i, j - <span class="number">1</span>, rows, cols, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += j % <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk变态跳台阶</title>
    <url>/2020/01/20/nk%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">既然要找一个树是不是另一个树的子结构，那么我的做法是先先序遍历root1，</span><br><span class="line">找到root1中root2中相同根节点的树，在这个节点开始进行判断这两个树一不一样，</span><br><span class="line">因为先序遍历会遍历到一棵树的任何节点，所以在root1中找到某个和root2相同节点值</span><br><span class="line">的节点之后进行判断这root2是否和root1的部分相同(这么做的原因是省点时间，因为</span><br><span class="line">如果对root1中每节点都进行一次数的判断，太浪费时间了)。</span><br><span class="line"></span><br><span class="line">找到root1中某个部分后，就判断root2是不是root1中这个部分的子结构，同样还是递归，</span><br><span class="line">和二叉树的镜像判断很像。</span><br><span class="line"></span><br><span class="line">只不过要注意到一点，在判断二叉树的镜像的时候两棵树是一样的，没有存在谁比谁多几个节点</span><br><span class="line">的情况，所以通过遍历方式来判断一棵树是否是另一棵树的递归终止条件就要发生变化</span><br><span class="line">因为cur2的结构是小于等于cur1的，所以在两者根都不空的条件下是可以拿当cur2==null</span><br><span class="line">时做递归终止的第一个条件的。因为cur2的结构可能就是那么小。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        f1(root1,root2);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cur1进行先序遍历，直到找到根节点和cur2相同的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(TreeNode cur1, TreeNode cur2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到节点之后，进行判断cur2是否时cur1的一部分</span></span><br><span class="line">        <span class="keyword">if</span> (cur1.val == cur2.val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="keyword">false</span>)</span><br><span class="line">                flag = f2(cur1, cur2);</span><br><span class="line">        &#125;</span><br><span class="line">        f1(cur1.left, cur2);</span><br><span class="line">        f1(cur1.right, cur2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">f2</span><span class="params">(TreeNode cur1, TreeNode cur2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为根节点已经确定了cur1.val==cur2.val，所以这里</span></span><br><span class="line">        <span class="comment">//cur2为空只能说明cur2结构小。</span></span><br><span class="line">        <span class="keyword">if</span> (cur2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//cur1为空自然返回为false</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//值不相同自然也是</span></span><br><span class="line">        <span class="keyword">if</span> (cur1.val != cur2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点相同的话，就去比较子树。</span></span><br><span class="line">        <span class="keyword">return</span> f2(cur1.left, cur2.left) &amp;&amp; f2(cur1.right, cur2.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">还是多找规律，比如此处判断一棵树是不是另一棵树的子结构，如果按照判断</span><br><span class="line">一棵树是不是镜像的那种做法同时进行先序遍历的时候，这里如果一棵树的结构</span><br><span class="line">比另一棵树的结构小的话，同时进行遍历的话倒是可以判断两棵树一不一样，</span><br><span class="line">但是递归因为停不下来所以判断不出来子结构的问题，但是加一个递归终止条件</span><br><span class="line">为 cur2==null?return true:false;就可以了。这个递归终止条件很巧妙。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk构建乘积数组</title>
    <url>/2020/02/11/nk%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],</span><br><span class="line">其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。</span><br><span class="line">不能使用除法。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>相当于算b[i]的时候是从a[0]<em>a[1]</em> … * a[i-1] * a[i+1]* a[i+2] * a[n-1]。</li>
<li>那就可以分成两段，前半段是a[0]…a[i-1]，后半段是a[i+1]..a[n-1]。这两段的乘积就是b[i]。因为b在数组的位置，可以看成一个矩阵。<img src="/image/%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF.png" alt>。在每一行中，阴影前面的所有的数的乘积是t1，后面的是t2，那么每一行的b[i] = t1*t2。而每一行的t1都可以从上一行的t1 * a[i-1]的来，可见t是有规律的，所以根据这个规律，把每一行的t都求出来，保存到c数组里面。同理处理t2，保存到d数组里面。那么求每一行的b[i]就是c[i] * d[i]了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="看成矩阵"><a href="#看成矩阵" class="headerlink" title="看成矩阵"></a>看成矩阵</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line"></span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        d[d.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//求出每一行的c[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//c[i]可以根据上一行得到</span></span><br><span class="line">            c[i] = c[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出每一行的d[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//d[i]可以根据下一行得到</span></span><br><span class="line">            d[i] = d[i + <span class="number">1</span>] * a[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="comment">//根据c[i]和d[i]求出b[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = c[i] * d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk正则表达式匹配</title>
    <url>/2020/02/11/nk%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数用来匹配包括&apos;.&apos;和&apos;*&apos;的正则表达式。模式中的字符&apos;.&apos;</span><br><span class="line">表示任意一个字符，而&apos;*&apos;表示它前面的字符可以出现任意次（包含0次）。</span><br><span class="line"> 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;</span><br><span class="line"> 与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>当模式中的第二个字符不是“*”时：<br>1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。<br>2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</p>
<p>而当模式中的第二个字符是“<em>”时：<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：<br>1、模式后移2字符，相当于x</em>被忽略；<br>2、字符串后移1字符，模式后移2字符；<br>3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</p>
<p>这里需要注意的是：Java里，要时刻检验数组是否越界。</p>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="逐个分析情况"><a href="#逐个分析情况" class="headerlink" title="逐个分析情况"></a>逐个分析情况</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> cur1, <span class="keyword">char</span>[] p, <span class="keyword">int</span> cur2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当两个指针指向的全都是末端的时候就表明通配完成</span></span><br><span class="line">        <span class="keyword">if</span> (s.length == cur1 &amp;&amp; p.length == cur2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果模式串先完，自然匹配不成功</span></span><br><span class="line">        <span class="keyword">if</span> (p.length == cur2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果第二位是*</span></span><br><span class="line">        <span class="keyword">if</span> (cur2 + <span class="number">1</span> &lt; p.length &amp;&amp; p[cur2 + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">//如果相同</span></span><br><span class="line">            <span class="keyword">if</span> (p[cur2] == <span class="string">'.'</span> &amp;&amp; cur1 &lt; s.length || cur1 &lt; s.length &amp;&amp; s[cur1] == p[cur2]&#123;</span><br><span class="line">                <span class="comment">//相同有三种情况</span></span><br><span class="line">                <span class="keyword">return</span> dfs(s, cur1 + <span class="number">1</span>, p, cur2) ||</span><br><span class="line">                        dfs(s, cur1, p, cur2 + <span class="number">2</span>) ||</span><br><span class="line">                        dfs(s, cur1 + <span class="number">1</span>, p, cur2 + <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不相同只有一种情况</span></span><br><span class="line">                <span class="keyword">return</span> dfs(s, cur1, p, cur2 + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二位不是*</span></span><br><span class="line">        <span class="keyword">if</span> (cur1 &lt; s.length &amp;&amp; cur2 &lt; p.length) &#123;</span><br><span class="line">            <span class="comment">//如果两者相同，直接看下一位</span></span><br><span class="line">            <span class="keyword">if</span> (s[cur1] == p[cur2] || p[cur2] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> dfs(s, cur1 + <span class="number">1</span>, p, cur2 + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>明白了字符匹配的感觉。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk求1+2+3+...+n</title>
    <url>/2020/02/02/nk%E6%B1%821+2+3+...+n/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">求1+2+3+...+n，要求不能使用乘除法、for、while、if</span><br><span class="line">、else、switch、case等关键字及条件判断语句（A?B:C）。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>前n项和公式</li>
<li>递归</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n + f(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk用两个栈实现队列</title>
    <url>/2020/01/16/nk%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>模拟一下，很自然的就能想到：一个栈做入栈(stack1)，另一个栈做出栈(stack2)，入栈不用说，出栈的时候每次出栈的时候如果stack2是空，就把stack1的所有内容放到stack2里面(这里顺序就和队列的顺序一样了)，如果stack2不是空，就直接返回栈顶元素。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk矩阵中的路径</title>
    <url>/2020/02/11/nk%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字</span><br><span class="line">符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向</span><br><span class="line">左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个</span><br><span class="line">格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e </span><br><span class="line">矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，</span><br><span class="line">因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不</span><br><span class="line">能再次进入该格子。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>常规dfs，dfs寻路</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs寻路"><a href="#dfs寻路" class="headerlink" title="dfs寻路"></a>dfs寻路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] book;</span><br><span class="line">    <span class="comment">//最后结果，在递归过程中会被改变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] chs = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">        <span class="comment">//把数据放到二维数组里面</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; matrix.length; t++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= cols) &#123;</span><br><span class="line">                i %= cols;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            chs[r][i] = matrix[t];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记数组</span></span><br><span class="line">        book = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="comment">//因为不是起点开始的，所以对于每一个点都进行一次dfs</span></span><br><span class="line">                dfs(chs, rows, cols, str, <span class="number">0</span>, i, j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; book.length; k++) &#123;</span><br><span class="line">                    Arrays.fill(book[k], <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] chs, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        //要注意递归终止条件一定要写在最上面</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (index == str.length)</span> </span>&#123;</span><br><span class="line">            res = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果走过就不走了</span></span><br><span class="line">        <span class="keyword">if</span> (book[i][j])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果不是想要的字符,不走递归</span></span><br><span class="line">        <span class="keyword">if</span> (chs[i][j] != str[index])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        book[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(chs, rows, cols, str, index + <span class="number">1</span>, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(chs, rows, cols, str, index + <span class="number">1</span>, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(chs, rows, cols, str, index + <span class="number">1</span>, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(chs, rows, cols, str, index + <span class="number">1</span>, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>递归终止条件要写在递归函数最开始的地方😂。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&amp;tqId=11218&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&amp;tqId=11218&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk滑动窗口的最大值</title>
    <url>/2020/01/19/nk%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组&#123;2,3,4,2,6,2,5,1&#125;及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;； 针对数组&#123;2,3,4,2,6,2,5,1&#125;的滑动窗口有以下6个： &#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>优先队列，每隔size个数拿到size个数的最值，然后去掉size里面的第一个值，在给size里面添加新值，因为堆的性质，每次更新都是O(log n)复杂度，拿到堆顶是O(1)的，如此往后移动窗口，就能拿到所有窗口的最值，整体复杂度是O(N logn)。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为是最小堆，只需要定义大数的优先级小就能让大数在堆顶了</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.compareTo(o2) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; num.length || size &lt; <span class="number">1</span>) <span class="keyword">return</span> arrayList;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            heap.add(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次向右移动窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; num.length; i++) &#123;</span><br><span class="line">            arrayList.add(heap.peek());</span><br><span class="line">            heap.remove(num[i - size]);</span><br><span class="line">            heap.add(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到这里少统计一个窗口，所以对最后的窗口进行一个统计。</span></span><br><span class="line">        arrayList.add(heap.peek());</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>窗口，最大值，可以朝着堆来考虑。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk第一个只出现一次的字符</title>
    <url>/2020/02/02/nk%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第</span><br><span class="line">一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>因为只有字母，所以可以直接让每个字母对应其对应的ASCII码做索引，用一个长度为256的数组ch来进行计数，先遍历一遍str，然后为字符串里面的每个字符进行赋值，此时ch[i]代表的是字符的ASCII码是i的字符出现的次数，然后再遍历一遍字符串，遍历到第一个ch[i]是1的返回i进行了。</li>
<li>也可以用map存储</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            ch1[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch1[str.charAt(i)] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明数组</span></span><br><span class="line">        <span class="keyword">int</span> ch[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">//一定要初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i) &#123;</span><br><span class="line">            ch[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="用map"><a href="#用map" class="headerlink" title="用map"></a>用map</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.find(str[i]) == m.end()) &#123;</span><br><span class="line">                m.insert(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(str[i], <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m.insert(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(str[i], m[str[i]]++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1>]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk矩形覆盖</title>
    <url>/2020/01/18/nk%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</span><br><span class="line">```627</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"># 理解</span><br></pre></td></tr></table></figure>

<p>其实就是斐波那契。</p>
<p>比如有n个2<em>1的格子，假设它的铺法是f(n)，那么它可以看过n-1个2</em>1的格子竖着加一个2<em>1个格子。<br>也能看作n-2个2</em>1的格子横着加两个格子。所以f(n)的情况可以由f(n-1)和f(n-2)结合而成。 </p>
<p>所以f(n)=f(n-1)+f(n-2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"># 代码</span><br><span class="line">```java</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        int[] nums = new int[50000];</span><br><span class="line">        nums[0] = 0;</span><br><span class="line">        nums[1] = 1;</span><br><span class="line">        nums[2] = 2;</span><br><span class="line">        f(target, nums);</span><br><span class="line">        return nums[target];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int f(int n, int[] nums) &#123;</span><br><span class="line">        if (n==0)</span><br><span class="line">            return 0;</span><br><span class="line">        if (nums[n] != 0)</span><br><span class="line">            return nums[n];</span><br><span class="line">        //斐波那契</span><br><span class="line">        nums[n] = f(n - 1, nums) + f(n - 2, nums);</span><br><span class="line">        return nums[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk翻转单词顺序列</title>
    <url>/2020/02/09/nk%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，</span><br><span class="line">写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向</span><br><span class="line">Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。</span><br><span class="line">后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是</span><br><span class="line">“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能</span><br><span class="line">帮助他么？</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>因为单词之间都有空格的，所以把字符串按照” “分割就行，得到的字符串数组进行倒序拼接就行了。不过要注意到一种特殊情况，如果字符串内容全是” “或者”     “，这类都是n个空格字符拼接成的字符串，按照” “进行split的时候返回的字符数组是没有内容的，所以自己再生成一个对应的字符串，在结果进行特判就好咯。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空串进行特判</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.equals(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分割产生字符串</span></span><br><span class="line">        String[] s = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">//sb是正常情况的最后拼接的字符串</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//sb2是为了防止n个空白字符拼接的成的没有内容但是有长度的字符串</span></span><br><span class="line">        StringBuffer sb2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//先造一个最后特判的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            sb2.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正常情况的倒叙拼接字符串数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s[i]);</span><br><span class="line">                sb.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后的特判，看题目给的字符串是不是没有内容的字符串，即n个宫格字符</span></span><br><span class="line">        <span class="keyword">return</span> sb2.toString().equals(str) ? sb2.toString() : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>“      “这个字符串对于” “进行split的时候返回的字符串数组没有内容</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk调整数组顺序使得奇数在偶数前面</title>
    <url>/2020/02/05/nk%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%BE%97%E5%A5%87%E6%95%B0%E5%9C%A8%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有</span><br><span class="line">的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇</span><br><span class="line">数和奇数，偶数和偶数之间的相对位置不变。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>让数组里面的所有的奇数在前面，偶数在后面。并且奇数和奇数，偶数和偶数的相对位置不能变。</li>
<li>一开始想的是用两个集合，一个存奇数，一个存偶数，这样可以保持奇数偶数的相对位置不变。</li>
<li>题目给出的信息是稳定性，而且一定程度上有序，然后可以用插入排序。每次遇到奇数的时候，就把这个奇数一直往前插，知道插到从头数的最后一个奇数后面，插入的过程中，其实是偶数后移的过程，每次遇到偶数就后移。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="两个集合"><a href="#两个集合" class="headerlink" title="两个集合"></a>两个集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计奇数</span></span><br><span class="line">        ArrayList&lt;Integer&gt; a1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//统计偶数</span></span><br><span class="line">        ArrayList&lt;Integer&gt; a2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                a2.add(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a1.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : a1) &#123;</span><br><span class="line">            array[t] = integer;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : a2) &#123;</span><br><span class="line">            array[t] = integer;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//遇到奇数进行插入排序</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = a[i];</span><br><span class="line">                <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//把偶数后移</span></span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + <span class="number">1</span>] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk表示数值的字符串</title>
    <url>/2020/02/11/nk%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</span><br><span class="line">例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 </span><br><span class="line">但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>写正则表达式的时候要确定那些东西是否出现就行了。还要确保哪些东西一起出现，哪些东西一起不出现。</li>
<li>数字前面的加号和减号是可以出现或者不出现的，加号减号后面的数字是可以出现或者不出现的，数字后面的小数部分中的小数点和小数点后面的数字是一起出现的，而如果出现小数点，小数点后面的数字有是必须出现的，后面的指数部分，e和加号减号，和指数部分里面的数字是一起出现的。</li>
</ol>
<p>/*<br>以下对正则进行解释:<br>[\+\-]?            -&gt; 正或负符号出现与否<br>\d*                 -&gt; 整数部分是否出现，如-.34 或 +3.34均符合<br>(\.\d+)?           -&gt; 如果出现小数点，那么小数点后面必须有数字；<br>                        否则一起不出现<br>([eE][\+\-]?\d+)? -&gt; 如果存在指数部分，那么e或E肯定出现，+或-可以不出现，<br>                        紧接着必须跟着整数；或者整个部分都不出现<br>*/</p>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(str);</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"[\\+\\-]?\\d*(\\.\\d+)?([eE][\\+\\-]?\\d+)?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&amp;tqId=11206&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&amp;tqId=11206&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>nk跳台阶</title>
    <url>/2020/01/16/nk%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>斐波那锲序列一样的，跳上第n节台阶都是从第n-1上跳1节和第n-2上跳2节达到的。f(n)=f(n-1)+f(n-2)，并且f(1)=1,f(2)=2。</li>
<li>用动态规划也行，用递归剪枝也行。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5000</span>];</span><br><span class="line">        <span class="keyword">return</span> f(n,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[n] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[n];</span><br><span class="line"></span><br><span class="line">        nums[n] = f(n - <span class="number">1</span>, nums) + f(n - <span class="number">2</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> nums[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk重建二叉树</title>
    <url>/2020/01/18/nk%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历和中序遍历其实是有联系的，比如说前序遍历的第一个节点是根节点，而</span><br><span class="line">中序遍历的顺序是先遍历根节点的所有左孩子再遍历根节点的右孩子，所以可以根据</span><br><span class="line">前序遍历来找到根节点，然后从再中序遍历里面根据根节点来找左右孩子。</span><br><span class="line"></span><br><span class="line">比如明显这棵树的根节点就是1，那么再中序遍历中4,7,2就是1的所有左孩子，5,3,8,6</span><br><span class="line">就是1的所有右孩子。同样的道理，继续看前序遍历下一个数字是2，那么4，7就是2的</span><br><span class="line">左孩子，2没有右孩子。7又是4的右孩子。</span><br><span class="line"></span><br><span class="line">根据这样的道理可以进行递归。每次根据前序遍历的顺序再中序遍历所对应的区间来递归</span><br><span class="line">创建一棵树。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(pre, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//采用递归创建，l和r表示当前节点的所在的区间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (step &gt;= pre.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(in[l]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从中序遍历中找到前序遍历得到的根节点</span></span><br><span class="line">        <span class="comment">//根据这个index来对中序遍历进行递归创建</span></span><br><span class="line">        <span class="keyword">int</span> index = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[step] == in[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建这个区间对应的节点</span></span><br><span class="line">        TreeNode cur = <span class="keyword">new</span> TreeNode(pre[step]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个区间没有左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (index == l) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            cur.right = f(pre, in, index + <span class="number">1</span>, r);</span><br><span class="line">            cur.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果这个区间没有右孩子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == r) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            cur.left = f(pre, in, l, index - <span class="number">1</span>);</span><br><span class="line">            cur.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果这个区间既有左孩子又有右孩子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            step++;</span><br><span class="line">            cur.left = f(pre, in, l, index - <span class="number">1</span>);</span><br><span class="line">            step++;</span><br><span class="line">            cur.right = f(pre, in, index + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>多找规律</li>
<li>树的问题共性解决不了就从遍历入手。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk链表中倒数第K个节点</title>
    <url>/2020/02/01/nk%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个链表，输出该链表中倒数第k个结点。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>第一遍遍历链表得到链表长度len，然后用长度len-k得到下次应该遍历的次数t，然后下次从头开始遍历cnt次到第k个节点的时候直接返回节点就行了。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历长度</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒数第K个节点其实就是正数第t个节点</span></span><br><span class="line">        <span class="keyword">int</span> t = len - k;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历t次直接返回节点就行了</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == t)</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            cnt++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>nk链表中环的入口节点</title>
    <url>/2020/02/06/nk%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>一开始想的是标记数组，走过的地方走一个标记。</li>
<li>左神说有一个定理，在链表中，比如有两个指针，一个快指针一个慢指针，快指针一次走两步，慢指针一次走一步，如果两个指针相遇，那么两个指针相同的节点一定是在环内。此时如果给一个指针赋值为链表头节点，两个指针都同时往后走一步，直到两个指针相遇的地方，这个地方就是环的开始节点。</li>
<li>设定一个特殊的地址值，如果走过这个节点就把这个节点的next域指向这个特殊的节点，然后向后遍历节点，给每个节点都这样进行操作，如果存在环，那么一定存在某个节点，这个节点指向特殊域，然后返回这个节点就行了。这个方法其实就是对走过的节点进行一个标记。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        ArrayList&lt;ListNode&gt; book = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果发现走过，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (book.contains(cur)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            book.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode f = pHead;</span><br><span class="line">        ListNode l = pHead;</span><br><span class="line">        <span class="keyword">while</span> (f.next != <span class="keyword">null</span> &amp;&amp; l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            f = f.next.next;</span><br><span class="line">            l = l.next;</span><br><span class="line">            <span class="comment">//如果快慢指针相遇就说明到了环内</span></span><br><span class="line">            <span class="keyword">if</span> (f == l) &#123;</span><br><span class="line">                f = pHead;</span><br><span class="line">                <span class="comment">//然后定理的内容，让一个指针从头开始</span></span><br><span class="line">                <span class="comment">//两个链表都每次往后走一步，那么两个</span></span><br><span class="line">                <span class="comment">//指针再次相遇的地方就是在链表的开始节点/</span></span><br><span class="line">                <span class="keyword">while</span> (f != l) &#123;</span><br><span class="line">                    f = f.next;</span><br><span class="line">                    l = l.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给链表遍历过的节点的地址值加标记"><a href="#给链表遍历过的节点的地址值加标记" class="headerlink" title="给链表遍历过的节点的地址值加标记"></a>给链表遍历过的节点的地址值加标记</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设定一个特殊地址值</span></span><br><span class="line">        ListNode special = <span class="keyword">new</span> ListNode(Integer.MIN_VALUE);</span><br><span class="line">        <span class="comment">//从头开始</span></span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//查看当前节点是否走过</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next == special) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先保留每个节点的下一个节点</span></span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            <span class="comment">//把每个节点的next域都指向特定的节点</span></span><br><span class="line">            cur.next = special;</span><br><span class="line">            <span class="comment">//更新节点位置</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol>
<li>链表环的定理。左神说有一个定理，在链表中，比如有两个指针，一个快指针一个慢指针，快指针一次走两步，慢指针一次走一步，如果两个指针相遇，那么两个指针相同的节点一定是在环内。此时如果给一个指针赋值为链表头节点，两个指针都同时往后走一步，直到两个指针相遇的地方，这个地方就是环的开始节点。</li>
</ol>
<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>定理</tag>
      </tags>
  </entry>
  <entry>
    <title>nk顺时针打印矩阵</title>
    <url>/2020/02/07/nk%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，</span><br><span class="line">例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 </span><br><span class="line">13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>这道题是真的恶心，首先在找规律，发现每次从左上角选一圈的起点，举个例子，第一圈是(0,0)，第二圈是(1,1)，第三圈是(2,2)，假设这个起点里面的数是start，那么循环选圈保持的条件是row &gt; start * 2 &amp;&amp; col &gt; start * 2，每次寻找到每一圈的起点之后就开始打印指定起点的一圈就行了。</li>
<li>找到起点之后，那么如何打印一圈呢？其实打印可以分4步，分别是从左到右，从上到下，从右到左，从下到上。而且这4步因为矩阵的不确定性，不确定4步都是要走的，但是可以确定，如果走第n步，那么第n-1是一定要走的，所以只需要从第一步开始逐个写每一步的前提条件就行。</li>
<li>在这里需要得到每一圈的右下角，试想如果有每一圈的左上角和右下角，那么边界问题是不是可以很好的解决。那么回过头来看每一步的前提条件，第一步没有前提条件，第二步的前提条件就是要确保这一圈至少有两行，第三步要确保这一圈至少有两行两列(第二步的条件是两行，第三步的条件是两列)，第四步条件是三行两列。因为第三步占了一列，而且第三步可能和第二步在同一列，所以第四步需要三行两列。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为start每走一步，对于矩阵相当于少两列和两行。所以*2</span></span><br><span class="line">        <span class="keyword">while</span> (row &gt; start * <span class="number">2</span> &amp;&amp; col &gt; start * <span class="number">2</span>) &#123;</span><br><span class="line">            f(res, start, row, col, matrix);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(ArrayList&lt;Integer&gt; res, <span class="keyword">int</span> start, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到右下角的坐标</span></span><br><span class="line">        <span class="keyword">int</span> endx = col - <span class="number">1</span> - start;</span><br><span class="line">        <span class="keyword">int</span> endy = row - <span class="number">1</span> - start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这一圈打印第一步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endx; i++) &#123;</span><br><span class="line">            res.add(matrix[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有两行</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; endy) &#123;</span><br><span class="line">            <span class="comment">//第二步</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endy; i++) &#123;</span><br><span class="line">                res.add(matrix[i][endx]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果两行两列</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; endy &amp;&amp; start &lt; endx) &#123;</span><br><span class="line">            <span class="comment">//第三步</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endx - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">                res.add(matrix[endy][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果三行两列</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; endx &amp;&amp; start &lt; endy - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endy - <span class="number">1</span>; i &gt;= start + <span class="number">1</span>; i--) &#123;</span><br><span class="line">                res.add(matrix[i][start]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>python语法糖</title>
    <url>/2019/09/06/python%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<h1 id="leetcode上的python"><a href="#leetcode上的python" class="headerlink" title="leetcode上的python"></a>leetcode上的python</h1><h2 id="接口的题目信息"><a href="#接口的题目信息" class="headerlink" title="接口的题目信息"></a>接口的题目信息</h2><ol>
<li><p>比如说这个接口的名字长这个样子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>本着leetcode上的代码都是设计接口的原则来分析一下这个接口的名字</p>
<ol>
<li>self，类似于java的this，可以代替调用这个方法的对象</li>
<li>参数nums:list[int]这个的是方法的注释，这个nums是一个里面装的都是int的list，这里的”:List[int]”都是注释，只是用来提示一下，并没有真的限定作用</li>
<li>-&gt;List[int]就是返回值是List[int]，这个的含义已经在上面解释过了</li>
</ol>
</li>
</ol>
<h2 id="题目的返回值"><a href="#题目的返回值" class="headerlink" title="题目的返回值"></a>题目的返回值</h2><ol>
<li><p>以两数之和的问题来举例子，如果需要返回一个list，而且list里面就两个数，那么通过以下这种写法就可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure>
</li>
<li><p>不同于java的是，list在python可以直接用[]来表示，在java代码中完成上述的功能的话需要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>仔细对比两种代码，python不用写new，而且list直接是通过[]来表达的，这样就更为简洁</p>
</li>
</ol>
<h2 id="sum求和函数"><a href="#sum求和函数" class="headerlink" title="sum求和函数"></a>sum求和函数</h2><ol>
<li>用sum函数可以直接对list或者range求和<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sum1 = sum(list)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="创建一个set"><a href="#创建一个set" class="headerlink" title="创建一个set"></a>创建一个set</h2><ol>
<li><p>python中的set是有序切唯一的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = set()</span><br><span class="line"></span><br><span class="line"># 增加元素</span><br><span class="line">s.add(1)</span><br><span class="line">s.add(2)</span><br><span class="line">s.add(0)</span><br><span class="line">s.add(0)</span><br><span class="line"></span><br><span class="line">print(s) # 结果是 0,1,2，表明set是有序且唯一的</span><br></pre></td></tr></table></figure>
</li>
<li><p>当尝试往set中存放一个不能排序的类型时，比如往set中添加一个list，会抛出</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: unhashable type: <span class="string">'list'</span></span><br></pre></td></tr></table></figure>

<p> 这样的异常，因为list是unhashable的</p>
</li>
<li><p>在set中查询一个元素是比在list中查询一个元素是要快的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先造一个set</span><br><span class="line">s = set()</span><br><span class="line">s.add(1)</span><br><span class="line">s.add(2)</span><br><span class="line"></span><br><span class="line"># 再造一个list</span><br><span class="line">l = [1,2,3,4]</span><br><span class="line"></span><br><span class="line">if 1 in s:</span><br><span class="line">    print(&apos;set中存在1&apos;)</span><br><span class="line"></span><br><span class="line">if 1 in list:</span><br><span class="line">    print(&apos;list中存在1&apos;)</span><br></pre></td></tr></table></figure>

<p> 从中是可以发现set中查找某个值的速度是要比在list中查询某个值的速度要快的多的，因为set的底层是hash，现在还暂时不知道set的底层</p>
</li>
</ol>
<h2 id="python中的栈和队列"><a href="#python中的栈和队列" class="headerlink" title="python中的栈和队列"></a>python中的栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol>
<li><p>简易一点的话就是通过list来模拟栈，只处理末尾的元素，就相当于处理栈</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用list来代替栈</span></span><br><span class="line">stack = []</span><br><span class="line">stack.append(<span class="number">1</span>)</span><br><span class="line">stack.append(<span class="number">2</span>)</span><br><span class="line">stack.append(<span class="number">3</span>)</span><br><span class="line">print(stack)  <span class="comment"># [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line">print(stack)  <span class="comment"># [1, 2]</span></span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line">print(stack)  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或者就是自己封装一个简易的栈咯</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3></li>
<li><p>用collections包下的deque来当队列用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入deque</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">queue = deque()</span><br><span class="line">queue.append(<span class="number">1</span>)</span><br><span class="line">queue.append(<span class="number">2</span>)</span><br><span class="line">queue.append(<span class="number">3</span>)</span><br><span class="line">print(queue)  <span class="comment"># deque([1, 2, 3])</span></span><br><span class="line"></span><br><span class="line">queue.popleft()</span><br><span class="line">print(queue)  <span class="comment"># deque([2, 3])</span></span><br><span class="line"></span><br><span class="line">queue.popleft()</span><br><span class="line">print(queue)  <span class="comment"># deque([3])</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="用内置的API在主串中寻找子串的位置"><a href="#用内置的API在主串中寻找子串的位置" class="headerlink" title="用内置的API在主串中寻找子串的位置"></a>用内置的API在主串中寻找子串的位置</h2><p>python3中在主串中找子串的时候，如果找不到会抛出异常ValueError</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = &apos;aaaaaa&apos;</span><br><span class="line">s2 = &apos;bbbb&apos;</span><br><span class="line"></span><br><span class="line">print(s1.index(s2)) # 会抛出ValueError: substring not found 这样的异常</span><br></pre></td></tr></table></figure>

<h2 id="leetcode上的python类"><a href="#leetcode上的python类" class="headerlink" title="leetcode上的python类"></a>leetcode上的python类</h2><ol>
<li>有时候leetcode的Solution类中的属性在不同的测试用例中可能会有残余，比如kmp那道题的next数组就是因为没有在类中清空才导致莫名其妙的错。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list = []</span><br><span class="line"><span class="comment"># 清空数组</span></span><br><span class="line">list.clear()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="python中的引用类型的空值为None"><a href="#python中的引用类型的空值为None" class="headerlink" title="python中的引用类型的空值为None"></a>python中的引用类型的空值为None</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个节点，然后节点的左右子节点的初始引用值都是None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="python中判断集合相等的方法"><a href="#python中判断集合相等的方法" class="headerlink" title="python中判断集合相等的方法"></a>python中判断集合相等的方法</h2><ol>
<li>可以直接==来判断是否相同<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">print(list1 == list2) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="判断一个对象是否是一个某个类型"><a href="#判断一个对象是否是一个某个类型" class="headerlink" title="判断一个对象是否是一个某个类型"></a>判断一个对象是否是一个某个类型</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">if</span> isinstance(d, dict):</span><br><span class="line">    print(<span class="string">'d是字典类型'</span>)</span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> isinstance(l, list):</span><br><span class="line">    print(<span class="string">'l是list类型'</span>)</span><br><span class="line"></span><br><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> isinstance(t, tuple):</span><br><span class="line">    print(<span class="string">'t是tuple类型'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="python中的字符转ascii码"><a href="#python中的字符转ascii码" class="headerlink" title="python中的字符转ascii码"></a>python中的字符转ascii码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把字符a转换成ascii码</span><br><span class="line">ord(&apos;a&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="python快速初始化集合"><a href="#python快速初始化集合" class="headerlink" title="python快速初始化集合"></a>python快速初始化集合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 集合li里面就有了100个元素0</span><br><span class="line">li = [0]*100</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="for的糖"><a href="#for的糖" class="headerlink" title="for的糖"></a>for的糖</h1><h2 id="for循环的循环体位置上的值"><a href="#for循环的循环体位置上的值" class="headerlink" title="for循环的循环体位置上的值"></a>for循环的循环体位置上的值</h2><ol>
<li><p>可以发现for循环上不仅可以放list，tuple，range</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for遍历list</span></span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for遍历tuple</span></span><br><span class="line">tu = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tu:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for遍历range</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环遍历字符串</span></span><br><span class="line">str = <span class="string">'abcdefg'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>那就可以根据这些被for使用东东来看他们都有一个共性：可迭代，用下面这个语句可以判断该值是否可以迭代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断对象是否是可迭代的，也是判断值是否是Iterable类型的</span></span><br><span class="line">print(isinstance(<span class="string">'hello'</span>, Iterable))</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以能得出一个结论，只要一个东西可以迭代，那就可以用for来迭代</p>
</li>
</ol>
<br>
<br>


<h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><ol>
<li><p>如果说想要一个列表，而且里面的元素都满足范围是在0~100中并且能整除3，那么原来的原来的写法就是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 声明一个目标li</span></span><br><span class="line">li = []</span><br><span class="line"><span class="comment"># 符合条件加入到li</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        li.append(i)</span><br><span class="line"></span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是这么些未免有点麻烦，如果用列表生成式的话就会简单不少</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for还是for，只不过是把if写了出来</span></span><br><span class="line">nli2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(nli2)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>
<br>

<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ol>
<li><p>正常来说用for就可以迭代列表，元组，字符串什么的，但是也可以用迭代器来迭代</p>
</li>
<li><p>举个迭代的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先生成一个列表</span></span><br><span class="line">nli = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 产生这个列表的迭代器</span></span><br><span class="line">it = iter(nli)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 迭代器每次拿出相对于当前元素的下一个元素</span></span><br><span class="line">        print(next(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面代码中为什么要捕获StopIteration这个异常呢？看一下next的源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(iterator, default=None)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    next(iterator[, default])</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Return the next item from the iterator. If default is given and the iterator</span></span><br><span class="line"><span class="string">    is exhausted, it is returned instead of raising StopIteration.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p> 英文的next函数每次返回当前迭代器的下一个元素。如果说default的值如果给了并且迭代器走完的时候，就不会抛出一个StopIteration异常，而是直接返回给的默认值default。那么从中可以看出当迭代器走完的时候并且default也没有值的那种情况的时候，就会抛出一个StopIteration异常，通过抛出异常的形式来表明迭代完毕了，如果迭代器走完并且default有值，那么就不会抛出StopIteration异常，而是直接返回给的default值。</p>
</li>
<li><p>所以说上面的代码需要捕捉一个StopIteration异常来使死循环停止，同样的也可以使用default在不产生异常的情况来遍历一个迭代类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nli = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">it = iter(nli)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 这里假设default的值是111，因为如果default有值并且next到了底，这时候next的返回值就是default的值。</span></span><br><span class="line">    <span class="comment"># 通过next的返回值可以表明迭代器循环到底了</span></span><br><span class="line">    x = next(it, <span class="number">111</span>)</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">111</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>
<br>

<h1 id="python的自定义函数"><a href="#python的自定义函数" class="headerlink" title="python的自定义函数"></a>python的自定义函数</h1><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如说这里的f函数有一个参数b有默认值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b=<span class="number">2</span>)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么下面这三种赋值方法都是正确的</span></span><br><span class="line">f(<span class="number">1</span>)  <span class="comment"># a=1,b=2</span></span><br><span class="line">f(<span class="number">2</span>)  <span class="comment"># a=2,b=2</span></span><br><span class="line">f(<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># a=3,b=3</span></span><br></pre></td></tr></table></figure>

<h2 id="多参数传递"><a href="#多参数传递" class="headerlink" title="多参数传递"></a>多参数传递</h2><ol>
<li><p>比如说要传递多个单个值的话原来的做法是</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c, d)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(c)</span><br><span class="line">    print(d)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是这样对于形参方面不太友好，那岂不是如果实参那里多一个参数，形参以后都要改一下？于是有了下面的写法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*nums)</span>:</span></span><br><span class="line">    print(nums)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p> 上面这种写法把形参那里做了优化，使得不管在实参这里不管传入多少个参数，都会被形参那里接收到一个list中</p>
</li>
<li><p>那么形参那里都做了优化，实参那里也可以做优化</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*nums)</span>:</span></span><br><span class="line">    print(nums)</span><br><span class="line"></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># f(1, 2, 3, 4) 这是以前的写法</span></span><br><span class="line">f(*list)    <span class="comment"># 因为用list代替了分开的数字，所以要在list前加一个*</span></span><br></pre></td></tr></table></figure>

<p> 从这种写法里可以看出，传入多个参数肯定是把它们封装到一个list中方便，于是给list前加一个*，来代替之前的分开的</p>
</li>
<li><p>同样的类似于1的方法传递多参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line">    print(age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f(<span class="string">'tom'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>同2,优化形参地方</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(**keys)</span>:</span></span><br><span class="line">    print(keys)</span><br><span class="line"></span><br><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'tom'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(name=dic[<span class="string">'name'</span>], age=dic[<span class="string">'age'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>同3,直接传递一个字典</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(**keys)</span>:</span></span><br><span class="line">    print(keys)</span><br><span class="line"></span><br><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'tom'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line">f(**dic)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当可变参数放在前面的时候，这时候不能确定实参到哪里算是传送结束，这时候只需要将可变参数后面的参数按照参数-值的键值对的形式传递就行了，如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ff</span><span class="params">(*y, x)</span>:</span></span><br><span class="line">    print(y)</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">ff(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, x=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p> 这样的例子在源码中的使用地方是print函数</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self, *args, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=None)</span>:</span> <span class="comment"># known special case of print</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Prints the values to a stream, or to sys.stdout by default.</span></span><br><span class="line"><span class="string">Optional keyword arguments:</span></span><br><span class="line"><span class="string">file:  a file-like object (stream); defaults to the current sys.stdout.</span></span><br><span class="line"><span class="string">sep:   string inserted between values, default a space.</span></span><br><span class="line"><span class="string">end:   string appended after the last value, default a newline.</span></span><br><span class="line"><span class="string">flush: whether to forcibly flush the stream.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="参数类型检查"><a href="#参数类型检查" class="headerlink" title="参数类型检查"></a>参数类型检查</h2><ol>
<li><p>主要用于检查形参的参数类型是否是指定的参数类型</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x,int):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'参数类型不正确'</span>)</span><br></pre></td></tr></table></figure>

<p> 如上代码就表示如果x不是int类型的话就会抛出异常</p>
</li>
</ol>
<h2 id="函数的文档注释"><a href="#函数的文档注释" class="headerlink" title="函数的文档注释"></a>函数的文档注释</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    这是sum函数的文档注释</span></span><br><span class="line"><span class="string">    :param x: x表示一个加数</span></span><br><span class="line"><span class="string">    :param y: y表示另一个加数</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, int):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'参数类型不正确'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure>

<h2 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h2><ol>
<li><p>如下代码可以解释：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fff</span><span class="params">(x, *, name, age)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(name)</span><br><span class="line">    print(age)</span><br><span class="line"></span><br><span class="line">fff(<span class="number">1</span>, name=<span class="string">'tom'</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p> 在形参列表里的参数中加入一个星号，那么星号在实参形参传递时就必须用键值对的形式传递</p>
</li>
</ol>
<br>
<br>


<h1 id="python中的面向对象"><a href="#python中的面向对象" class="headerlink" title="python中的面向对象"></a>python中的面向对象</h1><h2 id="定义一个普通类"><a href="#定义一个普通类" class="headerlink" title="定义一个普通类"></a>定义一个普通类</h2><ol>
<li>python中的普通类包括的内容有：实例成员、实例方法、类成员、类方法、静态方法。</li>
<li>如下是定义一个普通类<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    hobby = <span class="string">'睡觉'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一个参数若是self就说明这个方法是实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'调用了一个实例方法'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若一个方法被@classmethod修饰，并且第一个参数是cls，就说明这个方法是类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'调用了一个类方法'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若一个方法被@staticmethod修饰，表明这个方法是一个静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method3</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'调用了一个静态方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个类的对象</span></span><br><span class="line">s = Student()</span><br><span class="line"><span class="comment"># 与java不同，实例变量不需要提前声明，可以直接赋值</span></span><br><span class="line">s.name = <span class="string">'tom'</span></span><br><span class="line">s.age = <span class="string">'18'</span></span><br><span class="line"></span><br><span class="line">s.method1()  <span class="comment"># 调用了一个实例方法</span></span><br><span class="line">Student.method2()  <span class="comment"># 调用了一个类方法</span></span><br><span class="line">Student.method3()  <span class="comment"># 调用了一个静态方法</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ol>
<li>因为python中没有重载，所以一般构造方法都写无参的<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="comment"># 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'调用了构造方法'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student()  <span class="comment"># 调用了构造方法</span></span><br><span class="line"><span class="comment"># 需要注意的是，因为python中不存在重载的特性，所以构造方法加了形参的话，就会</span></span><br><span class="line"><span class="comment"># 把构造方法写死，不怎么方便，所以一般用无参的构造方法就行了</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ol>
<li>封装无非就是把一个类的属性设置为私有，然后通过get/set方法来获得和修改该属性的值，在python中在类变量之前加‘__’就可以把一个类变量变成私有变量<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="comment"># 以__开头的类属性就不再是类属性了，就是私有属性了</span></span><br><span class="line">    __name = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 常规的get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 常规的set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.set_name(<span class="string">'tom'</span>)</span><br><span class="line">print(s.get_name())</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="comment"># Person的两个类变量</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这两个类变量的get/set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Person类的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我叫%s,我%d岁'</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Student类继承Person类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="comment"># 子类新增加了一个属性</span></span><br><span class="line">    score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, score)</span>:</span></span><br><span class="line">        <span class="comment"># 子类调用父类的构造方法</span></span><br><span class="line">        Person.__init__(self, name, age)</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子类重写父类的speak()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我叫%s,我%d岁,我考了%d分'</span> % (self.name, self.age, self.score))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student(<span class="string">'tom'</span>, <span class="number">18</span>, <span class="number">100</span>).speak() <span class="comment"># 我叫tom,我18岁,我考了100分</span></span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol>
<li>同样的对象有不同的表现形式，比java的多态要多态<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'猫叫...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'狗叫...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.shout()</span><br><span class="line"></span><br><span class="line">play(Cat())</span><br><span class="line">play(Dog())</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="一些常用的魔术方法"><a href="#一些常用的魔术方法" class="headerlink" title="一些常用的魔术方法"></a>一些常用的魔术方法</h2><h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><p>这个类似于java的toString()方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    name = <span class="string">'tom'</span></span><br><span class="line">    age = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类似于toString()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'name = %s, age = %d'</span>%(self.name, self.age)</span><br><span class="line"></span><br><span class="line">c = Cat()</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<h3 id="len"><a href="#len" class="headerlink" title="len"></a>len</h3><p>常规来说一个对象是不能直接调用len()函数的，因为len()是用来计数的，一些类型可以用len()，比如list、string，因为这些有一个很明确的奇数的内容，如果自定义对象也想使用len()方法的话，就需要自己定义要计数的内容，比如说想在自定义对象调用len()的时候计算自己的name这个类属性的长度的话，就在自定义类中重写len这个魔术方法，示例如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    name = <span class="string">'tom'</span></span><br><span class="line">    age = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># len这个魔术方法自定义为计算自身name属性的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Cat()</span><br><span class="line"><span class="comment"># 重写了len的魔术方法，自定义对象就能使用len方法了</span></span><br><span class="line">print(len(c))</span><br></pre></td></tr></table></figure>

<h3 id="repr"><a href="#repr" class="headerlink" title="repr"></a>repr</h3><p>在对象调用repr函数的时候，会调用这个方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    name = <span class="string">'tom'</span></span><br><span class="line">    age = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'调用了repr方法'</span></span><br><span class="line">    </span><br><span class="line">c = Cat()</span><br><span class="line"><span class="comment"># 自定义对象调用repr方法</span></span><br><span class="line">print(repr(c))</span><br></pre></td></tr></table></figure>

<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p>自定义对象的一个bool函数，用来表示这个对象的某些属性在某些条件下的布尔值，当然这些条件都可以自定义,重写了bool魔术方法之后可以直接把对象放到表达式中，示例如下代码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    name = <span class="string">'tom'</span></span><br><span class="line">    age = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义bool的比较</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.age &gt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Cat()</span><br><span class="line">print(bool(c))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c:  <span class="comment"># 注意这里可以直接把对象放到表达式中，因为会自动调用对象的bool()方法</span></span><br><span class="line">    print(<span class="string">'这个对象里面的age属性的值大于10'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'这个对象里面的age属性的值小于10'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="gt、lt、eq"><a href="#gt、lt、eq" class="headerlink" title="gt、lt、eq"></a>gt、lt、eq</h3><p>当同一类型的两个对象用大于、小于、等于号进行比较的时候，会自动调用对应的魔术方法来进行比较</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义两个相同的对象使用大于号比较的时候，具体怎么比</span></span><br><span class="line">    <span class="comment"># 同理也可以用小于，等于</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.age &gt; other.age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = Cat()</span><br><span class="line">c2 = Cat()</span><br><span class="line">c1.age = <span class="number">10</span></span><br><span class="line">c2.age = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的大于号就走了gt的魔术方法</span></span><br><span class="line">print(c1 &gt; c2)</span><br></pre></td></tr></table></figure>

<h1 id="python中的切片"><a href="#python中的切片" class="headerlink" title="python中的切片"></a>python中的切片</h1><ol>
<li><p>list的切片是list</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    print(l[<span class="number">0</span>:<span class="number">3</span>])  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>str的切片是str</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = <span class="string">'abcdef'</span></span><br><span class="line">    print(s[<span class="number">0</span>:<span class="number">3</span>])  <span class="comment"># abc</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉最大堆的实现</title>
    <url>/2019/08/20/%E4%BA%8C%E5%8F%89%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要一个数组来存放最大堆</span></span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把一个数组转换成最大堆，也就是Heapify</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Array&lt;&gt;(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = parent(arr.length - <span class="number">1</span>) ; i &gt;= <span class="number">0</span> ; i --)</span><br><span class="line">            siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index-0 doesn't have parent."</span>);</span><br><span class="line">        <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向堆中添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先将e添加到数组末尾</span></span><br><span class="line">        data.addLast(e);</span><br><span class="line">        <span class="comment">//添加之后对e进行siftUp操作</span></span><br><span class="line">        siftUp(data.getSize() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次比较x和x的父节点的大小值，并且索引不越界</span></span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//若父节点小，则交换x与x的父节点的值</span></span><br><span class="line">            data.swap(k, parent(k));</span><br><span class="line">            <span class="comment">//更新x</span></span><br><span class="line">            k = parent(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看堆中的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">findMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.getSize() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can not findMax when heap is empty."</span>);</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出堆中最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        E ret = findMax();</span><br><span class="line"></span><br><span class="line">        data.swap(<span class="number">0</span>, data.getSize() - <span class="number">1</span>);</span><br><span class="line">        data.removeLast();</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(leftChild(k) &lt; data.getSize())&#123;</span><br><span class="line">            <span class="keyword">int</span> j = leftChild(k); <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt; data.getSize() &amp;&amp;</span><br><span class="line">                    data.get(j + <span class="number">1</span>).compareTo(data.get(j)) &gt; <span class="number">0</span> )</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// data[j] 是 leftChild 和 rightChild 中的最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//若x节点要比其左右孩子节点都要大的话，那么堆这时候的结构是没有被破坏的，所以也就再进行siftDown操作了</span></span><br><span class="line">            <span class="keyword">if</span>(data.get(k).compareTo(data.get(j)) &gt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//走到这里说明j已经存放了x的两个节点的最大节点的索引</span></span><br><span class="line">            data.swap(k, j);</span><br><span class="line">            <span class="comment">//更新x</span></span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出堆中的最大元素，并且替换成元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">replace</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        E ret = findMax();</span><br><span class="line">        data.set(<span class="number">0</span>, e);</span><br><span class="line">        siftDown(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有必要提及的点"><a href="#有必要提及的点" class="headerlink" title="有必要提及的点"></a>有必要提及的点</h1><ol>
<li>Heapify这个操作是将一个数组转化为一个堆，这里的Heapify转化为一个最大堆，最大堆最小堆的转化原理都是一样的，都是寻找到最后一个非叶子节点的节点所在的索引(因为是数组实现的堆，所以会有节点对应的索引这么一说，其次这个索引为最后一个叶子节点的父节点的索引)，然后从这个索引开始往回一个节点一个节点的开始siftDown操作。</li>
<li>对于用数组实现的堆中求父节点和子节点的索引<ol>
<li>当索引为0开始时：<ol>
<li>父节点：(i-1)/2</li>
<li>左孩子：i*2+1</li>
<li>右孩子：i*2+2</li>
</ol>
</li>
<li>当索引为1开始时：<ol>
<li>父节点：i/2</li>
<li>左孩子：i*2</li>
<li>右孩子：i*2+1</li>
</ol>
</li>
</ol>
</li>
<li>对于往堆中添加元素e的时候，操作是<ol>
<li>先把要添加的元素e放到数组的末尾</li>
<li>因为这时加入新元素可能会破坏堆的结构，所以要对置于末尾的元素e进行siftUp操作<ol>
<li>对于siftUp操作来说(这里以最大堆来实现)：假设元素x(x会变的)进行siftUp操作</li>
<li>把x与x的父节点进行大小比较，如果父节点要比x小的话，就交换这两个节点的位置(在数组中的实现就是交换两个索引上的值)</li>
<li>交换完后，此时x为之前的x的父节点，继续对新的x进行siftUp。</li>
</ol>
</li>
</ol>
</li>
<li>对于往堆中取出最大元素时，操作是<ol>
<li>先把要删除的元素的值先保留上</li>
<li>再把最后一个元素上的值与第一个元素上的值进行交换</li>
<li>然后删除最后一个元素</li>
<li>再对第一个元素进行siftDown操作<ol>
<li>对于siftDown操作：假设元素x进行siftDown操作</li>
<li>每次寻找x的左右孩子节点的最大值(用最大值的原因是防止更新以后的x节点比左右孩子小)对应的索引</li>
<li>如果说x比两个孩子节点的值都大就说明堆的结构是完整的，就退出siftDown操作</li>
<li>如果进行到这一步就说明堆的结构是不正确的，这时交换x与第2步找到的索引上的值</li>
<li>更新x的索引，新索引就是第二步找到的索引</li>
</ol>
</li>
</ol>
</li>
<li>堆还有很多种，比如d叉堆，索引堆，二项堆，斐波那契堆</li>
</ol>
<h1 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h1><p>慕课网的liuyubobobo老师的数据结构的课程<br><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">https://coding.imooc.com/class/207.html</a></p>
]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>个人github的一些常用的操作</title>
    <url>/2019/09/12/%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%B7%B1%E6%9D%A5%E8%AF%B4%E6%9C%89%E7%94%A8%E7%9A%84github%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="让一个文件夹与github上的一个项目产生联系"><a href="#让一个文件夹与github上的一个项目产生联系" class="headerlink" title="让一个文件夹与github上的一个项目产生联系"></a>让一个文件夹与github上的一个项目产生联系</h1><p>两种方法：</p>
<ol>
<li><p>第一种也是最方便的方法，就是通过github上的远程仓库的SSH Key或者Https的Web URl来在本地执行下面这个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用Https的Web URL</span><br><span class="line">$ git clone https://github.com/why0609why/gitstudy.git</span><br><span class="line"></span><br><span class="line"># 或者用SSH连接方式的SSH Key</span><br><span class="line">$ git clone git@github.com:why0609why/gitstudy.git</span><br></pre></td></tr></table></figure>

<p> 执行完之后就会发现文件夹中多了一个.git的文件夹，这就表明本地这个文件夹和github上的所选定的远程仓库连接上了</p>
</li>
<li><p>第二种就是先创建一个文件夹，然后在这个文件夹的目录下打开GitBash，在这个目录下执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先让这个文件夹init一下</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"># 这个表明给你这个项目添加一个远程连接，通过这个名字叫origin的连接你就可以连接到后面那个SSH Key或者Https的Web URl所对应的仓库</span><br><span class="line">$ git remote add origin https://github.com/why0609why/gitstudy.git</span><br><span class="line"></span><br><span class="line"># 同理的，这里连接也可以使用SSH连接方式的SSH Key</span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>
<br>

<h1 id="往远程仓库上传文件"><a href="#往远程仓库上传文件" class="headerlink" title="往远程仓库上传文件"></a>往远程仓库上传文件</h1><ol>
<li><p>上传文件其实就是push操作，但是push之前得先把文件加载到缓存区中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 加载当前工作区的全部文件到缓存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 加载指定文件到缓存区</span><br><span class="line">$ git 111.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>要传输的文件到了缓存区之后就需要把文件提交到本地仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交可以增加注释，用来说明此次commit的内容，方便以后查看</span><br><span class="line">$ git commit -m &apos;这是本次commit的操作的注释&apos;</span><br></pre></td></tr></table></figure>

<p> 注意一点，每次提交之后，每次提交的版本都会被记录下来，而且每个版本都会被赋予一个ID，通过不同的ID可以回到不同的版本(这个很牛皮)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 通过log查看所有的commit的版本，随之可以看到所有的提交的版本的ID号</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 通过指定某个版本的ID号来回到某个版本</span><br><span class="line">$ git checkout ID</span><br></pre></td></tr></table></figure>
</li>
<li><p>把文件commit到本地仓库之后就需要把文件push到远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在push的时候需要指定一个远程的仓库，也就是下面的origin，因为origin之前已经定义过了。</span><br><span class="line"># 如果项目当时是clone下来的话，origin默认就是clone下来的指令，origin也是可以修改值的</span><br><span class="line"># 而且在push的时候需要指定一个分支，一般是你在哪个工作区工作就提交到那个分支</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>经过上面3步文件就已经push到了github的远程仓库，在远程仓库的里面有图形化的显示了提交了哪些版本，以及这些提交的版本中的更新，而且还有提交的ID，这个ID和你本地的git log查询下的ID是一样的，而且github会根据你不同的分支来查看不同的分支的里面的提交的版本。</p>
</li>
</ol>
<br>
<br>

<h1 id="关于分支"><a href="#关于分支" class="headerlink" title="关于分支"></a>关于分支</h1><ol>
<li><p>分支这个概念是十分的神奇，比如说你现在已经有一个工作区，并且工作区里面已经有文件，但是现在需要根据当前这个工作区里面的文件再开发一个新的版本，那么算上你原来的版本你需要做的事情就是根据你当前的文件开发两个版本，一个是你按照你原来的需求继续的开发(在这里可以看成master分支)，另一个是按照新需求和当前的文件开发一个新的版本(在这里可以看做新分支，给他取名为newbranch)，那么在master分支上开发并不困难，在newbranch上的分支需要原来的文件这就是一个问题，所以为了解决这个问题就有了Git中的分支概念，分支所进行的操作就是在你当前所有的文件中在开一条支路(也就是上面提到的newbranch分支)，这个支路拥有当前开辟新支路是工作区所有的所有文件。</p>
</li>
<li><p>如何开辟一个分支、查询所有分支以及切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开辟一个新的分支</span><br><span class="line">$ git branch [这里填写你的新分支的名字]</span><br><span class="line">$ git branch newbranch</span><br><span class="line"></span><br><span class="line"># 查询这个remote连接下的所有的分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 切换分支</span><br><span class="line">$ git checkout [这里填你要切换的分支的名字]</span><br><span class="line">$ git checkout newbranch</span><br></pre></td></tr></table></figure>
</li>
<li><p>有了分枝以后，切换到指定分枝之后工作区里面的文件就会自动更新为你这个分支所对应的文件们</p>
</li>
<li><p>注意切换了分支之后，push到远程仓库的时候记得提交到对应的分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交到origin这个remote下的newbranch文件</span><br><span class="line">$ git push -u origin newbranch</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="关于bug"><a href="#关于bug" class="headerlink" title="关于bug"></a>关于bug</h1><h2 id="GitHub报错master-gt-master（fetch-first-的解决方法"><a href="#GitHub报错master-gt-master（fetch-first-的解决方法" class="headerlink" title="GitHub报错master-&gt;master（fetch first)的解决方法"></a>GitHub报错master-&gt;master（fetch first)的解决方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull --rebase https://github.com/why0609why/gitstudy.git</span><br></pre></td></tr></table></figure>

<p>pull完了之后就可以正常的add、commit、push了</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2019/08/11/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol>
<li>可以优化</li>
<li>n个数只需要排序n-1次</li>
<li>每次排序的时候只需要排序从头到未被排序的第二个数就行，因为每次比较的都是两个数</li>
<li>每次比较的当前元素和下一个元素</li>
</ol>
<h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Test().bubbleSort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">//带优化的冒泡排序</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = a[j];</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = t;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树的实现</title>
    <url>/2019/08/02/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一些点"><a href="#一些点" class="headerlink" title="一些点"></a>一些点</h1><h2 id="每个节点的内容"><a href="#每个节点的内容" class="headerlink" title="每个节点的内容"></a>每个节点的内容</h2><ol>
<li><p>每个节点肯定得有一个存放字符的值</p>
</li>
<li><p>而且得有一个存放当前节点和其子节点的连接关系，要么是用map，要么是用数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map实现关系的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    <span class="keyword">public</span> TreeMap&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">        next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组实现关系的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    <span class="keyword">public</span> TreeNode[] next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">        next = <span class="keyword">new</span> TreeNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而且还有一个isWord用来表明从根节点到当前节点，是否是一个字符串</p>
</li>
<li><p>用map的好处就是能存储多种多样的字符串，只要能通过Character类型表达的，都能放入map中</p>
</li>
</ol>
<h2 id="往字典树中增加字符串"><a href="#往字典树中增加字符串" class="headerlink" title="往字典树中增加字符串"></a>往字典树中增加字符串</h2><ol>
<li>因为字典树的特性，往树中增加字符串必然要从根节点开始往下逐个插入字符</li>
<li>对于每个节点插入的操作：先看当前的节点的子树中是否存在要插入的字符，如果存在指针就指向节点的子节点，并且获得下一个要插入的字符，在进行同样的判断；如果说当前节点中不存在要插入的字符，就新造一个子节点，并且把该子节点与当前节点相连，同样的再更新指针的位置和要插入的字符，直到要插入的字符串都插入到了字典树中。</li>
<li>在字符串插入完毕之后，指针指向的应该是字符串的最后一个位置，这时可以把该节点的isWord设置为true表示从根节点到当前节点这一个字符串表示一个字符串。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向Trie中添加一个新的单词word</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为是从字典树根开始，所以先拿到根节点</span></span><br><span class="line">    Node cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">//因为是往字典树里面增加一个字符串，当发现没有的字符的时候就会往树里面新增字符节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//节点往下深入以继续构建字典树</span></span><br><span class="line">        cur = cur.next.get(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这颗字典树只统计不重复的字符串，可见重复的字符串是不会被计入到size中的</span></span><br><span class="line">    <span class="keyword">if</span> (!cur.isWord)&#123;</span><br><span class="line">        cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="查询字典树中是否存在某个字符串"><a href="#查询字典树中是否存在某个字符串" class="headerlink" title="查询字典树中是否存在某个字符串"></a>查询字典树中是否存在某个字符串</h2><ol>
<li>同样因为字典树的特性，查询字典树中是否存在某个字符串也是得从根节点开始</li>
<li>对于每个节点的查询操作：看当前节点的子节点中是否存在要查询的字符，如果不存在就直接表明该字典树中不存在该字符串，如果存在当前字符的话，就继续从子节点的子节点继续查询是否存在字符串的下一个字符</li>
<li>在字符串的全部字符都查询过后，如果发现都存在，还得看指针当前指向的节点中的isWord是否为true。如果是true就表明字典树中存在该字符串，如果不存在就说明当前查询的字符串是字典树中某个字符串的前缀 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询单词word是否在Trie中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为是从字典树根开始，所以先拿到根节点</span></span><br><span class="line">    Node cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历字符串的每一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">//当查询的时候发现字符串中没有某个字符时，就表示当前的字典树中没有这个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//节点往下深入以继续查询</span></span><br><span class="line">        cur = cur.next.get(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里已经是遍历到这个word在字典树中的最下面的那一层了，如果当前到节点是一个完整的</span></span><br><span class="line">    <span class="comment">//字符串而不是某个字符串的前缀时，就表明这个字符串存在于这个字典树中</span></span><br><span class="line">    <span class="keyword">return</span> cur.isWord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="简单的通配符-简单的正则表达式"><a href="#简单的通配符-简单的正则表达式" class="headerlink" title="简单的通配符 . (简单的正则表达式)"></a>简单的通配符 . (简单的正则表达式)</h2><ol>
<li>如果说.代表任意一个字符都能匹配的话，那么当某个节点遇到 “.” 这个字符的时候，就需要遍历当前节点的所有子节点，这里用递归就很方便了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Node node, String word, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前遍历到的深度和字符串的长度相同的话就表明找到字符串了</span></span><br><span class="line">        <span class="keyword">if</span>(index == word.length())</span><br><span class="line">            <span class="keyword">return</span> node.isWord;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前字符不是.的话，那么遍历的方式和原来的普通查找是没区别的</span></span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> match(node.next.get(c), word, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则如果是.就得遍历该节点的所有子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//            for(char nextChar: node.next.keySet())</span></span><br><span class="line"><span class="comment">//                if(match(node.next.get(nextChar), word, index + 1))</span></span><br><span class="line"><span class="comment">//                    return true;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到所有的子节点</span></span><br><span class="line">            Set&lt;Character&gt; characters = node.next.keySet();</span><br><span class="line">            Iterator&lt;Character&gt; it = characters.iterator();</span><br><span class="line">            <span class="comment">//逐个遍历所有的子节点</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                Character nextChar = it.next();</span><br><span class="line">                <span class="keyword">if</span>(match(node.next.get(nextChar), word, index + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="字符串的最简单的实现"><a href="#字符串的最简单的实现" class="headerlink" title="字符串的最简单的实现"></a>字符串的最简单的实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//isWord表示从根节点到前节点是否构成一个字符串</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">        <span class="comment">//代替了长度为26的数组，用map会更方便</span></span><br><span class="line">        <span class="keyword">public</span> TreeMap&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isWord)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isWord = isWord;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得Trie中存储的单词数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向Trie中添加一个新的单词word</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为是从字典树根开始，所以先拿到根节点</span></span><br><span class="line">        Node cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">//因为是往字典树里面增加一个字符串，当发现没有的字符的时候就会往树里面新增字符节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//节点往下深入以继续构建字典树</span></span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这颗字典树只统计不重复的字符串，可见重复的字符串是不会被计入到size中的</span></span><br><span class="line">        <span class="keyword">if</span> (!cur.isWord)&#123;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询单词word是否在Trie中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为是从字典树根开始，所以先拿到根节点</span></span><br><span class="line">        Node cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">//当查询的时候发现字符串中没有某个字符时，就表示当前的字典树中没有这个字符串</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//节点往下深入以继续查询</span></span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到这里已经是遍历到这个word在字典树中的最下面的那一层了，如果当前到节点是一个完整的</span></span><br><span class="line">        <span class="comment">//字符串而不是某个字符串的前缀时，就表明这个字符串存在于这个字典树中</span></span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询是否在Trie中有单词以prefix为前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrefix</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        Node cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.get(c) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/01/31/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] n1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] n2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>,-<span class="number">3213123</span>,<span class="number">3242342</span>,<span class="number">4645</span>,<span class="number">323523</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        solution.sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左半段</span></span><br><span class="line">            sort(nums, l, mid);</span><br><span class="line">            <span class="comment">//右半段</span></span><br><span class="line">            sort(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merger(nums, l, r, mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) &#123;</span><br><span class="line">            n1[t++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        n1[t] = Integer.MAX_VALUE;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            n2[t++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        n2[t] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n1[i] &lt;= n2[j]) &#123;</span><br><span class="line">                nums[k] = n1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = n2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2019/08/11/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol>
<li>快排主要是基准数，每次选定一个基准数，确保基准数左边的值都比基准数小，右边的值都比基准数大，然后再把基准数放到基准数应该放的位置，然后重新确立基准数，所有的数都要当一次基准数。</li>
</ol>
<h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            q = partition(nums, l, r);</span><br><span class="line">            quickSort(nums, l, q - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, q + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, i, j, t;</span><br><span class="line">        x = nums[r];</span><br><span class="line">        i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从j区间开始选择数</span></span><br><span class="line">        <span class="keyword">for</span> (j = l; j &lt; r; j++) &#123;</span><br><span class="line">            <span class="comment">//如果发现这是i区间的数</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; x) &#123;</span><br><span class="line">                <span class="comment">//就把数放到i区间里面</span></span><br><span class="line">                i++;</span><br><span class="line">                t = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基准数归位</span></span><br><span class="line">        t = nums[i + <span class="number">1</span>];</span><br><span class="line">        nums[i + <span class="number">1</span>] = nums[r];</span><br><span class="line">        nums[r] = t;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>,-<span class="number">3213123</span>,<span class="number">3242342</span>,<span class="number">4645</span>,<span class="number">323523</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        solution.quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2020/02/05/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Test().insertSort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = a[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//每次把比a[i]大的数都后移(从后往前看)</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt;= v) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + <span class="number">1</span>] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>nk把二叉树打印成多行</title>
    <url>/2020/02/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>bfs二叉树。</li>
</ol>
<br>
<br>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = queue.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                TreeNode node = queue.remove();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>拉火车判断输赢</title>
    <url>/2019/08/11/%E6%8B%89%E7%81%AB%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一个人手上的牌</span></span><br><span class="line">        Queue&lt;Integer&gt; p1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//第二个人手上的牌</span></span><br><span class="line">        Queue&lt;Integer&gt; p2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//桌面上的牌</span></span><br><span class="line">        Stack&lt;Integer&gt; card = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//牌数为1到9</span></span><br><span class="line">        <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入第一个人的牌"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            t = sc.nextInt();</span><br><span class="line">            p1.offer(t);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"请输入第二个人的牌"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            t = sc.nextInt();</span><br><span class="line">            p2.offer(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!p1.isEmpty() &amp;&amp; !p2.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//p1先出牌</span></span><br><span class="line">            t = p1.poll();</span><br><span class="line">            <span class="keyword">if</span> (book[t]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//p1出的牌桌子上都没有的时候</span></span><br><span class="line">                card.push(t);</span><br><span class="line">                book[t] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则此轮可以赢牌</span></span><br><span class="line">                p1.offer(t);</span><br><span class="line">                <span class="comment">//把中间的牌的标记都清除</span></span><br><span class="line">                <span class="keyword">while</span> (!card.empty() &amp;&amp; card.peek()!=t)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = card.pop();</span><br><span class="line">                    p1.offer(temp);</span><br><span class="line">                    book[temp] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后放t</span></span><br><span class="line">                p1.offer(t);</span><br><span class="line">                card.pop();</span><br><span class="line">                book[t] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p1出完牌若p1没牌了，p1直接输</span></span><br><span class="line">            <span class="keyword">if</span> (p1.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//p2同p1</span></span><br><span class="line">            t = p2.poll();</span><br><span class="line">            <span class="keyword">if</span> (book[t]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//p2没有赢牌，就放在牌堆里</span></span><br><span class="line">                card.push(t);</span><br><span class="line">                book[t] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p2.offer(t);</span><br><span class="line">                <span class="keyword">while</span> (!card.empty() &amp;&amp; card.peek()!=t)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = card.pop();</span><br><span class="line">                    p2.offer(temp);</span><br><span class="line">                    book[temp] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p2.offer(t);</span><br><span class="line">                card.pop();</span><br><span class="line">                book[t] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p2.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"p1赢"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"p2赢"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础知识1</title>
    <url>/2019/09/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%981/</url>
    <content><![CDATA[<h1 id="数据库的事务的基础点"><a href="#数据库的事务的基础点" class="headerlink" title="数据库的事务的基础点"></a>数据库的事务的基础点</h1><h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><ol>
<li>事务就是针对一组sql的操作，如果一组sql中的一条sql执行不成功，那么所有的sql都不会执行成功。（存储点之后说）</li>
<li>而且事务要保持4个特性<ol>
<li>原子性：也就是说一个事务里面的sql语句是不能再分的，不能说执行一个事务的部分sql，事务要么全部执行，要么全不执行。</li>
<li>一致性：一致性是指数据库从一个状态到另一个状态。也就是说数据库在执行完事务之后，要和原来的数据库状态是一样的，要有一致性。</li>
<li>隔离性：当多个用户同时对数据库进行操作的时候，数据库会开启很多个事务，那么这些事务之间是不能有相互影响的，要有隔离的感觉。</li>
<li>持久性：事务一旦提交，事务对数据库的影响就应该是在数据库健康的时候一直存在的，也就是说提交以后这个事务就不能再撤销，并且事务就相当于完全的完成了。</li>
</ol>
</li>
</ol>
<h2 id="事务的提交"><a href="#事务的提交" class="headerlink" title="事务的提交"></a>事务的提交</h2><ol>
<li><p>开启一个事务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交一个事务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="事务的回滚"><a href="#事务的回滚" class="headerlink" title="事务的回滚"></a>事务的回滚</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure>

<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>因为数据库是多线程并发访问的，所以当有多个操作的时候，所以很容易出现多个线程同时开启事务的情况，在不同的隔离级别下，会出现不同的情况。比如脏读、重复度、幻读的情况，所以为了解决这些问题，有了隔离级别。在不同等级的隔离界别下，可以避免并发的访问问题。</p>
<ol>
<li>READ UNCOMMITTED（读未提交） ：<ol>
<li>概念：是事务隔离界别的最低的等级，由于这种情况下会出现脏读，也就是可以读取到别人没有提交的数据，而且避免不了任何一种情况，一般不使用。</li>
<li>脏读：读到了别人没有提交的数据。</li>
</ol>
</li>
<li>READ COMMITTED（读提交）： <ol>
<li>概念：这种级别只能读取到别人提交了的数据，可以避免脏读，但是不能避免重复读和幻读。</li>
<li>重复读：就是在事务中重复读到了别人的数据，而且这两次的数据不一样，是因为在这两次查询的过程中别人的事务进行了更新。</li>
<li>幻读：就是在十五中的两次查询的数据条数不一样，因为在这两次的查询过程中别的事务进行了添加操作。</li>
</ol>
</li>
<li>REPEATABLE READ（可重复读）<ol>
<li>概念：是MySQL的默认的事务隔离级别，可以避免脏读、重复读、幻读</li>
</ol>
</li>
<li>SERIALIZABLE（可串行化）<ol>
<li>概念：是最高的事务隔离级别。它会强制对事务进行排序，使之不会发生并发问题。实际上就是对每个事务进行上锁，可能会导致大量的超时现象和锁竞争。实际中也是很少使用。</li>
</ol>
</li>
</ol>
<br>
<br>

<h1 id="一些并发异常的演示"><a href="#一些并发异常的演示" class="headerlink" title="一些并发异常的演示"></a>一些并发异常的演示</h1><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><ol>
<li><p>比如说有下面这个表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `name` varchar(255) NOT NULL,</span><br><span class="line">  `money` int(11) NOT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert into test values(&apos;a&apos;,1000)</span><br><span class="line">insert into test values(&apos;b&apos;,1000)</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先开启一个隔离级别是读未提交的事务，因为这个级别下的事务是不能避免脏读的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启一个隔离级别是read uncommitted的事务B</span><br><span class="line"># 在事务B中执行</span><br><span class="line">set session transaction isolation level read uncommitted</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在另一个事务中进行更新操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 其中字段是money、表名是test、a和b分别是两个人</span><br><span class="line"># 在事务A中执行</span><br><span class="line">start transaction</span><br><span class="line"></span><br><span class="line">update test set money = money-100 where name=&apos;a&apos;;  </span><br><span class="line">update test set money = money+100 where name=&apos;b&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这时候在事务B中执行查询操作，就可以发现money这个字段的值缺失改变了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务B中执行</span><br><span class="line">select * from test;     </span><br><span class="line"></span><br><span class="line"># a 900</span><br><span class="line"># b 1100</span><br></pre></td></tr></table></figure>
</li>
<li><p>A事务在B事务执行完查询操作后，就可以回滚事务了，回滚之后，money字段的值和执行事务之前一样没有发生变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务A中执行</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>到这里脏读就算演示完成了，说白了脏读就是读取到别人没有提交的信息。</p>
<p>同样的，如果刚开始把事务B的隔离级别设置为read committed及其以上就不会出现了脏读的问题了。</p>
<h2 id="重复读"><a href="#重复读" class="headerlink" title="重复读"></a>重复读</h2><ol>
<li><p>还是上面那个表</p>
</li>
<li><p>在事务B中开启一个隔离级别为READ COMMITTED（读提交的事务），创建完之后查询当时的money字段的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务B中执行</span><br><span class="line">set session transaction isolation level read committed</span><br><span class="line"></span><br><span class="line">select * from test</span><br><span class="line">// a 1000</span><br><span class="line">// b 1000</span><br></pre></td></tr></table></figure>
</li>
<li><p>这时开启一个事务A，并且在事务A中进行money的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务A中执行</span><br><span class="line">start transaction</span><br><span class="line"></span><br><span class="line">update test set money = money-100 where name=&apos;a&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这时再到事务B中查询money</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务B中执行</span><br><span class="line">select * from test</span><br><span class="line">// a 900</span><br><span class="line">// b 1000</span><br></pre></td></tr></table></figure>
</li>
<li><p>由此可见在事务B中的两次查询，居然出现了不同的结果，这样的结果虽然没有错，但是这样的不同的结果在事务B中是不符合要求的，比如事务B是做报表的时候。</p>
</li>
<li><p>所以避免这种重复读的时候只需要把隔离级别设置为repeatable read及其以上就行了</p>
</li>
</ol>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><ol>
<li><p>还是那个表</p>
</li>
<li><p>开启一个隔离级别是read committed的事务B，然后在B中进行查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务B中执行</span><br><span class="line">set session transaction isolation level read committed</span><br><span class="line"></span><br><span class="line">select * from test</span><br><span class="line">// a 1000</span><br><span class="line">// b 1000</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启一个事务A，在事务A中插入一条记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务A中执行</span><br><span class="line">start transaction</span><br><span class="line"></span><br><span class="line">insert into test values(&apos;c&apos;,1000)</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时再在事务B中查询一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务B中执行</span><br><span class="line">select * from test</span><br><span class="line">// a 1000</span><br><span class="line">// b 1000</span><br><span class="line">// c 1000</span><br></pre></td></tr></table></figure>
</li>
<li><p>从中可以看出事务B在两次的查询中，查询的记录数不一样，同重复读一样，每次查询的结果虽然显示的不错，但是在事务B的需求不同下，这样的结果是不符合要求的。而且幻读和重复读很像，只不过幻读是在两次查询的过程中插入了新数据，而重复读是在两次查询的中间进行了数据的修改。而且把隔离级别设置为设置为repeatable read及其以上就行了。</p>
</li>
</ol>
<h2 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h2><ol>
<li><p>还是上面的表</p>
</li>
<li><p>开启一个隔离级别是serializable的事务B，并且再里面进行一个插入操作，但是不提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在事务B中执行</span><br><span class="line">set session transaction isolation level serializable</span><br><span class="line"></span><br><span class="line">insert into test values(&apos;c&apos;,1000)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后开启一个事务A，然后在A中进行一个插入操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction</span><br><span class="line"></span><br><span class="line">insert into test values(&apos;d&apos;,1000)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就会发现事务A是提交不了的，因为事务B使用的是可串行化，这个隔离界别会给所有的事务加上一个锁，也就是事务都是一个一个进行的，这样就不会出现并发问题。所以在先开始的事务B没有结束的时候事务A是不能提交的。将隔离级别改成其他的隔离级别就能避免这个问题了。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，可以看出最好用的隔离级别是repeatable read，因为第一个级别会有脏读，第二个级别会有重复读和幻读，第四个级别会有串行化。而且MySql的默认级别就是第三种，而大部分得其他数据库（比如Oracle）都是第二种。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的实现</title>
    <url>/2019/08/19/%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="数组数据结构的实现"><a href="#数组数据结构的实现" class="headerlink" title="数组数据结构的实现"></a>数组数据结构的实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="comment">//size为当前数组中存在的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，传入数组的容量capacity构造Array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        data = (E[])<span class="keyword">new</span> Object[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造函数，默认数组的容量capacity=10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">        data = (E[])<span class="keyword">new</span> Object[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i ++)</span><br><span class="line">            data[i] = arr[i];</span><br><span class="line">        size = arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组的容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数组是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在index索引的位置插入一个新元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Add failed. Require index &gt;= 0 and index &lt;= size."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在添加元素的时候进行扩容</span></span><br><span class="line">        <span class="keyword">if</span>(size == data.length)</span><br><span class="line">            resize(<span class="number">2</span> * data.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index ; i --)</span><br><span class="line">            data[i + <span class="number">1</span>] = data[i];</span><br><span class="line"></span><br><span class="line">        data[index] = e;</span><br><span class="line"></span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向所有元素后添加一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        add(size, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有元素前添加一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        add(<span class="number">0</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取index索引位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Get failed. Index is illegal."</span>);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改index索引位置的元素为e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Set failed. Index is illegal."</span>);</span><br><span class="line">        data[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找数组中是否有元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i].equals(e))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找数组中元素e所在的索引，如果不存在元素e，则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i].equals(e))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除index位置的元素, 返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Remove failed. Index is illegal."</span>);</span><br><span class="line"></span><br><span class="line">        E ret = data[index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span> ; i &lt; size ; i ++)</span><br><span class="line">            data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">        size --;</span><br><span class="line">        data[size] = <span class="keyword">null</span>; <span class="comment">// loitering objects != memory leak</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(size == data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            resize(data.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除第一个元素, 返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除最后一个元素, 返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组中删除元素e(并非所有e)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = find(e);</span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>)</span><br><span class="line">            remove(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= size || j &lt; <span class="number">0</span> || j &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal."</span>);</span><br><span class="line"></span><br><span class="line">        E t = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(String.format(<span class="string">"Array: size = %d , capacity = %d\n"</span>, size, data.length));</span><br><span class="line">        res.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++)&#123;</span><br><span class="line">            res.append(data[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != size - <span class="number">1</span>)</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组空间的容量变成newCapacity大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        E[] newData = (E[])<span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++)</span><br><span class="line">            newData[i] = data[i];</span><br><span class="line">        data = newData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h1><p>慕课网的liuyubobobo老师的数据结构的课程<br><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">https://coding.imooc.com/class/207.html</a></p>
]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/2019/08/11/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol>
<li>桶排序使用的数据范围有要求，数据范围不能有负数并且数据范围必须在数组长度范围之内</li>
</ol>
<h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里假设数组长度是100</span></span><br><span class="line">        <span class="keyword">int</span> book[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入10个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = sc.nextInt();</span><br><span class="line">            book[t]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从最小的开始遍历，达到排序效果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (book[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                book[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>用堆实现优先队列</title>
    <url>/2019/08/20/%E7%94%A8%E5%A0%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="二叉最大堆的代码"><a href="#二叉最大堆的代码" class="headerlink" title="二叉最大堆的代码"></a>二叉最大堆的代码</h1><p><a href="https://why0609why.github.io/2019/08/20/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://why0609why.github.io/2019/08/20/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></p>
<h1 id="二叉堆实现的优先队列"><a href="#二叉堆实现的优先队列" class="headerlink" title="二叉堆实现的优先队列"></a>二叉堆实现的优先队列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MaxHeap&lt;E&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> MaxHeap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看队首的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.findMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        maxHeap.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.extractMax();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="点"><a href="#点" class="headerlink" title="点"></a>点</h1><ol>
<li><p>知道堆怎么实现后，再用堆去实现一个优先队列就很容易了</p>
<ol>
<li>优先队列的add操作其实就是堆的增添一个元素的操作</li>
<li>优先队列的remove操作其实就是堆的取出最大元素的操作</li>
<li>还有诸多操作等等</li>
</ol>
</li>
<li><p>注意此时实现的优先队列是有缺陷的，是没有办法使用比较器排序的，只能在类中实现compare方法来定义优先级，这就造成了存储基本类型时不能自定义优先级的不方便之处，也就是说存储基本类型时，是按照默认顺序来的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是Integer类的比较方法，默认从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里就有必要提及java本身的PriporityQueue，支持了自定义比较器，也就是说优先队列不管存储自定义类型还是基本类型的，都可以通过自定义比较器来实现自定义优先级，从而更方便的使用优先队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//大于的就有优先级</span></span><br><span class="line">            <span class="keyword">if</span> (o1 &gt; o2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//小于的就没有优先</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (o1 &lt; <span class="number">02</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">    priorityQueue.add(<span class="number">3</span>);</span><br><span class="line">    priorityQueue.add(-<span class="number">2</span>);</span><br><span class="line">    priorityQueue.add(-<span class="number">5</span>);</span><br><span class="line">    priorityQueue.add(<span class="number">5</span>);</span><br><span class="line">    priorityQueue.add(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;</span><br><span class="line">        System.out.println(priorityQueue.remove());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里提一下java内置的优先队列的可以用比较器的方法来实现排序的原理：本质上Comparator比较器是一个接口，这个接口里面有一个方法是compare方法(接口里面自然是空方法)，然后在优先队列的构造方法里面需要一个接口的对象(肯定是匿名内部类)，在创建优先队列的对象的时候，传递一个重写了compare方法的Comparator接口的匿名内部类。在优先队列内部使用compare方法时只需要通过之前传过来的接口的对象就可以使用compare方法了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>等式枚举</title>
    <url>/2019/08/12/%E7%AD%89%E5%BC%8F%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="简易等式"><a href="#简易等式" class="headerlink" title="简易等式"></a>简易等式</h1><h2 id="试找出一个数字让这个等式成立"><a href="#试找出一个数字让这个等式成立" class="headerlink" title="试找出一个数字让这个等式成立"></a>试找出一个数字让这个等式成立</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">□3 * 6528 = 3□ * 8256</span><br></pre></td></tr></table></figure>

<h2 id="枚举代码"><a href="#枚举代码" class="headerlink" title="枚举代码"></a>枚举代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((i*<span class="number">10</span>+<span class="number">3</span>)*<span class="number">6528</span> == (<span class="number">30</span>+i)*<span class="number">8256</span>)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="难度升级等式"><a href="#难度升级等式" class="headerlink" title="难度升级等式"></a>难度升级等式</h1><h2 id="实现这个等式"><a href="#实现这个等式" class="headerlink" title="实现这个等式"></a>实现这个等式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">□□□ + □□□ = □□□</span><br><span class="line"></span><br><span class="line">并且1~9每个数字只能用一次</span><br></pre></td></tr></table></figure>

<h2 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把每一位的每个数字都试一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= <span class="number">9</span>; b++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">9</span>; c++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= <span class="number">9</span>; d++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">1</span>; e &lt;= <span class="number">9</span>; e++) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">1</span>; f &lt;= <span class="number">9</span>; f++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt;= <span class="number">9</span>; g++) &#123;</span><br><span class="line">                                    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h &lt;= <span class="number">9</span>; h++) &#123;</span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                                            <span class="comment">//确保每个数字都不相互一样</span></span><br><span class="line">                                            <span class="keyword">if</span> (a!=b &amp;&amp; a!=c &amp;&amp; a!=d &amp;&amp; a!=e &amp;&amp; a!=f &amp;&amp; a!=g &amp;&amp; a!=h &amp;&amp; a!=i</span><br><span class="line">                                                    &amp;&amp; b!=c &amp;&amp; b!=d &amp;&amp; b!=e &amp;&amp; b!=f &amp;&amp; b!=g &amp;&amp; b!=h &amp;&amp; b!=i</span><br><span class="line">                                                        &amp;&amp; c!=d  &amp;&amp; c!=e  &amp;&amp; c!=f  &amp;&amp; c!=g  &amp;&amp; c!=h  &amp;&amp; c!=i</span><br><span class="line">                                                            &amp;&amp; d!=e  &amp;&amp; d!=f  &amp;&amp; d!=g  &amp;&amp; d!=h  &amp;&amp; d!=i</span><br><span class="line">                                                                &amp;&amp; e!=f  &amp;&amp; e!=g  &amp;&amp; e!=h  &amp;&amp; e!=i</span><br><span class="line">                                                                    &amp;&amp; f!=g  &amp;&amp; f!=h  &amp;&amp; f!=i</span><br><span class="line">                                                                        &amp;&amp; g!=h &amp;&amp; g!=i</span><br><span class="line">                                                                            &amp;&amp; h!=i</span><br><span class="line">                                                    &amp;&amp; (a*<span class="number">100</span>+b*<span class="number">10</span>+c + d*<span class="number">100</span>+e*<span class="number">10</span>+f == g*<span class="number">100</span>+h*<span class="number">10</span>+i))&#123;</span><br><span class="line">                                                <span class="keyword">int</span> t1 = a*<span class="number">100</span>+b*<span class="number">10</span>+c;</span><br><span class="line">                                                <span class="keyword">int</span> t2 = d*<span class="number">100</span>+e*<span class="number">10</span>+f;</span><br><span class="line">                                                <span class="keyword">int</span> t3 = g*<span class="number">100</span>+h*<span class="number">10</span>+i;</span><br><span class="line">                                                System.out.println(t1+<span class="string">" "</span>+t2+<span class="string">" "</span>+t3);</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组优化字母暴力枚举"><a href="#数组优化字母暴力枚举" class="headerlink" title="数组优化字母暴力枚举"></a>数组优化字母暴力枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//book数组中对应索引上就是数字出现的次数，当book数组和为9的时候代表都出现</span></span><br><span class="line">    <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//用数组a来代替a,b,c,d...i这些字母</span></span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (a[<span class="number">1</span>] = <span class="number">1</span>; a[<span class="number">1</span>] &lt;= <span class="number">9</span>; a[<span class="number">1</span>]++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (a[<span class="number">2</span>] = <span class="number">1</span>; a[<span class="number">2</span>] &lt;= <span class="number">9</span>; a[<span class="number">2</span>]++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (a[<span class="number">3</span>] = <span class="number">1</span>; a[<span class="number">3</span>] &lt;= <span class="number">9</span>; a[<span class="number">3</span>]++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (a[<span class="number">4</span>] = <span class="number">1</span>; a[<span class="number">4</span>] &lt;= <span class="number">9</span>; a[<span class="number">4</span>]++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (a[<span class="number">5</span>] = <span class="number">1</span>; a[<span class="number">5</span>] &lt;= <span class="number">9</span>; a[<span class="number">5</span>]++)&#123;</span><br><span class="line">                        <span class="keyword">for</span> (a[<span class="number">6</span>] = <span class="number">1</span>; a[<span class="number">6</span>] &lt;= <span class="number">9</span>; a[<span class="number">6</span>]++)&#123;</span><br><span class="line">                            <span class="keyword">for</span> (a[<span class="number">7</span>] = <span class="number">1</span>; a[<span class="number">7</span>] &lt;= <span class="number">9</span>; a[<span class="number">7</span>]++)&#123;</span><br><span class="line">                                <span class="keyword">for</span> (a[<span class="number">8</span>] = <span class="number">1</span>; a[<span class="number">8</span>] &lt;= <span class="number">9</span>; a[<span class="number">8</span>]++)&#123;</span><br><span class="line">                                    <span class="keyword">for</span> (a[<span class="number">9</span>] = <span class="number">1</span>; a[<span class="number">9</span>] &lt;= <span class="number">9</span>; a[<span class="number">9</span>]++)&#123;</span><br><span class="line">                                        </span><br><span class="line">                                        <span class="comment">//每次得到一种结果的时候为了确保不受之前结果影响先都把book数组清零</span></span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; i++)&#123;</span><br><span class="line">                                            book[i] = <span class="number">0</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">//book[i]表示a[i]代表的值是否出现，book[i]的值为1表示出现，为表示没有出现</span></span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; i++)&#123;</span><br><span class="line">                                            book[a[i]] = <span class="number">1</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">//统计book数组的总和，如果值为9表示每个数字都出现过</span></span><br><span class="line">                                        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">int</span> i : book) &#123;</span><br><span class="line">                                            sum+=i;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> (sum==<span class="number">9</span> &amp;&amp; a[<span class="number">1</span>]*<span class="number">100</span>+a[<span class="number">2</span>]*<span class="number">10</span>+a[<span class="number">3</span>]+a[<span class="number">4</span>]*<span class="number">100</span>+a[<span class="number">5</span>]*<span class="number">10</span>+a[<span class="number">6</span>]==a[<span class="number">7</span>]*<span class="number">100</span>+a[<span class="number">8</span>]*<span class="number">10</span>+a[<span class="number">9</span>])&#123;</span><br><span class="line">                                            <span class="keyword">int</span> t1 = a[<span class="number">1</span>]*<span class="number">100</span>+a[<span class="number">2</span>]*<span class="number">10</span>+a[<span class="number">3</span>];</span><br><span class="line">                                            <span class="keyword">int</span> t2 = a[<span class="number">4</span>]*<span class="number">100</span>+a[<span class="number">5</span>]*<span class="number">10</span>+a[<span class="number">6</span>];</span><br><span class="line">                                            <span class="keyword">int</span> t3 = a[<span class="number">7</span>]*<span class="number">100</span>+a[<span class="number">8</span>]*<span class="number">10</span>+a[<span class="number">9</span>];</span><br><span class="line">                                            System.out.println(t1+<span class="string">" "</span>+t2+<span class="string">" "</span>+t3);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用递归来做"><a href="#用递归来做" class="headerlink" title="用递归来做"></a>用递归来做</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代替字母来存放9个数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//用来标记索引对应的牌数的牌是否还在手上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相当于是优化了一点，当数字没有达到10个的时候不处理</span></span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//如果9个数都符合规则的话</span></span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>]*<span class="number">100</span>+a[<span class="number">2</span>]*<span class="number">10</span>+a[<span class="number">3</span>]+a[<span class="number">4</span>]*<span class="number">100</span>+a[<span class="number">5</span>]*<span class="number">10</span>+a[<span class="number">6</span>]==a[<span class="number">7</span>]*<span class="number">100</span>+a[<span class="number">8</span>]*<span class="number">10</span>+a[<span class="number">9</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> t1 = a[<span class="number">1</span>]*<span class="number">100</span>+a[<span class="number">2</span>]*<span class="number">10</span>+a[<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">int</span> t2 = a[<span class="number">4</span>]*<span class="number">100</span>+a[<span class="number">5</span>]*<span class="number">10</span>+a[<span class="number">6</span>];</span><br><span class="line">                <span class="keyword">int</span> t3 = a[<span class="number">7</span>]*<span class="number">100</span>+a[<span class="number">8</span>]*<span class="number">10</span>+a[<span class="number">9</span>];</span><br><span class="line">                System.out.println(t1+<span class="string">" "</span>+t2+<span class="string">" "</span>+t3);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常的放格子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//当牌在手上的时候</span></span><br><span class="line">            <span class="keyword">if</span> (book[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//把牌放入对应的格子中</span></span><br><span class="line">                a[step] = i;</span><br><span class="line">                <span class="comment">//放入牌之后，牌就不在手上了</span></span><br><span class="line">                book[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//在这个基础上进行放下一个</span></span><br><span class="line">                dfs(step+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//在当前的格子面前不放入i，考虑放i+1</span></span><br><span class="line">                book[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>考研必会的代码题</title>
    <url>/2020/09/05/%E8%80%83%E7%A0%94%E5%BF%85%E4%BC%9A%E7%9A%84%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
    <content><![CDATA[<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="二叉树的前序非递归遍历"><a href="#二叉树的前序非递归遍历" class="headerlink" title="二叉树的前序非递归遍历"></a>二叉树的前序非递归遍历</h2><p>先遍历节点，然后入栈，然后每次处理栈顶的右子树，对于右子树的处理也是遍历节点，然后左子树入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//先访问节点</span></span><br><span class="line">                System.out.println(cur.val);</span><br><span class="line">                <span class="comment">//放入当前节点入栈，为了后序的当前节点的右子树遍历</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                <span class="comment">//左孩子</span></span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//处理栈顶元素的右子树</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的中序非递归遍历"><a href="#二叉树的中序非递归遍历" class="headerlink" title="二叉树的中序非递归遍历"></a>二叉树的中序非递归遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//先入栈节点</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                <span class="comment">//入栈左子树</span></span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//处理栈顶(每次都是最左面的元素)</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                System.out.println(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的后序非递归遍历"><a href="#二叉树的后序非递归遍历" class="headerlink" title="二叉树的后序非递归遍历"></a>二叉树的后序非递归遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先构造一棵树</span></span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    root-&gt;right-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">    root-&gt;right-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    <span class="comment">//r记录上一个遍历过的节点</span></span><br><span class="line">    TreeNode *r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur || !s.empty()) &#123;</span><br><span class="line">        <span class="comment">//把所有的左子树都放到栈里</span></span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//cur为当前栈顶元素，即遍历过的树中最左面的节点</span></span><br><span class="line">            cur = s.top();</span><br><span class="line">            <span class="comment">//如果当前节点有右子树，并且右子树还没有走过</span></span><br><span class="line">            <span class="comment">//因为对于一个节点的后序遍历来说，他的上一个节点</span></span><br><span class="line">            <span class="comment">//是他的右子树，所以要遍历右子树时，只需要看他有没有走过</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right != r) &#123;</span><br><span class="line">                <span class="comment">//如果没有走过，自然继续放右子树</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="comment">//访问节点</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;cur-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//更新r</span></span><br><span class="line">                r = cur;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过二叉树后序非递归遍历找到一个节点的祖先"><a href="#通过二叉树后序非递归遍历找到一个节点的祖先" class="headerlink" title="通过二叉树后序非递归遍历找到一个节点的祖先"></a>通过二叉树后序非递归遍历找到一个节点的祖先</h2><p>这里需要知道，通过后序非递归遍历到指定节点x时，此时栈中的元素都是x的祖先。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    root-&gt;right-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">    root-&gt;right-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常栈</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">    <span class="comment">//用来存放节点x的祖先</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s2;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s3;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    TreeNode *r = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = s.top();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right != r) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="comment">//此时遍历到了指定的节点</span></span><br><span class="line">                <span class="comment">//记录s当前的栈内的内容</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;val == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="comment">//把s1的放到s3</span></span><br><span class="line">                    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">                        TreeNode *t = s.top();</span><br><span class="line">                        s.pop();</span><br><span class="line">                        s3.push(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//再把s3放到s1，顺便放到s2里面</span></span><br><span class="line">                    <span class="keyword">while</span> (!s3.empty()) &#123;</span><br><span class="line">                        TreeNode *t = s3.top();</span><br><span class="line">                        s3.pop();</span><br><span class="line">                        s.push(t);</span><br><span class="line">                        s2.push(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r = cur;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5那个节点的祖先是"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">        TreeNode *t = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过二叉树后序非递归遍历，找到给定的两个节点的最近公共祖先"><a href="#通过二叉树后序非递归遍历，找到给定的两个节点的最近公共祖先" class="headerlink" title="通过二叉树后序非递归遍历，找到给定的两个节点的最近公共祖先"></a>通过二叉树后序非递归遍历，找到给定的两个节点的最近公共祖先</h2><p>有了上面一个节点的祖先路径的基础，就可以利用后序非递归遍历，拿到两个节点的祖先路径(此时在两条路径存储在两个栈里)，自然可以得到最近的公共祖先，也可以得到公共祖先路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正常用来递归的栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s1;</span><br><span class="line">        <span class="comment">//用来保存p的祖先路径的栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s2;</span><br><span class="line">        <span class="comment">//用来保存q的祖先路径的栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s3;</span><br><span class="line">        <span class="comment">//保存祖先路径时需要的辅助栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; temp;</span><br><span class="line"></span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        TreeNode *r = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur || !s1.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">                s1.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = s1.top();</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right != r) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    s1.push(cur);</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s1.pop();</span><br><span class="line">                    <span class="comment">//如果遍历到了p，那么此时s1里面的节点都是p的祖先</span></span><br><span class="line">                    <span class="comment">//然后用s2保存</span></span><br><span class="line">                    <span class="keyword">if</span> (cur == p) &#123;</span><br><span class="line">                        <span class="comment">//把s1里面的值放到temp里面</span></span><br><span class="line">                        <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">                            TreeNode *t = s1.top();</span><br><span class="line">                            s1.pop();</span><br><span class="line">                            temp.push(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">                            TreeNode *t = temp.top();</span><br><span class="line">                            temp.pop();</span><br><span class="line">                            s1.push(t);</span><br><span class="line">                            s2.push(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//因为自己的祖先可能是自己，所以这里</span></span><br><span class="line">                        <span class="comment">//在保存路径的地方存储上自己</span></span><br><span class="line">                        s2.push(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cur == q) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">                            TreeNode *t = s1.top();</span><br><span class="line">                            s1.pop();</span><br><span class="line">                            temp.push(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (!temp.empty()) &#123;</span><br><span class="line">                            TreeNode *t = temp.top();</span><br><span class="line">                            temp.pop();</span><br><span class="line">                            s1.push(t);</span><br><span class="line">                            s3.push(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//同理，在q的祖先路径上存储自己</span></span><br><span class="line">                        s3.push(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    r = cur;  </span><br><span class="line">                    cur = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让两个栈的长度一样长</span></span><br><span class="line">        <span class="keyword">while</span> (s3.size() &gt; s2.size())</span><br><span class="line">            s3.pop();</span><br><span class="line">        <span class="keyword">while</span> (s3.size() &lt; s2.size())</span><br><span class="line">            s2.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//祖先路径从下往上找，找到第一个相同的节点就行</span></span><br><span class="line">        <span class="keyword">while</span> (!s3.empty() &amp;&amp; !s2.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s3.top() == s2.top())</span><br><span class="line">                <span class="keyword">return</span> s3.top();</span><br><span class="line">            s3.pop();</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="BST的非递归查找"><a href="#BST的非递归查找" class="headerlink" title="BST的非递归查找"></a>BST的非递归查找</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到就返回节点指针，找不到就返回null</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">BST_Search</span><span class="params">(TreeNode *cur, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cur &amp;&amp; num!=cur-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;cur-&gt;val)</span><br><span class="line">            cur = cur-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何判断一棵树是不是BST"><a href="#如何判断一棵树是不是BST" class="headerlink" title="如何判断一棵树是不是BST"></a>如何判断一棵树是不是BST</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//记录一个前驱</span></span><br><span class="line">    <span class="keyword">long</span> pre = <span class="number">-2147483648111</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟中序遍历</span></span><br><span class="line">        <span class="keyword">bool</span> l = dfs(cur-&gt;left);</span><br><span class="line">        <span class="comment">//如果pre比当前值大，自然就不是BST了</span></span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">false</span> || pre&gt;= cur-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新pre</span></span><br><span class="line">        pre = cur-&gt;val;</span><br><span class="line">        <span class="keyword">bool</span> r = dfs(cur-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> l &amp;&amp; r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="如何判断一棵树是不是AVL"><a href="#如何判断一棵树是不是AVL" class="headerlink" title="如何判断一棵树是不是AVL"></a>如何判断一棵树是不是AVL</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断这个树是不是AVL</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求左子树的高度</span></span><br><span class="line">        <span class="keyword">int</span> l = getHight(cur-&gt;left);</span><br><span class="line">        <span class="comment">//求右子树的高度</span></span><br><span class="line">        <span class="keyword">int</span> r = getHight(cur-&gt;right);</span><br><span class="line">        <span class="comment">//如果高度差大于1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树也要继续判断</span></span><br><span class="line">        <span class="keyword">return</span> dfs(cur-&gt;left)&amp;&amp;dfs(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求这个树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHight</span><span class="params">(TreeNode * cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = getHight(cur-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = getHight(cur-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> max(l,r)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="判断图中两个节点有没有通路"><a href="#判断图中两个节点有没有通路" class="headerlink" title="判断图中两个节点有没有通路"></a>判断图中两个节点有没有通路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] book = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(book, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//构造邻接表,集合数组，就很神奇</span></span><br><span class="line">        List&lt;Integer&gt;[] adj = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="comment">//给每个数组中的集合元素赋初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="comment">//把每个边的起始点和终点拿出来</span></span><br><span class="line">            <span class="keyword">int</span> l = graph[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r = graph[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//以邻接表的方式存储</span></span><br><span class="line">            adj[l].add(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从start开始bfs</span></span><br><span class="line">        queue.add(start);</span><br><span class="line">        book[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">//每次拿到新点</span></span><br><span class="line">                Integer remove = queue.remove();</span><br><span class="line">                <span class="comment">//如果是终点自然就说明有通路</span></span><br><span class="line">                <span class="keyword">if</span> (remove == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//remove点作为起点，从邻接表里面找remove点</span></span><br><span class="line">                <span class="comment">//相连的终点</span></span><br><span class="line">                <span class="keyword">for</span> (Integer j : adj[remove]) &#123;</span><br><span class="line">                    <span class="comment">//终点必须没有走过</span></span><br><span class="line">                    <span class="keyword">if</span> (book[j] != <span class="number">1</span>) &#123;</span><br><span class="line">                        book[j] = <span class="number">1</span>;</span><br><span class="line">                        queue.add(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>时间复杂度： O(n^2)<br>空间复杂度： O(1)<br>稳定性：    是一种稳定排序，因为一样大的元素是不会交换顺序的</p>
<p>要注意</p>
<ol>
<li>直接插入排序产生的有序子序列不一定是全局的有序序列（全局指的是针对最后结果序列来说的），如234561，最后会变成123456,那么此时23456这个子序列不是全局有序的</li>
<li>排2次直接插入排序，3个数字有序</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第二个元素开始，因为插排的第一个序列只有一个元素</span></span><br><span class="line">        <span class="comment">//自然是有序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//记录当前失序的值</span></span><br><span class="line">                <span class="keyword">int</span> t = nums[i];</span><br><span class="line">                <span class="comment">//从后往前把大于目标值的数都往后放</span></span><br><span class="line">                <span class="keyword">for</span> (k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span> &amp;&amp; t &lt; nums[k]; k--) &#123;</span><br><span class="line">                    nums[k + <span class="number">1</span>] = nums[k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把t放到应该放到的位置</span></span><br><span class="line">                nums[k + <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>时间复杂度： O(n^2)<br>空间复杂度： O(1)<br>稳定性： 是一种稳定排序<br>元素比较次数：O(n*logN)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//记录这个数字</span></span><br><span class="line">            <span class="keyword">int</span> t = nums[i];</span><br><span class="line">            <span class="comment">//从[0,i-1]去寻找nums[i]应该在的位置</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//二分出来以后,l所在的位置就是nums[i]最后应该插入的位置</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; t) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把[l,i-1]的所有的元素都向后移动一次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= l; j--) &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//l是nums[i]应该在的位置</span></span><br><span class="line">            nums[l] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>时间复杂度： O(n^2) ，最好可能是O(n^1.3)<br>空间复杂度： O(1)<br>稳定性： 不稳定，因为可能会把相同大小的元素值分到不同的组，分组进行直接插入排序可能导致原来相同元素的先后关系发生改变，所以不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//希尔排序  升序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = len / <span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>) &#123;  <span class="comment">//d增量，逐渐减半</span></span><br><span class="line">            <span class="comment">//和插入排序一样，插排是从第二个开始的，同理系尔的每一组都是从</span></span><br><span class="line">            <span class="comment">//第二个元素开始的，从每一组的第二个开始和每一组的地一个开始比的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; len; i++) &#123;     </span><br><span class="line">                <span class="comment">//j是每一组第一个元素的下标</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - d; j &gt;= <span class="number">0</span>; j -= d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt; nums[j + d]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> t = nums[j];</span><br><span class="line">                        nums[j] = nums[j + d];</span><br><span class="line">                        nums[j + d] = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>时间复杂度： O(n^2)<br>空间复杂度： O(1)<br>稳定性： 是一种稳定排序</p>
<p>注意事项：</p>
<ol>
<li>冒泡排序产生的子序列一定是全局有序的。这个和插入排序是不一样的。</li>
<li>走2次冒泡排序，两个数字有序</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//冒泡n-1次，每次把小的元素都往前面放</span></span><br><span class="line">        <span class="comment">//第i次循环，就归位了[0...i]的序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//每次从最后一个元素出发，和前面元素相比较</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="comment">//如果比前面元素小，就交换位置</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j - <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = nums[j - <span class="number">1</span>];</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = t;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="keyword">false</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>时间复杂度： 当元素基本有序，或者基本无序的时候是最坏O(n^2)，正常O(N*logN)<br>空间复杂度： 最好O(logN)，最换O(N)，平均O(logN)<br>稳定性： 快排自然是不稳定的</p>
<p>注意：</p>
<ol>
<li>当每次partition返回的索引都能将对应区间分成左面n/2,右面n/2，这样的快排是最快的，反而如果全部是数字是全部有序，或者全部无序，这样的partition总能将指定的区间变成左面1,右面n-1，导致递归层数很深，系统栈调用深，从而这种快排是很慢的。</li>
<li>快排跑了几次，就有几个数字是归位的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//q返回每一轮快排归位的元素的索引</span></span><br><span class="line">            q = partition2(nums, l, r);</span><br><span class="line">            <span class="comment">//递归处理左右区间</span></span><br><span class="line">            quickSort(nums, l, q - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, q + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//x是基准数，i是比基准数小的最后一个数字的索引</span></span><br><span class="line">        <span class="keyword">int</span> x, i, j, t;</span><br><span class="line">        <span class="comment">//选区间内部最后一个数字作为基准数</span></span><br><span class="line">        x = nums[r];</span><br><span class="line">        i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//开始遍历数字</span></span><br><span class="line">        <span class="keyword">for</span> (j = l; j &lt; r; j++) &#123;</span><br><span class="line">            <span class="comment">//如果当前数字比基准数小，即当前数字属于左面区间</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; x) &#123;</span><br><span class="line">                <span class="comment">//就把数放到i区间里面</span></span><br><span class="line">                i++;</span><br><span class="line">                t = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基准数归位，因为此时i指向的比基准数小的最后一个数字，这个元素的下一个就是</span></span><br><span class="line">        <span class="comment">//比基准数大的数字，让i的下一个(比基准数大的数)与基准数交换</span></span><br><span class="line">        t = nums[i + <span class="number">1</span>];</span><br><span class="line">        nums[i + <span class="number">1</span>] = nums[r];</span><br><span class="line">        nums[r] = t;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以第一个数字为基准数</span></span><br><span class="line">        <span class="keyword">int</span> x = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//从右面找第一个比基准数小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt;= x) r--;</span><br><span class="line">            <span class="comment">//这里是可以直接放的，基准数已经被记录了</span></span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="comment">//从左面找第一个比基准数大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= x) l++;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[l] = x;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Main().quickSort(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="三色问题"><a href="#三色问题" class="headerlink" title="三色问题"></a>三色问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//三色问题，一个数组里面只有三种颜色，以O(n)的时间排成Red，White，Blue的顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//颜色数组</span></span><br><span class="line">        String[] color = &#123;<span class="string">"Red"</span>, <span class="string">"White"</span>, <span class="string">"Blue"</span>, <span class="string">"Red"</span>, <span class="string">"White"</span>, <span class="string">"Blue"</span>, <span class="string">"White"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i前面都是红色[0,i-1]，k后面都是蓝色[k+1,len-1]，白色是[i,k]</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = color.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= k) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (color[j]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"Red"</span>: &#123;</span><br><span class="line">                    <span class="comment">//交换i，j</span></span><br><span class="line">                    String t = color[i];</span><br><span class="line">                    color[i] = color[j];</span><br><span class="line">                    color[j] = t;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"White"</span>: &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"Blue"</span>: &#123;</span><br><span class="line">                    <span class="comment">//交换t与k</span></span><br><span class="line">                    String t = color[k];</span><br><span class="line">                    color[k] = color[j];</span><br><span class="line">                    color[j] = t;</span><br><span class="line">                    <span class="comment">//注意这里没有j++，为了防止交换后的j还是蓝色</span></span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : color) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="二分partition"><a href="#二分partition" class="headerlink" title="二分partition"></a>二分partition</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个无序数组中找到数组排序之后的指定索引k的值。</span></span><br><span class="line"><span class="comment"> * 做法有很多，</span></span><br><span class="line"><span class="comment"> *      1.给数组排序</span></span><br><span class="line"><span class="comment"> *      2.用堆</span></span><br><span class="line"><span class="comment"> *      3.这里采用二分partition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正常的partition函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以第一个数字为基准数</span></span><br><span class="line">        <span class="keyword">int</span> x = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//从右面找第一个比基准数小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt;= x) r--;</span><br><span class="line">            <span class="comment">//这里是可以直接放的，基准数已经被记录了</span></span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="comment">//从左面找第一个比基准数大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= x) l++;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[l] = x;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//要找到nums数组里面排序后索引为3的值</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = partition(nums, l, r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据parititoin的返回值index将k分为两个区间，然后对对应的区间进行partitoin</span></span><br><span class="line">        <span class="keyword">while</span> (index != k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; k) &#123;</span><br><span class="line">                index = partition(nums, index + <span class="number">1</span>, r);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; k) &#123;</span><br><span class="line">                index = partition(nums, l, index - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(nums[index]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>时间复杂度： O(n^2)<br>空间复杂度： O(1)<br>稳定性： 是一种不稳定的算法，可能外层循环跑到第i层的时候，此趟相同大小的元素，后面的元素会放在前面，因此不稳定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次选择未排序序列的最小的一个数，和索引为i的数字进行交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//排序n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//min是每次选取未排序区间的最小值的索引</span></span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="comment">//在[i,len-1]里面找最小值的索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把最小值放到第i个位置上</span></span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = nums[i];</span><br><span class="line">                nums[i] = nums[min];</span><br><span class="line">                nums[min] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>


<h1 id="其他章节"><a href="#其他章节" class="headerlink" title="其他章节"></a>其他章节</h1><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>N皇后自然是回溯的问题，回溯时要处理好N皇后的摆放问题与回溯基本处理<br>官方题解</p>
<p><a href="https://leetcode-cn.com/problems/n-queens/solution/nhuang-hou-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/solution/nhuang-hou-by-leetcode-solution/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结果数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ans;</span><br><span class="line">        <span class="comment">//cols存储用了哪些列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="comment">//用于记录已经存在的格子的左值(左值一样不能放)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line">        <span class="comment">//用于记录已经存在的格子的右值(右值一样不能放)</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第一层到第n-1层开始递归</span></span><br><span class="line">        dfs(ans, cols, l1, l2, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l2, <span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果递归到了最后一层</span></span><br><span class="line">        <span class="keyword">if</span> (num == n) &#123;</span><br><span class="line">            <span class="comment">//根据保存的列的下标，生成棋盘</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp = generateString(cols, n);</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//如果不符合N皇后的标准</span></span><br><span class="line">            <span class="comment">//如果列存在（不同列）</span></span><br><span class="line">            <span class="keyword">if</span> (find(cols.begin(), cols.end(), i) != cols.end()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保证左值不存在（不在一个对角线）</span></span><br><span class="line">            <span class="keyword">int</span> left = num - i;</span><br><span class="line">            <span class="keyword">if</span> (find(l1.begin(), l1.end(), left) != l1.end())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//保证右值不存在</span></span><br><span class="line">            <span class="keyword">int</span> right = num + i;</span><br><span class="line">            <span class="keyword">if</span> (find(l2.begin(), l2.end(), right) != l2.end())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果这个位置可以放，就往下递归</span></span><br><span class="line">            cols.push_back(i);</span><br><span class="line">            <span class="comment">//记录这个格子的左值</span></span><br><span class="line">            l1.push_back(left);</span><br><span class="line">            <span class="comment">//记录这个格子的右值</span></span><br><span class="line">            l2.push_back(right);</span><br><span class="line">            <span class="comment">//往下递归</span></span><br><span class="line">            dfs(ans, cols, l1, l2, num + <span class="number">1</span>, n);</span><br><span class="line">            <span class="comment">//消除影响，回溯的保证</span></span><br><span class="line">            cols.pop_back();</span><br><span class="line">            <span class="comment">//消除这个格子的影响</span></span><br><span class="line">            l1.pop_back();</span><br><span class="line">            l2.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给的列的数字生成一个棋盘</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                s += <span class="string">'.'</span>;</span><br><span class="line">            <span class="comment">//给指定的列放Q</span></span><br><span class="line">            s[cols[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            ans.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ky</category>
      </categories>
      <tags>
        <tag>ky</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2019/08/21/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="关于数组实现的线段树的4-n的容量解释"><a href="#关于数组实现的线段树的4-n的容量解释" class="headerlink" title="关于数组实现的线段树的4*n的容量解释"></a>关于数组实现的线段树的4*n的容量解释</h1><ol>
<li>线段树不是完全二叉树，但线段树本身就是一颗平衡二叉树(最大深度和最小深度的差值不会超过1)，而且线段树可以近似看成一个满的二叉树，只不过在没有节点的地方放的空节点来代替节点来形成满二叉树，如图<br><img src="/image/segtree1.png" alt></li>
<li>还有一个规律，对于一颗深度为h的线段树，假设深度是从0开始计的(那么行数分别是0,1,2…h-1)，那么可以看出第0行有1个节点(2^0)，第一行有2个节点(2^1)，第二行有4个节点(2^2)，那么可以得出第h-1行有(2^(h-1))个节点，那么根据等比数列的前n项和可以得出这一颗深度为h的线段树总共有2^h-1个节点，那么注意，最后一行(第h-1行)的节点个数是2^(h-1)个，可以化简为2^h/2，近似可以看成占了整棵数的一半的节点个数(实则可以根据刚才的式子可以看出是占了一半多一点点，因为最后一行的个数是2^h的一半，而总共的个数是2^h-1,)，而深度为h的线段树中除了最后一行的节点个数为2^h-1-2^h/2<br><img src="/image/segtree2.png" alt></li>
<li>知道了上面的规律以后就可以知道当一个数组有n个元素的时候，假设这个n = 2^k，也就是说在第k层的时候，数组中n个数都被放到了线段树的第k层中，那么只需要2n个元素的位置就可以以线段树的形式完全存放这个数组了。因为最后一行是n个，上面的是比n个小一点的，如果用2n个空间就足够了。那么在假设一个最坏的情况，也就是n = 2^k+1的时候，这时候第k行把数组中n个元素都放进去之后，再有一个元素放到第k+1行中，那么依照满二叉树的性质，就至少需要4n个空间了，原理同上，第k及往上一共是2n个，第k+1行又是2n的两倍，自然全部的元素个数需要4n了，这也就是线段树一般需要4n个内存的原因。 </li>
</ol>
<h1 id="点"><a href="#点" class="headerlink" title="点"></a>点</h1><ol>
<li><p>因为这里是把线段树看做一颗满二叉树来用的，所以自然就是用数组来实现比较方便。</p>
</li>
<li><p>这里的线段树的操作只有建树，区间查询，单点修改。(没有区间的惰性修改)</p>
</li>
<li><p>实质上能对线段树进行修改的索引只有treeIndex，而treeIndex位置上的只有区间节点和普通节点，在treeIndex索引对应的是区间节点的时候,tree[treeIndex]对应的是一个区间的merger操作产生的值，也就是说处理这个节点的时候要像处理区间一样处理，当treeIndex索引对应的是一个叶子节点的话，tree[treeIndex]的值是原数组中的值。</p>
</li>
<li><p>线段树的基本操作</p>
<ol>
<li><p>建树</p>
<ol>
<li>数组建树<ol>
<li>首先得有一个原数组data，先创建一个4倍data数组长度的线段树数组tree，然后递归创建tree数组</li>
<li>递归的作用就是每次把tree[treeIndex]的值确定好，并且把treeIndex的左右子树都建立好，每次递归都需要传递treeIndex(通过这个索引可以访问到tree中的值，如果是区间节点访问的就是区间值，如果是叶子节点，访问的就是普通值)，并且还要传递每个treeIndex对应的左(l)右(r)区间，当然还得有data原数组。</li>
<li>递归内容：当发现这个treeIndex的节点的左右区间相同，那么就是遍历到叶子节点了，那就把tree[treeIndex]赋值成对应的原数组中的内容data[l]，如果左右区间不同的时候，就继续递归当前这个节点的左右子区间，在递归完左右子区间之后，把左右子区间的值merge一下，即<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tree[treeIndex] = merger.merger(tree[leftIndex],tree[rightIndex])`</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>区间查询</p>
<ol>
<li>数组区间查询<ol>
<li>如果发现当前节点的区间就是所查询的区间，就直接返回当前treeIndex上的值，如果不是那就分情况讨论查询的区间在当前区间的位置，如果查询的区间完全在当前区间的左边，那就从当前区间的左区间开始查，如果是右面那就从当前区间的右区间开始查，如果查询的区间正好在中间一部分，也就是左右区间都有涉及，那就把要查询的区间以当前所在的区间的中点分段查询，然后分别统计两段区间的值，然后merger</li>
</ol>
</li>
</ol>
</li>
<li><p>单点修改</p>
<ol>
<li><p>数组的单点修改</p>
<ol>
<li><p>如果修改的index就是当前区间(那一定是叶子节点)对应的index，就直接修改，否则看index在treeIndex对应的区间中是在左半边还是右半边，index在treeIndex区间的左半边的话就往左半边进行递归，右半边就往右半边递归，在递归完之后，再把当前treeIndex上的值进行更新，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex])</span><br></pre></td></tr></table></figure>

<p>因为不管是<code>tree[leftTreeIndex]</code>还是<code>tree[rightTreeIndex]</code>都在递归中被更新了，因为子节点是先被更新的</p>
</li>
</ol>
</li>
<li><p>区间修改,</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>用数组实现线段树时，每次递归时的l,r其实就是线段树中索引为treeIndex的左右区间，所以l,r是不能随便改变的。(因为没有封装，所以只能以形参的形式传递)</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="Merger接口"><a href="#Merger接口" class="headerlink" title="Merger接口"></a>Merger接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Merger</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">merge</span><span class="params">(E a, E b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组实现线段树"><a href="#数组实现线段树" class="headerlink" title="数组实现线段树"></a>数组实现线段树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] tree;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> Merger&lt;E&gt; merger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(E[] arr, Merger&lt;E&gt; merger)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.merger = merger;</span><br><span class="line"></span><br><span class="line">        data = (E[])<span class="keyword">new</span> Object[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i ++)</span><br><span class="line">            data[i] = arr[i];</span><br><span class="line"></span><br><span class="line">        tree = (E[])<span class="keyword">new</span> Object[<span class="number">4</span> * arr.length];</span><br><span class="line">        buildSegmentTree(<span class="number">0</span>, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在treeIndex的位置创建表示区间[l...r]的线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历到节点的时候，自然就是把节点上的值赋值到tree数组中</span></span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            tree[treeIndex] = data[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到当前节点的左孩子所在的节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="comment">//拿到右孩子的节点</span></span><br><span class="line">        <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int mid = (l + r) / 2;</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        buildSegmentTree(leftTreeIndex, l, mid);</span><br><span class="line">        buildSegmentTree(rightTreeIndex, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在一个节点的左右子树都建造完事后，就需要把当前节点的值变更成merger了两个子树的内容</span></span><br><span class="line">        tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal."</span>);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*index + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回区间[queryL, queryR]的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(queryL &lt; <span class="number">0</span> || queryL &gt;= data.length ||</span><br><span class="line">                queryR &lt; <span class="number">0</span> || queryR &gt;= data.length || queryL &gt; queryR)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>, queryL, queryR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值,注意这个l,r必须是treeIndex对应的l和r，不能更改为queryL和qeuryR</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前遍历到的区间就是索要查询的区间，那么tree中代表这个的区间的值就是要查询的区间的值</span></span><br><span class="line">        <span class="keyword">if</span>(l == queryL &amp;&amp; r == queryR)</span><br><span class="line">            <span class="keyword">return</span> tree[treeIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// treeIndex的节点分为[l...mid]和[mid+1...r]两部分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line">        <span class="comment">//如果所查询的区间在当前区间的右半段的话</span></span><br><span class="line">        <span class="keyword">if</span>(queryL &gt;= mid + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> query(rightTreeIndex, mid + <span class="number">1</span>, r, queryL, queryR);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(queryR &lt;= mid)<span class="comment">//如果是左半段的话</span></span><br><span class="line">            <span class="keyword">return</span> query(leftTreeIndex, l, mid, queryL, queryR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果左右区间都有的占到的话，就分段取值，再统计分段后的值</span></span><br><span class="line">        E leftResult = query(leftTreeIndex, l, mid, queryL, mid);</span><br><span class="line">        E rightResult = query(rightTreeIndex, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, queryR);</span><br><span class="line">        <span class="keyword">return</span> merger.merge(leftResult, rightResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将index位置的值，更新为e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= data.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Index is illegal"</span>);</span><br><span class="line"></span><br><span class="line">        data[index] = e;</span><br><span class="line">        set(<span class="number">0</span>, <span class="number">0</span>, data.length - <span class="number">1</span>, index, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在以treeIndex为根的线段树中更新index的值为e</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> treeIndex, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这就是遍历到index的那个节点的时候</span></span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            tree[treeIndex] = e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// treeIndex的节点分为[l...mid]和[mid+1...r]两部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左右子树逐渐遍历到节点</span></span><br><span class="line">        <span class="keyword">int</span> leftTreeIndex = leftChild(treeIndex);</span><br><span class="line">        <span class="keyword">int</span> rightTreeIndex = rightChild(treeIndex);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= mid + <span class="number">1</span>)</span><br><span class="line">            set(rightTreeIndex, mid + <span class="number">1</span>, r, index, e);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// index &lt;= mid</span></span><br><span class="line">            set(leftTreeIndex, l, mid, index, e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时在treeIndex这里，index其实相当于是treeIndex的子节点，因为index已经更新过，所以再更新treeIndex</span></span><br><span class="line">        tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tree.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[i] != <span class="keyword">null</span>)</span><br><span class="line">                res.append(tree[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.append(<span class="string">"null"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i != tree.length - <span class="number">1</span>)</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表实现线段树"><a href="#链表实现线段树" class="headerlink" title="链表实现线段树"></a>链表实现线段树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkArrSegTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="comment">//每个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</span><br><span class="line">        <span class="comment">//把一个节点的左右区间封装到节点内部中</span></span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        E value;</span><br><span class="line">        <span class="comment">//左右孩子也是</span></span><br><span class="line">        SegmentTreeNode leftChild;</span><br><span class="line">        SegmentTreeNode rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeNode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.l = l;</span><br><span class="line">            <span class="keyword">this</span>.r = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SegmentTreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    Merger&lt;E&gt; merger;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把nums数组按照merger操作造成一颗线段树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkArrSegTree</span><span class="params">(E[] nums,Merger&lt;E&gt; merger)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先把merger操作复制了</span></span><br><span class="line">        <span class="keyword">this</span>.merger = merger;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为了类中的成员变量能访问到nums的内容，所以让data代替nums</span></span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            data[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从根节点开始建树</span></span><br><span class="line">        root = build(<span class="number">0</span>, data.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个区间范围是l~r的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SegmentTreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不管啥先创建一个新的节点</span></span><br><span class="line">        SegmentTreeNode node = <span class="keyword">new</span> SegmentTreeNode(l,r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果遍历到了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            node.value = data[l];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        node.leftChild = build(l, mid);</span><br><span class="line">        node.rightChild = build(mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        node.value = merger.merge(node.leftChild.value, node.rightChild.value);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询区间queryL到queryR的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">query</span><span class="params">(<span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要从根节点开始查找区间</span></span><br><span class="line">        <span class="keyword">return</span> query(root, queryL, queryR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次查询递归的函数,treeNode对应的区间已经封装在treeNode节点里面了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">query</span><span class="params">(SegmentTreeNode treeNode, <span class="keyword">int</span> queryL, <span class="keyword">int</span> queryR)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (treeNode.l == queryL &amp;&amp; treeNode.r == queryR)&#123;</span><br><span class="line">            <span class="keyword">return</span> treeNode.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = treeNode.l + (treeNode.r - treeNode.l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (queryL &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> query(treeNode.rightChild, queryL, queryR);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (queryR &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> query(treeNode.leftChild, queryL, queryR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        E leftResult = query(treeNode.leftChild, queryL, mid);</span><br><span class="line">        E rightResult = query(treeNode.rightChild, mid + <span class="number">1</span>, queryR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merger.merge(leftResult,rightResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把index索引位置上的值更新为e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">        data[index] = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新线段树的某个点需要从树的根节点开始更新</span></span><br><span class="line">        update(root, index, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是真正用来递归的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(SegmentTreeNode treeNode, <span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (treeNode.l == index &amp;&amp; treeNode.r == index)&#123;</span><br><span class="line">            treeNode.value = e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = treeNode.l + (treeNode.r - treeNode.l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            update(treeNode.rightChild, index, e);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &lt;= mid)&#123;</span><br><span class="line">            update(treeNode.leftChild,index, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        treeNode.value = merger.merge(treeNode.leftChild.value, treeNode.rightChild.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/02/05/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Test().selectSort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="comment">//每次从i开始选择最小的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[min])</span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//选择出来之后和i换，然后i后移</span></span><br><span class="line">            <span class="keyword">int</span> t = a[i];</span><br><span class="line">            a[i] = a[min];</span><br><span class="line">            a[min] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
